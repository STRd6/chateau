{
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "content": "MIT License\n\nCopyright (c) 2017 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "mode": "100644",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "content": "# chateau\nRemake of thepalace.com\n",
      "mode": "100644",
      "type": "blob"
    },
    "chateau.coffee": {
      "path": "chateau.coffee",
      "content": "# Chat Based MUD\n\nChateauPresenter = require \"./presenters/chateau\"\nModel = require \"model\"\n{Modal, Observable} = UI = require \"ui\"\nDrop = require \"./lib/drop\"\n\nAuth = require \"./module/auth\"\nRenderer = require \"./module/renderer\"\n\nshaUpload = require \"./sha-upload\"\n\nrand = (n) ->\n  Math.floor(Math.random() * n)\n\nMember = require \"./models/member\"\nRoom = require \"./models/room\"\n\nProp = Member\n\nmodule.exports = (I={}, self=Model(I)) ->\n\n  self.include require \"./module/auth\"\n\n  self.extend\n    displayNameInput: Observable \"duder\"\n\n    displayNameFormClass: ->\n      \"changed\" if self.displayNameInput() != self.displayName()\n\n    displayNameFormSubmit: (e) ->\n      e.preventDefault()\n      self.currentUser().update\n        name: self.displayNameInput()\n      .sync()\n\n    resetDisplayNameInput: (e) ->\n      e?.preventDefault()\n\n      self.displayNameInput self.displayName()\n\n    displayName: ->\n      self.currentUser()?.name() or \"\"\n\n    currentRoom: Observable null\n    currentUser: Observable null\n    avatars: Observable [\n      \"https://1.pixiecdn.com/sprites/148517/original.png\"\n      \"https://0.pixiecdn.com/sprites/148468/original.png\"\n      \"https://2.pixiecdn.com/sprites/137922/original.png\"\n      \"https://1.pixiecdn.com/sprites/147597/original.png\"\n      \"https://1.pixiecdn.com/sprites/151181/original.png\"\n      \"https://1.pixiecdn.com/sprites/150973/original.png\"\n      \"https://3.pixiecdn.com/sprites/151199/original.png\"\n      \"https://3.pixiecdn.com/sprites/151187/original.png\"\n      \"https://0.pixiecdn.com/sprites/151140/original.png\"\n      \"https://3.pixiecdn.com/sprites/150719/original.png\"\n      \"https://1.pixiecdn.com/sprites/151149/original.png\"\n      \"https://2.pixiecdn.com/sprites/151046/original.png\"\n    ].map (url) -> avatarURL: url\n    rooms: Observable []\n    props: Observable [\n      \"https://1.pixiecdn.com/sprites/151213/original.png\"\n      \"https://3.pixiecdn.com/sprites/151203/original.png\"\n      \"https://0.pixiecdn.com/sprites/148204/original.png\"\n      \"https://1.pixiecdn.com/sprites/148365/original.png\"\n      \"https://2.pixiecdn.com/sprites/148330/original.png\"\n      \"https://1.pixiecdn.com/sprites/148333/original.png\"\n      \"https://1.pixiecdn.com/sprites/148329/original.png\"\n      \"https://1.pixiecdn.com/sprites/137441/original.png\"\n      \"https://0.pixiecdn.com/sprites/137380/original.png\"\n    ].map (url) -> imageURL: url\n\n    displayModalLoader: (message) ->\n      progressView = UI.Progress\n        message: message\n      Modal.show progressView.element,\n        cancellable: false\n\n    currentAccountId: ->\n      self.firebaseUser()?.uid\n\n    accountConnected: (firebaseUser) ->\n      unless firebaseUser\n        stats.increment \"accountDisconnected\"\n        return\n\n      stats.increment \"accountConnected\"\n\n      providerDisplayName = null\n      providerPhoto = null\n\n      # Get provider data\n      firebaseUser.providerData.forEach (profile) ->\n        providerDisplayName ?= profile.displayName\n        providerPhoto ?= profile.photoURL\n\n      user = Member.find(firebaseUser.uid)\n      self.currentUser user\n\n      self.displayModalLoader \"Loading...\"\n      user.connect().then ->\n        unless user.name()\n          user.name providerDisplayName\n        self.resetDisplayNameInput()\n\n        self.currentUser().updatePresence(\"\")\n\n        Modal.hide()\n\n        # Display Avatar Drawer unless user has avatar\n        new Promise (resolve, reject) ->\n          if user.imageURL()\n            resolve()\n          else\n            self.element.querySelectorAll(\"tab-drawer > *\").forEach (element) ->\n              element.classList.remove(\"show\")\n            self.element.querySelector(\"avatar-control\").classList.add(\"show\")\n\n            checkForAvatarURL = (value) ->\n              if value\n                user.imageURL.stopObserving checkForAvatarURL\n                resolve()\n\n            user.imageURL.observe checkForAvatarURL\n      .then ->\n        # Connect to previously connected room\n        previousRoom = Room.find(user.roomId())\n        if previousRoom\n          # Need to force join because currentRoom will be equal to previousRoom\n          self.joinRoom previousRoom, true\n        else\n          # Display Rooms drawer\n          self.element.querySelectorAll(\"tab-drawer > *\").forEach (element) ->\n            element.classList.remove(\"show\")\n          self.element.querySelector(\"room-control\").classList.add(\"show\")\n\n    createRoom: ->\n      Modal.prompt(\"Room name\", \"a fun room\")\n      .then (name) ->\n        if name\n          db.ref(\"rooms\").push\n            name: name\n\n    clearAllProps: ->\n      self.currentRoom().clearAllProps()\n\n    addProp: (prop) ->\n      stats.increment \"prop.add\"\n      self.currentRoom().addProp prop\n\n    setBackgroundURL: (backgroundURL) ->\n      room = self.currentRoom()\n      room.imageURL(backgroundURL)\n      room.sync()\n\n    setAvatar: (avatarURL) ->\n      self.currentUser()\n      .update\n        imageURL: avatarURL\n      .sync()\n\n    joinRoom: (room) ->\n      if room is self.currentRoom()\n        return\n\n      user = self.currentUser()\n      accountId = user?.key()\n      return unless accountId\n\n      stats.increment \"rooms.join\"\n\n      previousRoom = self.currentRoom()\n\n      previousRoom?.leave(accountId)\n      room.join(accountId)\n\n      user.roomId room.key()\n      user.sync()\n\n      self.currentRoom room\n\n      return\n\n    saySubmit: (e) ->\n      e.preventDefault()\n\n      input = e.currentTarget.querySelector('input')\n      words = input.value\n      if words\n        input.value = \"\"\n\n        self.currentRoom()?.addRoomEvent\n          source: self.currentAccountId()\n          type: \"chat\"\n          content:\n            sender: self.displayName()\n            message: words\n\n        self.currentUser().ref().child(\"text\").onDisconnect().remove()\n        self.currentUser().update\n          text: words\n        .sync(db)\n      else\n        self.currentUser().ref().child(\"text\").remove()\n\n    words: ->\n      self.currentRoom()?.members.map (member) ->\n        member.wordElement()\n\n  self.include Renderer\n  self.include Auth\n  self.initializeAuth()\n\n  do -> # General App Connectivity\n    # Populate Rooms list\n    db.ref(\"rooms\").on \"child_added\", (room) ->\n      key = room.key\n      value = room.val()\n\n      delete value.props\n\n      stats.increment \"rooms.child_added\"\n      room = Room.find(key).update value\n\n      self.rooms.push room\n\n  self.firebaseUser.observe self.accountConnected\n\n  self.element = element = ChateauPresenter self\n  Drop element, (e) ->\n    files = e.dataTransfer.files\n\n    if files.length\n      # TODO: Process multiple files\n      file = files[0]\n\n      stats.increment \"drop-file\"\n\n      shaUpload(firebase, file)\n      .then (downloadURL) ->\n        Modal.form require(\"./templates/asset-form\")()\n        .then (result) ->\n          switch result?.selection\n            when \"avatar\"\n              self.setAvatar downloadURL\n\n            when \"background\"\n              self.setBackgroundURL downloadURL\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "extensions.coffee": {
      "path": "extensions.coffee",
      "content": "Blob::readAsArrayBuffer = ->\n  file = this\n\n  new Promise (resolve, reject) ->\n    reader = new FileReader\n    reader.onload = ->\n      resolve reader.result\n    reader.onerror = reject\n    reader.readAsArrayBuffer(file)\n\n# Extend promises with `finally`\n# From: https://github.com/domenic/promises-unwrapping/issues/18\nPromise::finally ?= (callback) ->\n  # We don’t invoke the callback in here,\n  # because we want then() to handle its exceptions\n  this.then(\n    # Callback fulfills: pass on predecessor settlement\n    # Callback rejects: pass on rejection (=omit 2nd arg.)\n    (value) ->\n      Promise.resolve(callback())\n      .then -> return value\n    (reason) ->\n      Promise.resolve(callback())\n      .then -> throw reason\n  )\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/drop.coffee": {
      "path": "lib/drop.coffee",
      "content": "module.exports = (element, handler) ->\n  cancel = (e) ->\n    e.preventDefault()\n    return false\n\n  element.addEventListener \"dragover\", cancel\n  element.addEventListener \"dragenter\", cancel\n  element.addEventListener \"drop\", (e) ->\n    e.preventDefault()\n    handler(e)\n    return false\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/feedback-tab.coffee": {
      "path": "lib/feedback-tab.coffee",
      "content": "module.exports = (href) ->\n  tab = document.createElement 'a'\n  tab.textContent = \"Feedback\"\n  tab.id = \"feedback\"\n  tab.href = href\n  tab.target = \"_blank\"\n\n  return tab\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/logger.coffee": {
      "path": "lib/logger.coffee",
      "content": "module.exports = (bus) ->\n  logFn = (label) ->\n    ->\n      bus [label, arguments...]\n\n  self = {}\n\n  [\"error\", \"warn\", \"debug\", \"info\", \"log\"].forEach (label) ->\n    self[label] = logFn(label)\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/open-promise.coffee": {
      "path": "lib/open-promise.coffee",
      "content": "module.exports = ->\n  _resolve = _reject = null\n  promise = new Promise (resolve, reject) ->\n    _resolve = resolve\n    _reject = reject\n\n  promise.resolve = _resolve\n  promise.reject = _reject\n\n  return promise\n",
      "mode": "100644",
      "type": "blob"
    },
    "lib/stats.coffee": {
      "path": "lib/stats.coffee",
      "content": "module.exports = ->\n  stats = {}\n\n  self =\n    increment: (bucket, amount=1) ->\n      stats[bucket] ?= 0\n      stats[bucket] += amount\n\n    decrement: (bucket, amount=1) ->\n      self.increment(bucket, -amount)\n\n    stats: stats\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "main.coffee": {
      "path": "main.coffee",
      "content": "Chateau = require \"./chateau\"\n\nif PACKAGE.name is \"ROOT\"\n  require(\"analytics\").init(\"UA-3464282-15\")\n\n  {Style} = require \"ui\"\n  style = document.createElement \"style\"\n  style.innerHTML = Style.all + \"\\n\" + require(\"./style\")\n  document.head.appendChild style\n\n  # Initialize Firebase\n  firebase.initializeApp\n    apiKey: \"AIzaSyCnhTPOri3XGQ0q5pw0u8dRPZQwr74fpuw\"\n    authDomain: \"chateau-f2799.firebaseapp.com\"\n    databaseURL: \"https://chateau-f2799.firebaseio.com\"\n    storageBucket: \"chateau-f2799.appspot.com\"\n    messagingSenderId: \"2073045470\"\n\n  global.logger = require(\"./lib/logger\")(console.log)\n  global.stats = require(\"./lib/stats\")()\n  global.firebase = firebase\n  global.db = firebase.database()\n  db.TIMESTAMP = firebase.database.ServerValue.TIMESTAMP\n  global.defaults = require(\"./util\").defaults\n  global.chateau = Chateau()\n\n  document.body.appendChild chateau.element\n\n  document.body.appendChild require(\"./lib/feedback-tab\")(\"https://docs.google.com/forms/d/e/1FAIpQLScMur8T8VcgWGk0k-sFkNRmCiDGWAzTRTLICUC0v-W2J7rJKQ/viewform\")\nelse\n  module.exports = Chateau\n",
      "mode": "100644",
      "type": "blob"
    },
    "models/base.coffee": {
      "path": "models/base.coffee",
      "content": "# Base model generator\n#\n# Generates a model whose instances can sync and track changes in firebase\n\nOpenPromise = require \"../lib/open-promise\"\n\nModel = require \"model\"\n\nmodule.exports = (tableName, Mixin) ->\n  ModelConstructor = (I={}, self=Model(I)) ->\n    self.attrReader \"key\"\n\n    table = db.ref(tableName)\n    ref = table.child(self.key())\n\n    syncAttributes = []\n\n    self.extend\n      # List attributes to keep in sync\n      attrSync: (names...) ->\n        self.attrObservable names...\n\n        syncAttributes = syncAttributes.concat names\n      \n      # TODO: Currently only using this to track when the current user\n      # has refreshed from firebase\n      connect: ->\n        return connectedPromise\n\n      # Stop tracking updates from the server\n      disconnect: ->\n        stats.increment \"#{tableName}.disconnect\"\n        ref.off \"value\", update\n\n      # Update our state to match the given data\n      update: (data) ->\n        return unless data\n        stats.increment \"#{tableName}.update\"\n\n        Object.keys(data).forEach (key) ->\n          self[key]? data[key]\n\n        return self\n\n      ref: ->\n        ref\n\n      # Sync our local state to the server\n      # TODO: success/fail promise?\n      sync: ->\n        stats.increment \"#{tableName}.sync\"\n\n        # TODO: Only send changed\n        data = syncAttributes.reduce (memo, name) ->\n          memo[name] = self[name]()\n\n          return memo\n        , {}\n\n        ref.update data\n\n    self.include Mixin\n\n    # Track all server updates\n    # TODO: Fine grained tracking control\n    connectedPromise = OpenPromise()\n    update = (snap) ->\n      connectedPromise.resolve() # TODO: Rethink this\n      self.update snap.val()\n    ref.on \"value\", update\n\n    return self\n\n  # Add class methods on the constructor\n  identityMap = {}\n  # Use an identity map to return the same instances for the same key\n  # TODO: Allow for initializing with data\n  ModelConstructor.find = (id) ->\n    # Identity map instances by key\n    identityMap[id] ?= ModelConstructor\n      key: id\n\n  return ModelConstructor\n",
      "mode": "100644",
      "type": "blob"
    },
    "models/drawable.coffee": {
      "path": "models/drawable.coffee",
      "content": "\nmodule.exports = (I, self) ->\n  img = new Image\n\n  if self.attrSync\n    self.attrSync \"imageURL\"\n  else\n    self.attrObservable \"imageURL\"\n\n  self.extend\n    img: ->\n      img\n\n    height: ->\n      img.height | 0\n\n    width: ->\n      img.width | 0\n\n  # TODO: Cleanly swap image when loaded\n  updateImageURL = (url) ->\n    if url\n      img.src = url\n\n  self.imageURL.observe updateImageURL\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "models/member.coffee": {
      "path": "models/member.coffee",
      "content": "Base = require \"./base\"\nDrawable = require \"./drawable\"\n\nmodule.exports = Base \"members\", (I={}, self=Model(I)) ->\n  defaults I,\n    name: \"\"\n    roomId: null\n    text: \"\"\n    x: 480\n    y: 270\n\n  self.include Drawable\n\n  self.attrSync \"x\", \"y\", \"text\", \"name\", \"roomId\"\n\n  wordElement = document.createElement \"words\"\n\n  self.extend\n    updatePosition: ({x, y}) ->\n      self.x x\n      self.y y\n\n    wordElement: ->\n      wordElement\n\n    updatePresence: (status) ->\n      presenceRef = db.ref(\"presence/#{self.key()}\")\n\n      presenceRef.child(\"online\").onDisconnect().set false\n      presenceRef.child(\"lastSeen\").onDisconnect().set db.TIMESTAMP\n      presenceRef.update\n        online: true\n        lastSeen: db.TIMESTAMP\n        status: status\n\n  updateTextPosition = ->\n    if self.text()\n      wordElement.style.left = \"#{self.x()}px\"\n      wordElement.style.top = \"#{self.y() - self.height()/2 - 30}px\"\n    else\n      wordElement.style.left = \"-100%\"\n\n  self.text.observe (text) ->\n    wordElement.textContent = text\n    updateTextPosition()\n\n  self.x.observe updateTextPosition\n  self.y.observe updateTextPosition\n  self.imageURL.observe updateTextPosition\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "models/prop.coffee": {
      "path": "models/prop.coffee",
      "content": "Model = require \"model\"\n\nDrawable = require \"./drawable\"\n\nmodule.exports = Prop = (I={}, self=Model(I)) ->\n  defaults I,\n    x: 480\n    y: 270\n\n  self.include Drawable\n\n  self.attrReader \"key\", \"roomId\"\n  self.attrObservable \"x\", \"y\"\n\n  update = (snap) ->\n    self.update snap.val()\n\n  table = db.ref(\"rooms/#{self.roomId()}/props\")\n  ref = table.child(self.key())\n\n  self.extend\n    connect: ->\n\n    disconnect: ->\n      ref.off \"value\", update\n\n      return self\n\n    updatePosition: ({x, y}) ->\n      self.x x\n      self.y y\n\n    update: (data) ->\n      return unless data\n      stats.increment \"props.update\"\n\n      Object.keys(data).forEach (key) ->\n        self[key]? data[key]\n\n      return self\n\n    sync: ->\n      ref.update\n        x: self.x()\n        y: self.y()\n\n  ref.on \"value\", update\n\n  return self\n\nidentityMap = {}\n\nProp.find = (key) ->\n  # Identity map by keys\n  identityMap[key] ?= Prop\n    key: key\n",
      "mode": "100644",
      "type": "blob"
    },
    "models/room-event.coffee": {
      "path": "models/room-event.coffee",
      "content": "Model = require \"model\"\n\n# These events are immutable so their values never change\n# We use them to construct the chat log\n# who said what when\n# actions, sounds, emotes\n# can be used as commands in room based games too\n\nmodule.exports = RoomEvent = (I={}, self=Model(I)) ->\n  self.attrReader \"key\", \"source\", \"type\", \"content\"\n\n  return self\n\nidentityMap = {}\n\nRoomEvent.createFromSnap = (snap) ->\n  {key} = snap\n\n  return identityMap[key] if identityMap[key]\n\n  data = snap.val()\n  data.key = key\n\n  identityMap[key] = RoomEvent data\n",
      "mode": "100644",
      "type": "blob"
    },
    "models/room.coffee": {
      "path": "models/room.coffee",
      "content": "{Bindable} = require \"ui\"\nModel = require \"model\"\n\nDrawable = require \"./drawable\"\nMember = require \"./member\"\nProp = require \"./prop\"\nRoomEvent = require \"./room-event\"\n\nmodule.exports = Room = (I={}, self=Model(I)) ->\n  stats.increment \"room.initialize\"\n\n  defaults I,\n    members: []\n    events: []\n    props: []\n\n  self.attrReader \"key\"\n  self.include Bindable, Drawable\n\n  self.attrObservable \"name\"\n  self.attrModels \"members\", Member\n  self.attrModels \"props\", Prop\n  self.attrModels \"events\",  RoomEvent\n\n  table = db.ref(\"rooms\")\n  ref = table.child(self.key())\n\n  dataRef = db.ref(\"room-data/#{self.key()}\")\n\n  eventsRef = dataRef.child(\"events\")\n  membershipsRef = dataRef.child(\"memberships\")\n  propsRef = dataRef.child(\"props\")\n\n  subscribeToProp = (snap) ->\n    stats.increment \"room.subscribe-prop\"\n\n    {key} = snap\n    value = snap.val()\n\n    prop = Prop.find key\n    prop.update(value)\n\n    unless self.propByKey(key)\n      self.props.push prop\n\n  unsubscribeFromProp = ({key}) ->\n    stats.increment \"room.unsubscribe-prop\"\n\n    prop = self.propByKey(key)\n\n    if prop\n      self.props.remove prop\n      # prop.disconnect()\n\n  subscribeToMember = ({key}) ->\n    stats.increment \"room.subscribe-member\"\n\n    member = Member.find key\n    member.connect()\n\n    unless self.memberByKey(key)\n      self.members.push member\n\n  unsubscribeFromMember = ({key}) ->\n    stats.increment \"room.unsubscribe-member\"\n\n    member = self.memberByKey(key)\n\n    if member\n      self.members.remove member\n      # member.disconnect()\n\n  self.extend\n    addProp: ({imageURL}) ->\n      propsRef.push\n        x: (Math.random() * 960)|0\n        y: (Math.random() * 540)|0\n        imageURL: imageURL\n\n    join: (accountId) ->\n      # Auto-leave on disconnect\n      membershipsRef.child(accountId).onDisconnect().remove()\n      # Join\n      membershipsRef.child(accountId).set true\n\n    leave: (accountId) ->\n      membershipsRef.child(accountId).remove()\n\n    clearAllProps: ->\n      ref.child(\"props\").remove()\n\n    update: (data) ->\n      return unless data\n      stats.increment \"room.update\"\n\n      Object.keys(data).forEach (key) ->\n        self[key]? data[key]\n\n      return self\n\n    addRoomEvent: (data) ->\n      eventsRef.push data\n\n    memberByKey: (key) ->\n      [member] = self.members.filter (member) ->\n        member.key() is key\n\n      return member\n\n    propByKey: (key) ->\n      [prop] = self.props.filter (prop) ->\n        prop.key() is key\n\n      return prop\n\n    numberOfCurrentOccupants: ->\n      self.members.length\n\n    sync: ->\n      ref.update\n        imageURL: self.imageURL()\n        name: self.name()\n\n  update = (snap) ->\n    data = snap.val()\n\n    # Temporary: Remove legacy data\n    delete data.props\n    delete data.memberships\n\n    # Rename obsolete background\n    data.imageURL = data.backgroundURL\n\n    self.update data\n\n  # Keep room data up to date\n  ref.on \"value\", update\n\n  # Listen for all members, props, events\n  membershipsRef.on \"child_added\", subscribeToMember\n  membershipsRef.on \"child_removed\", unsubscribeFromMember\n\n  propsRef.on \"child_added\", subscribeToProp\n  propsRef.on \"child_removed\", unsubscribeFromProp\n\n  eventsRef.on \"child_added\", (snap) ->\n    roomEvent = RoomEvent.createFromSnap(snap)\n    self.events.push roomEvent\n\n    self.trigger \"eventAdded\", roomEvent\n\n  return self\n\nidentityMap = {}\nRoom.find = (id) ->\n  return unless id\n\n  stats.increment \"room.find\"\n\n  identityMap[id] ?= Room\n    key: id\n\nV = (fn) ->\n  (data) -> fn data.val()\n",
      "mode": "100644",
      "type": "blob"
    },
    "module/auth.coffee": {
      "path": "module/auth.coffee",
      "content": "# Basic Firebase Auth and Presence Mix-in\n\n# We display a modal until the person is authenticated\n# then pass control back to the source\n\n# We also set up basic account presence indicators\n\n{Modal, Observable} = UI = require \"ui\"\n\nLoginTemplate = require(\"../templates/login\")\n\nmodule.exports = (I, self) ->\n\n  # This always triggers one disconnected if we attach before we are connected\n  monitorConnectionStatus = ->\n    db.ref(\".info/connected\").on \"value\", (snap) ->\n      connected = snap.val()\n\n      if connected\n        self.connectionStatus \"Connected\"\n        stats.increment \"connect\"\n        # TODO: Remove room membership onDisconnect\n        # TODO: Update presence\n\n      else\n        self.connectionStatus \"Disconnected\"\n        stats.increment \"disconnected\"\n\n  # Initialize auth state\n  initializeAuth = ->\n    self.displayModalLoader(\"Initializing...\")\n\n    firebase.auth().onAuthStateChanged (user) ->\n      stats.increment \"authStateChanged\"\n\n      if user\n        # User is signed in.\n        Modal.hide()\n\n        self.firebaseUser(user)\n      else\n        # No user is signed in.\n        # Display modal when user is no longer signed in\n        loginTemplate = LoginTemplate(self)\n        Modal.show loginTemplate,\n          cancellable: false\n\n  self.extend\n    connectionStatus: Observable \"Disconnected\" # [Connected, Disconnected]\n    firebaseUser: Observable null # The current firebase user\n    initializeAuth: initializeAuth\n\n    logout: (e) ->\n      e?.preventDefault()\n\n      firebase.auth().signOut()\n\n    anonLogin: (e) ->\n      e.preventDefault()\n\n      firebase.auth().signInAnonymously()\n\n    googleLogin: (e) ->\n      e.preventDefault()\n\n      provider = new firebase.auth.GoogleAuthProvider()\n      provider.addScope('profile')\n      provider.addScope('email')\n      firebase.auth().signInWithPopup(provider)\n\n    facebookLogin: (e) ->\n      e.preventDefault()\n\n      provider = new firebase.auth.FacebookAuthProvider()\n      firebase.auth().signInWithPopup(provider)\n\n    twitterLogin: (e) ->\n      e.preventDefault()\n\n      provider = new firebase.auth.TwitterAuthProvider()\n      firebase.auth().signInWithPopup(provider)\n\n    githubLogin: (e) ->\n      e.preventDefault()\n\n      provider = new firebase.auth.GithubAuthProvider()\n      provider.addScope('user:email')\n      firebase.auth().signInWithPopup(provider)\n",
      "mode": "100644",
      "type": "blob"
    },
    "module/renderer.coffee": {
      "path": "module/renderer.coffee",
      "content": "drawRoom = (context, room) ->\n  backgroundImage = room.img()\n  members = room.members()\n  props = room.props()\n\n  if backgroundImage?.width\n    context.drawImage(backgroundImage, 0, 0, context.width, context.height)\n\n  # Draw Avatars/Objects\n  Object.values(members)\n  .concat(props).forEach (object) ->\n    img = object.img()\n    {width, height} = img\n    x = (object.x() - width / 2) | 0\n    y = (object.y() - height / 2) | 0\n\n    if width and height\n      context.drawImage(img, x, y)\n\ndrawAvatar = (context, member) ->\n  return unless member\n\n  img = member.img()\n  {width, height} = img\n  x = ((context.width - width) / 2) | 0\n  y = ((context.height - height) / 2) | 0\n\n  if width and height\n    context.drawImage(img, x, y)\n\nmodule.exports = (I, self) ->\n  canvas = document.createElement 'canvas'\n  canvas.width = 960\n  canvas.height = 540\n\n  context = canvas.getContext('2d')\n  context.width = canvas.width\n  context.height = canvas.height\n\n  # TODO: Drag and move props\n  canvas.onclick = (e) ->\n    {pageX, pageY, currentTarget} = e\n    {top, left} = currentTarget.getBoundingClientRect()\n\n    x = pageX - left\n    y = pageY - top\n\n    self.currentUser()\n    .update\n      x: x\n      y: y\n    .sync(db)\n\n  repaint = ->\n    context.fillStyle = 'white'\n    context.fillRect(0, 0, canvas.width, canvas.height)\n\n    if room = self.currentRoom()\n      drawRoom(context, room)\n    else if user = self.currentUser()\n      drawAvatar(context, user)\n\n    return\n\n  # Just animate forever\n  # later we can think about stopping/starting\n  animate = ->\n    requestAnimationFrame animate\n    repaint()\n  animate()\n\n  self.extend\n    canvas: canvas\n\n  return self\n",
      "mode": "100644",
      "type": "blob"
    },
    "notes.md": {
      "path": "notes.md",
      "content": "Firebase\n========\n\nAnonymous Sign In\n-----------------\n\n    firebase.auth().signInAnonymously()\n\nThis signs in anonymously and will keep the account when you return by\npersisting data in local storage.\n\nCaveat: If you call this before firebase is fully initialized it may generate a\nnew anonymous account instead of reusing the existing one.\n\nPush Key Uniqueness\n-------------------\n\nPush keys are unique enough to be considered globally unique.\n\nhttp://stackoverflow.com/a/38498220/68210\n\nSorting, Filtering, Pagination\n------------------------------\n\nTODO: Get a good handle on this.\n\nSyncing Models\n--------------\n\nThere's some nuance to syncing only the minimal amount of live data with models,\nespecially with compositions.\n\nTODO: Concrete examples and cookbook.\n\nShallow Data\n------------\n\nIn order to scope syncing, security rules, limit unnecessary data in queries,\nmaking many shallow compositions related by a shared key is the recommended way.\n\nTODO: Examples and cookbook\n\n\nHandling Log In\n---------------\n\nDetect when the user has logged in or out and firebase has finished initializing.\n\n    firebase.auth().onAuthStateChanged (user) ->\n      if user\n        # User is signed in.\n      else\n        # No user is signed in.\n\nFAQ\n---\n\n`ref.on` is not working... make sure you've set \".read\" permission in the\nsecurity rules ya dummy!",
      "mode": "100644",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "content": "width: 960\nheight: 540\nremoteDependencies: [\n  \"https://www.gstatic.com/firebasejs/3.6.7/firebase.js\"\n]\ndependencies:\n  analytics: \"distri/google-analytics:v0.1.0\"\n  model: \"distri/model:master\"\n  ui: \"STRd6/ui:master\"\n",
      "mode": "100644",
      "type": "blob"
    },
    "presenters/chateau.coffee": {
      "path": "presenters/chateau.coffee",
      "content": "AvatarTemplate = require \"../templates/avatar\"\nChateauTemplate = require \"../templates/chateau\"\nPropTemplate = require \"../templates/prop\"\nRoomTemplate = require \"../templates/room\"\n\nAvatarPresenter = (avatar, self) ->\n  stats.increment \"presenter.avatar\"\n\n  AvatarTemplate Object.assign {}, avatar,\n    click: (e) ->\n      e.preventDefault()\n      self.setAvatar avatar.avatarURL\n\nRoomPresenter = (room, self) ->\n  stats.increment \"presenter.room\"\n\n  RoomTemplate Object.assign {}, room,\n    click: (e) ->\n      e.preventDefault()\n      self.joinRoom room\n\nPropPresenter = (prop, self) ->\n  stats.increment \"presenter.prop\"\n\n  PropTemplate Object.assign {}, prop,\n    click: (e) ->\n      e.preventDefault()\n      self.addProp prop\n\nLogPresenter = (event) ->\n  stats.increment \"presenter.log\"\n\n  switch event.type()\n    when \"chat\"\n      log = document.createElement \"log\"\n\n      {sender, message} = event.content()\n\n      log.textContent = \"#{sender}: #{message}\"\n\n      return log\n\nmodule.exports = (self) ->\n  roomsLogElements = {}\n\n  findOrInitRoomLogs = (room) ->\n    key = room.key()\n\n    return roomsLogElements[key] if roomsLogElements[key]\n\n    logsElement = document.createElement 'logs'\n\n    # Use this trick to escape auto-binding room events observable\n    setTimeout ->\n      room.events.forEach (event) ->\n        logsElement.appendChild LogPresenter event\n      room.on \"eventAdded\", (event) ->\n        logsElement.appendChild LogPresenter event\n    , 0\n\n    roomsLogElements[key] = logsElement\n\n    return logsElement\n  \n  element = ChateauTemplate Object.assign {}, self,\n    toggleOpen: (e) ->\n      # TODO: Close any other open tabs\n      e.currentTarget.parentElement.classList.toggle \"show\"\n\n    avatars: ->\n      self.avatars.map (avatar) ->\n        AvatarPresenter avatar, self\n\n    props: ->\n      self.props.map (prop) ->\n        PropPresenter prop, self\n\n    rooms: ->\n      self.rooms.map (room) ->\n        RoomPresenter room, self\n\n    logs: ->\n      room = self.currentRoom()\n\n      if room\n        findOrInitRoomLogs(room)\n\n    friends: ->\n\n  return element\n",
      "mode": "100644",
      "type": "blob"
    },
    "sha-upload.coffee": {
      "path": "sha-upload.coffee",
      "content": "UI = require \"ui\"\nrequire \"./extensions\"\n\n{Modal, Progress} = UI\n\n# Upload to firebase storage based on SHA256 of file\nmodule.exports = (firebase, file) ->\n  file.readAsArrayBuffer()\n  .then (buffer) ->\n    crypto.subtle.digest(\"SHA-256\", buffer)\n  .then hex\n  .then (sha) ->\n    console.log sha\n\n    new Promise (resolve, reject) ->\n      # Upload to CDN\n      ref = firebase.storage().ref(sha)\n      uploadTask = ref.put file\n\n      progressView = Progress\n        value: 0\n        max: 1\n\n      Modal.show progressView.element,\n        cancellable: false\n\n      uploadTask.on 'state_changed', (snapshot) ->\n        progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n\n        progressView.value progress\n\n      , (error) ->\n        # Handle unsuccessful uploads\n        Modal.hide()\n        reject(error)\n      , () ->\n        # Handle successful uploads on complete\n        # For instance, get the download URL: https://firebasestorage.googleapis.com/...\n        Modal.hide()\n\n        resolve(uploadTask.snapshot.downloadURL)\n\nhex = (buffer) ->\n  buffer = new Uint8Array(buffer)\n\n  Array::map.call buffer, (x) ->\n    ('00' + x.toString(16)).slice(-2)\n  .join('')\n",
      "mode": "100644",
      "type": "blob"
    },
    "style.styl": {
      "path": "style.styl",
      "content": "*\n  box-sizing: border-box\n\nhtml, body\n  height: 100%\n\nbody\n  font-family: Sans-Serif\n  font-size: 14px\n  line-height: 18px\n  margin: 0\n  overflow: hidden\n\ninput\n  max-width: 100%\n\nlabel\n  display: block\n  margin: 1em 0\n\n  > h1\n    font-size: 1em\n    line-height: 20px\n    margin: 0 0 4px 0\n\n  > h2\n    display: inline-block\n    font-size: 1em\n    margin: 0 4px 0 0\n\n  > input[type=\"radio\"]\n    margin-right: 4px\n    vertical-align: baseline\n\nform\n  position: relative\n\n  > micro-controls\n    display: none\n\n    > button\n      font-size: 10px\n      margin-right: 4px\n\n      &:last-child\n        margin-right: 0\n\n      &.cancel\n        color: red\n        &::before\n          content: \"❌\"\n\n      &.accept\n        color: green\n        &::before\n          content: \"✔️️\"\n\n  &.changed\n    > micro-controls\n      display: block\n      position: absolute\n      top: 0\n      right: 0\n\ntab-drawer\n  display: block\n  height: 100%\n  left: 100%\n  position: absolute\n\n  > *\n    background-color: white\n    border-left: 1px solid gray\n    height: 100%\n    left: 0\n    position: absolute\n    transition-property: left, z-index\n    transition-duration: 0.25s\n    width: 200px\n    z-index: 0\n\n    > tab\n      background-color: white\n      border: 1px solid black\n      border-right: 0\n      border-bottom-left-radius: 4px\n      border-top-left-radius: 4px\n      cursor: pointer\n      display: block\n      font-size: 24px\n      font-weight: bold\n      height: 48px\n      line-height: 48px\n      padding: 0 0.5em\n      position: absolute\n      right: 100%\n      width: 150px\n      z-index: 0\n\n      &::before\n        content: \"<\\a0\"\n\n  > *.show\n    left: -200px\n    z-index: 60\n\n    > tab\n      &::before\n        content: \">\\a0\"\n\n  > *:first-child > tab\n    border-top: 0\n    border-top-left-radius: 0\n\n  for row in 1 2 3 4 5 6 7 8 9\n    > *:nth-child({row}) > tab\n      top: 47px * (row - 1)\n\nchateau\n  display: flex\n  height: 100%\n  position: relative\n\n  > viewport\n    flex: 0 0 auto\n    height: 540px\n    margin: auto\n    position: relative\n    width: 960px\n\n    > word-area\n      display: block\n      height: 100%\n      left: 0\n      pointer-events: none\n      position: absolute\n      top: 0\n      width: 100%\n\n      > words\n        border: 1px solid black\n        border-radius: 4px\n        background-color: white\n        padding: 0.5em\n        position: absolute\n        display: inline-block\n\n  > actions\n    position: absolute\n    bottom: 0\n    left: 0\n\n    > form\n      display: inline-block\n      margin-right: 1em\n\navatar-control\n  display: block\n\n  > avatars\n    display: block\n    height: 100%\n    overflow: auto\n    padding: 1em\n\n    > avatar\n      display: block\n      margin-bottom: 1em\n\n      &:hover\n        background-color: lightyellow\n\n      > img\n        max-width: 100%\n\nprop-control\n  display: block\n\n  > props\n    display: block\n    height: 100%\n    overflow: auto\n    padding: 1em\n\n    > prop\n      display: block\n      margin-bottom: 1em\n\n      &:hover\n        background-color: lightyellow\n\n      > img\n        max-width: 100%\n\nroom-control\n  padding: 1em\n  width: 300px\n\n  > actions\n    display: block\n    margin-bottom: 1em\n\n  &.show\n    left: -300px\n\n  > rooms\n    display: block\n\n    > room\n      display: flex\n      margin-bottom: 1em\n      width: 200px\n\n      > img\n        border: 1px solid gray\n        width: 82px\n        height: 47px\n        flex: 0 0 auto\n\n      > div.details\n        flex: 1 1 auto\n        margin: auto\n        padding-left: 1em\n\nsound-control\n  display: block\n  padding: 1em\n\n  > h2\n    margin-top: 0\n\naccount-control\n  display: block\n  padding: 1em\n  padding-top: 0\n\nfriends-control\n  display: block\n\n  > friends\n    display: block\n    height: 100%\n    overflow: auto\n    padding: 1em\n\n    > friend\n      border-bottom: 1px solid gray\n      display: flex\n      margin-bottom: 0.5em\n      position: relative\n\n      > img.profile\n        border: 2px solid gray\n        border-radius: 16px\n        flex: 0 0 auto\n        height: 32px\n        margin: 0 0.5em 0.5em 0\n        width: 32px\n\n      > online-status\n        background-color: green\n        border-radius: 6px\n        height: 12px\n        left: 20px\n        position: absolute\n        top: 20px\n        width: 12px\n\n      > info\n        flex: 1 1 auto\n        > .status-message\n          color: gray\n\n      > time.last-seen\n        color: gray\n        position: absolute\n        right: 0\n        top: 0\n\nlog-control\n  display: block\n\n  > logs\n    display: block\n    height: 100%\n    overflow: auto\n    padding: 1em\n\n    > log\n      display: block\n\nform#login\n  display: block\n  padding: 2em\n\n#feedback\n  background-color: rgb(103, 58, 183)\n  border: 2px solid white\n  border-top: 0\n  box-shadow: 1px 2px 5px black\n  color: white\n  font-weight: bold\n  padding: 4px 0.5em\n  position: absolute\n  right: 200px\n  text-decoration: none\n  text-shadow: 1px 1px black\n  top: 0\n  transition-property: padding-top\n  transition-duration: 0.25s\n\n  &:hover\n    padding-top: 1em\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/asset-form.jadelet": {
      "path": "templates/asset-form.jadelet",
      "content": "form\n  h1 Use Image for:\n\n  label\n    input(type=\"radio\" name=\"selection\" value=\"avatar\" checked=\"true\")\n    h2 Avatar\n\n  label\n    input(type=\"radio\" name=\"selection\" value=\"background\")\n    h2 Background\n\n  button Submit\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/avatar-control.jadelet": {
      "path": "templates/avatar-control.jadelet",
      "content": "avatar-control\n  tab(click=@toggleOpen) Avatar\n\n  avatars\n    = @avatars\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/avatar.jadelet": {
      "path": "templates/avatar.jadelet",
      "content": "avatar(@click)\n  img(src=@avatarURL)\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/chateau.jadelet": {
      "path": "templates/chateau.jadelet",
      "content": "- AvatarControl = require \"./avatar-control\"\n- FriendsControl = require \"./friends-control\"\n- PropControl = require \"./prop-control\"\n- RoomList = require \"./room-list\"\n\nchateau\n  viewport\n    = @canvas\n    word-area\n      = @words\n\n  actions\n    form(submit=@saySubmit)\n      input\n      button Speak\n\n  tab-drawer\n    = RoomList this\n\n    log-control\n      - stats.increment \"render.log-control\"\n      tab(click=@toggleOpen) Log\n      = @logs\n\n    = PropControl(this)\n\n    sound-control\n      tab(click=@toggleOpen) Sounds\n      h2 Coming Soon!\n\n    = AvatarControl(this)\n\n    = FriendsControl(this)\n\n    account-control\n      tab(click=@toggleOpen) Account\n\n      form(submit=@displayNameFormSubmit class=@displayNameFormClass)\n        micro-controls\n          button.accept\n          button.cancel(click=@resetDisplayNameInput)\n        label\n          h1 Display Name\n          input(value=@displayNameInput)\n\n      label\n        h1 Account ID\n        span= @currentAccountId\n\n      label\n        button(click=@logout) Sign Out\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/login.jadelet": {
      "path": "templates/login.jadelet",
      "content": "form#login\n  h1 Connect to Chateau\n\n  h2 Log in with\n\n  button(click=@facebookLogin) Facebook\n  button(click=@githubLogin) GitHub\n  button(click=@googleLogin) Google\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/prop-control.jadelet": {
      "path": "templates/prop-control.jadelet",
      "content": "prop-control\n  tab(click=@toggleOpen) Props\n  \n  props\n    = @props\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/prop.jadelet": {
      "path": "templates/prop.jadelet",
      "content": "prop(@click)\n  img(src=@imageURL)\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/room-list.jadelet": {
      "path": "templates/room-list.jadelet",
      "content": "room-control\n  tab(click=@toggleOpen) Rooms\n\n  actions\n    button(click=@createRoom) + New\n\n  rooms\n    = @rooms\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/room.jadelet": {
      "path": "templates/room.jadelet",
      "content": "room(@click)\n  img(src=@imageURL)\n  div.details\n    span.name= @name\n    br\n    span.occupants\n      = \"👤 \"\n      = @numberOfCurrentOccupants\n",
      "mode": "100644",
      "type": "blob"
    },
    "util.coffee": {
      "path": "util.coffee",
      "content": "module.exports =\n  defaults: (target, objects...) ->\n    for object in objects\n      for name of object\n        unless target.hasOwnProperty(name)\n          target[name] = object[name]\n\n    return target\n\n  sortBy: (attribute) ->\n    (a, b) ->\n      a[attribute] - b[attribute]\n",
      "mode": "100644",
      "type": "blob"
    },
    "docs/data.md": {
      "path": "docs/data.md",
      "content": "Data\n----\n\n    Members members/$account_uid\n      name : Display Name\n      imageURL\n      roomKey : room key of currentRoom\n      saying : current voice bubble\n      x : x coordinate in room\n      y : y coordinate in room\n\n    Presence presence/$account_uid\n      online :\n      lastSeen :\n      status :\n\n    Rooms rooms/$room_key\n      name : Room name\n      imageURL\n      owner : the creator of the room\n      public : whether the room is public to all or private\n\n    room-data/$key/memberships[] : shallow list of member keys\n    room-data/$key/props[] : complete props data\n    room-data/$key/events[] : complete events log\n      source : account_id\n      type : [chat, emote]\n      content : type dependent\n\nLater... scripts, complex objects, animations. Props can reference animations\nand scripts to gain advanced behaviors.\n",
      "mode": "100644"
    },
    "templates/debug-control.jadelet": {
      "path": "templates/debug-control.jadelet",
      "content": "debug-control\n  tab(click=@toggleOpen) Debug\n  = @statsElement\n",
      "mode": "100644"
    },
    "templates/friends-control.jadelet": {
      "path": "templates/friends-control.jadelet",
      "content": "- FriendTemplate = require \"./friend\"\n\nfriends-control\n  tab(click=@toggleOpen) Friends\n\n  friends\n    - [0..3].map () ->\n      = FriendTemplate()\n",
      "mode": "100644"
    },
    "models/presence.coffee": {
      "path": "models/presence.coffee",
      "content": "# Presence\n#\n# Stored at presence/$uid\n#\n# Tracks user's online/offline status, status message, and lastSeen time\n\nBase = require \"./base\"\n\nmodule.exports = Base \"presence\", (I={}, self=Model(I)) ->\n  self.attrSync \"online\", \"lastSeen\", \"status\"\n\n  return self\n",
      "mode": "100644"
    },
    "presenters/friends.coffee": {
      "path": "presenters/friends.coffee",
      "content": "Template = require \"../templates/friends\"\n\nmodule.exports = (self) ->\n  element = Template(self)",
      "mode": "100644"
    },
    "templates/friend.jadelet": {
      "path": "templates/friend.jadelet",
      "content": "friend\n  img.profile\n  online-status\n  info\n    .name Duder\n    .status-message lul wut\n  time.last-seen Ages ago\n",
      "mode": "100644"
    }
  },
  "distribution": {
    "chateau": {
      "path": "chateau",
      "content": "(function() {\n  var Auth, ChateauPresenter, Drop, Member, Modal, Model, Observable, Prop, Renderer, Room, UI, rand, shaUpload, _ref;\n\n  ChateauPresenter = require(\"./presenters/chateau\");\n\n  Model = require(\"model\");\n\n  _ref = UI = require(\"ui\"), Modal = _ref.Modal, Observable = _ref.Observable;\n\n  Drop = require(\"./lib/drop\");\n\n  Auth = require(\"./module/auth\");\n\n  Renderer = require(\"./module/renderer\");\n\n  shaUpload = require(\"./sha-upload\");\n\n  rand = function(n) {\n    return Math.floor(Math.random() * n);\n  };\n\n  Member = require(\"./models/member\");\n\n  Room = require(\"./models/room\");\n\n  Prop = Member;\n\n  module.exports = function(I, self) {\n    var element;\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Model(I);\n    }\n    self.include(require(\"./module/auth\"));\n    self.extend({\n      displayNameInput: Observable(\"duder\"),\n      displayNameFormClass: function() {\n        if (self.displayNameInput() !== self.displayName()) {\n          return \"changed\";\n        }\n      },\n      displayNameFormSubmit: function(e) {\n        e.preventDefault();\n        return self.currentUser().update({\n          name: self.displayNameInput()\n        }).sync();\n      },\n      resetDisplayNameInput: function(e) {\n        if (e != null) {\n          e.preventDefault();\n        }\n        return self.displayNameInput(self.displayName());\n      },\n      displayName: function() {\n        var _ref1;\n        return ((_ref1 = self.currentUser()) != null ? _ref1.name() : void 0) || \"\";\n      },\n      currentRoom: Observable(null),\n      currentUser: Observable(null),\n      avatars: Observable([\"https://1.pixiecdn.com/sprites/148517/original.png\", \"https://0.pixiecdn.com/sprites/148468/original.png\", \"https://2.pixiecdn.com/sprites/137922/original.png\", \"https://1.pixiecdn.com/sprites/147597/original.png\", \"https://1.pixiecdn.com/sprites/151181/original.png\", \"https://1.pixiecdn.com/sprites/150973/original.png\", \"https://3.pixiecdn.com/sprites/151199/original.png\", \"https://3.pixiecdn.com/sprites/151187/original.png\", \"https://0.pixiecdn.com/sprites/151140/original.png\", \"https://3.pixiecdn.com/sprites/150719/original.png\", \"https://1.pixiecdn.com/sprites/151149/original.png\", \"https://2.pixiecdn.com/sprites/151046/original.png\"].map(function(url) {\n        return {\n          avatarURL: url\n        };\n      })),\n      rooms: Observable([]),\n      props: Observable([\"https://1.pixiecdn.com/sprites/151213/original.png\", \"https://3.pixiecdn.com/sprites/151203/original.png\", \"https://0.pixiecdn.com/sprites/148204/original.png\", \"https://1.pixiecdn.com/sprites/148365/original.png\", \"https://2.pixiecdn.com/sprites/148330/original.png\", \"https://1.pixiecdn.com/sprites/148333/original.png\", \"https://1.pixiecdn.com/sprites/148329/original.png\", \"https://1.pixiecdn.com/sprites/137441/original.png\", \"https://0.pixiecdn.com/sprites/137380/original.png\"].map(function(url) {\n        return {\n          imageURL: url\n        };\n      })),\n      displayModalLoader: function(message) {\n        var progressView;\n        progressView = UI.Progress({\n          message: message\n        });\n        return Modal.show(progressView.element, {\n          cancellable: false\n        });\n      },\n      currentAccountId: function() {\n        var _ref1;\n        return (_ref1 = self.firebaseUser()) != null ? _ref1.uid : void 0;\n      },\n      accountConnected: function(firebaseUser) {\n        var providerDisplayName, providerPhoto, user;\n        if (!firebaseUser) {\n          stats.increment(\"accountDisconnected\");\n          return;\n        }\n        stats.increment(\"accountConnected\");\n        providerDisplayName = null;\n        providerPhoto = null;\n        firebaseUser.providerData.forEach(function(profile) {\n          if (providerDisplayName == null) {\n            providerDisplayName = profile.displayName;\n          }\n          return providerPhoto != null ? providerPhoto : providerPhoto = profile.photoURL;\n        });\n        user = Member.find(firebaseUser.uid);\n        self.currentUser(user);\n        self.displayModalLoader(\"Loading...\");\n        return user.connect().then(function() {\n          if (!user.name()) {\n            user.name(providerDisplayName);\n          }\n          self.resetDisplayNameInput();\n          self.currentUser().updatePresence(\"\");\n          Modal.hide();\n          return new Promise(function(resolve, reject) {\n            var checkForAvatarURL;\n            if (user.imageURL()) {\n              return resolve();\n            } else {\n              self.element.querySelectorAll(\"tab-drawer > *\").forEach(function(element) {\n                return element.classList.remove(\"show\");\n              });\n              self.element.querySelector(\"avatar-control\").classList.add(\"show\");\n              checkForAvatarURL = function(value) {\n                if (value) {\n                  user.imageURL.stopObserving(checkForAvatarURL);\n                  return resolve();\n                }\n              };\n              return user.imageURL.observe(checkForAvatarURL);\n            }\n          });\n        }).then(function() {\n          var previousRoom;\n          previousRoom = Room.find(user.roomId());\n          if (previousRoom) {\n            return self.joinRoom(previousRoom, true);\n          } else {\n            self.element.querySelectorAll(\"tab-drawer > *\").forEach(function(element) {\n              return element.classList.remove(\"show\");\n            });\n            return self.element.querySelector(\"room-control\").classList.add(\"show\");\n          }\n        });\n      },\n      createRoom: function() {\n        return Modal.prompt(\"Room name\", \"a fun room\").then(function(name) {\n          if (name) {\n            return db.ref(\"rooms\").push({\n              name: name\n            });\n          }\n        });\n      },\n      clearAllProps: function() {\n        return self.currentRoom().clearAllProps();\n      },\n      addProp: function(prop) {\n        stats.increment(\"prop.add\");\n        return self.currentRoom().addProp(prop);\n      },\n      setBackgroundURL: function(backgroundURL) {\n        var room;\n        room = self.currentRoom();\n        room.imageURL(backgroundURL);\n        return room.sync();\n      },\n      setAvatar: function(avatarURL) {\n        return self.currentUser().update({\n          imageURL: avatarURL\n        }).sync();\n      },\n      joinRoom: function(room) {\n        var accountId, previousRoom, user;\n        if (room === self.currentRoom()) {\n          return;\n        }\n        user = self.currentUser();\n        accountId = user != null ? user.key() : void 0;\n        if (!accountId) {\n          return;\n        }\n        stats.increment(\"rooms.join\");\n        previousRoom = self.currentRoom();\n        if (previousRoom != null) {\n          previousRoom.leave(accountId);\n        }\n        room.join(accountId);\n        user.roomId(room.key());\n        user.sync();\n        self.currentRoom(room);\n      },\n      saySubmit: function(e) {\n        var input, words, _ref1;\n        e.preventDefault();\n        input = e.currentTarget.querySelector('input');\n        words = input.value;\n        if (words) {\n          input.value = \"\";\n          if ((_ref1 = self.currentRoom()) != null) {\n            _ref1.addRoomEvent({\n              source: self.currentAccountId(),\n              type: \"chat\",\n              content: {\n                sender: self.displayName(),\n                message: words\n              }\n            });\n          }\n          self.currentUser().ref().child(\"text\").onDisconnect().remove();\n          return self.currentUser().update({\n            text: words\n          }).sync(db);\n        } else {\n          return self.currentUser().ref().child(\"text\").remove();\n        }\n      },\n      words: function() {\n        var _ref1;\n        return (_ref1 = self.currentRoom()) != null ? _ref1.members.map(function(member) {\n          return member.wordElement();\n        }) : void 0;\n      }\n    });\n    self.include(Renderer);\n    self.include(Auth);\n    self.initializeAuth();\n    (function() {\n      return db.ref(\"rooms\").on(\"child_added\", function(room) {\n        var key, value;\n        key = room.key;\n        value = room.val();\n        delete value.props;\n        stats.increment(\"rooms.child_added\");\n        room = Room.find(key).update(value);\n        return self.rooms.push(room);\n      });\n    })();\n    self.firebaseUser.observe(self.accountConnected);\n    self.element = element = ChateauPresenter(self);\n    Drop(element, function(e) {\n      var file, files;\n      files = e.dataTransfer.files;\n      if (files.length) {\n        file = files[0];\n        stats.increment(\"drop-file\");\n        return shaUpload(firebase, file).then(function(downloadURL) {\n          return Modal.form(require(\"./templates/asset-form\")()).then(function(result) {\n            switch (result != null ? result.selection : void 0) {\n              case \"avatar\":\n                return self.setAvatar(downloadURL);\n              case \"background\":\n                return self.setBackgroundURL(downloadURL);\n            }\n          });\n        });\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "extensions": {
      "path": "extensions",
      "content": "(function() {\n  var _base;\n\n  Blob.prototype.readAsArrayBuffer = function() {\n    var file;\n    file = this;\n    return new Promise(function(resolve, reject) {\n      var reader;\n      reader = new FileReader;\n      reader.onload = function() {\n        return resolve(reader.result);\n      };\n      reader.onerror = reject;\n      return reader.readAsArrayBuffer(file);\n    });\n  };\n\n  if ((_base = Promise.prototype)[\"finally\"] == null) {\n    _base[\"finally\"] = function(callback) {\n      return this.then(function(value) {\n        return Promise.resolve(callback()).then(function() {\n          return value;\n        });\n      }, function(reason) {\n        return Promise.resolve(callback()).then(function() {\n          throw reason;\n        });\n      });\n    };\n  }\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/drop": {
      "path": "lib/drop",
      "content": "(function() {\n  module.exports = function(element, handler) {\n    var cancel;\n    cancel = function(e) {\n      e.preventDefault();\n      return false;\n    };\n    element.addEventListener(\"dragover\", cancel);\n    element.addEventListener(\"dragenter\", cancel);\n    return element.addEventListener(\"drop\", function(e) {\n      e.preventDefault();\n      handler(e);\n      return false;\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/feedback-tab": {
      "path": "lib/feedback-tab",
      "content": "(function() {\n  module.exports = function(href) {\n    var tab;\n    tab = document.createElement('a');\n    tab.textContent = \"Feedback\";\n    tab.id = \"feedback\";\n    tab.href = href;\n    tab.target = \"_blank\";\n    return tab;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/logger": {
      "path": "lib/logger",
      "content": "(function() {\n  var __slice = [].slice;\n\n  module.exports = function(bus) {\n    var logFn, self;\n    logFn = function(label) {\n      return function() {\n        return bus([label].concat(__slice.call(arguments)));\n      };\n    };\n    self = {};\n    [\"error\", \"warn\", \"debug\", \"info\", \"log\"].forEach(function(label) {\n      return self[label] = logFn(label);\n    });\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/open-promise": {
      "path": "lib/open-promise",
      "content": "(function() {\n  module.exports = function() {\n    var promise, _reject, _resolve;\n    _resolve = _reject = null;\n    promise = new Promise(function(resolve, reject) {\n      _resolve = resolve;\n      return _reject = reject;\n    });\n    promise.resolve = _resolve;\n    promise.reject = _reject;\n    return promise;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/stats": {
      "path": "lib/stats",
      "content": "(function() {\n  module.exports = function() {\n    var self, stats;\n    stats = {};\n    self = {\n      increment: function(bucket, amount) {\n        if (amount == null) {\n          amount = 1;\n        }\n        if (stats[bucket] == null) {\n          stats[bucket] = 0;\n        }\n        return stats[bucket] += amount;\n      },\n      decrement: function(bucket, amount) {\n        if (amount == null) {\n          amount = 1;\n        }\n        return self.increment(bucket, -amount);\n      },\n      stats: stats\n    };\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "main": {
      "path": "main",
      "content": "(function() {\n  var Chateau, Style, style;\n\n  Chateau = require(\"./chateau\");\n\n  if (PACKAGE.name === \"ROOT\") {\n    require(\"analytics\").init(\"UA-3464282-15\");\n    Style = require(\"ui\").Style;\n    style = document.createElement(\"style\");\n    style.innerHTML = Style.all + \"\\n\" + require(\"./style\");\n    document.head.appendChild(style);\n    firebase.initializeApp({\n      apiKey: \"AIzaSyCnhTPOri3XGQ0q5pw0u8dRPZQwr74fpuw\",\n      authDomain: \"chateau-f2799.firebaseapp.com\",\n      databaseURL: \"https://chateau-f2799.firebaseio.com\",\n      storageBucket: \"chateau-f2799.appspot.com\",\n      messagingSenderId: \"2073045470\"\n    });\n    global.logger = require(\"./lib/logger\")(console.log);\n    global.stats = require(\"./lib/stats\")();\n    global.firebase = firebase;\n    global.db = firebase.database();\n    db.TIMESTAMP = firebase.database.ServerValue.TIMESTAMP;\n    global.defaults = require(\"./util\").defaults;\n    global.chateau = Chateau();\n    document.body.appendChild(chateau.element);\n    document.body.appendChild(require(\"./lib/feedback-tab\")(\"https://docs.google.com/forms/d/e/1FAIpQLScMur8T8VcgWGk0k-sFkNRmCiDGWAzTRTLICUC0v-W2J7rJKQ/viewform\"));\n  } else {\n    module.exports = Chateau;\n  }\n\n}).call(this);\n",
      "type": "blob"
    },
    "models/base": {
      "path": "models/base",
      "content": "(function() {\n  var Model, OpenPromise,\n    __slice = [].slice;\n\n  OpenPromise = require(\"../lib/open-promise\");\n\n  Model = require(\"model\");\n\n  module.exports = function(tableName, Mixin) {\n    var ModelConstructor, identityMap;\n    ModelConstructor = function(I, self) {\n      var connectedPromise, ref, syncAttributes, table, update;\n      if (I == null) {\n        I = {};\n      }\n      if (self == null) {\n        self = Model(I);\n      }\n      self.attrReader(\"key\");\n      table = db.ref(tableName);\n      ref = table.child(self.key());\n      syncAttributes = [];\n      self.extend({\n        attrSync: function() {\n          var names;\n          names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          self.attrObservable.apply(self, names);\n          return syncAttributes = syncAttributes.concat(names);\n        },\n        connect: function() {\n          return connectedPromise;\n        },\n        disconnect: function() {\n          stats.increment(\"\" + tableName + \".disconnect\");\n          return ref.off(\"value\", update);\n        },\n        update: function(data) {\n          if (!data) {\n            return;\n          }\n          stats.increment(\"\" + tableName + \".update\");\n          Object.keys(data).forEach(function(key) {\n            return typeof self[key] === \"function\" ? self[key](data[key]) : void 0;\n          });\n          return self;\n        },\n        ref: function() {\n          return ref;\n        },\n        sync: function() {\n          var data;\n          stats.increment(\"\" + tableName + \".sync\");\n          data = syncAttributes.reduce(function(memo, name) {\n            memo[name] = self[name]();\n            return memo;\n          }, {});\n          return ref.update(data);\n        }\n      });\n      self.include(Mixin);\n      connectedPromise = OpenPromise();\n      update = function(snap) {\n        connectedPromise.resolve();\n        return self.update(snap.val());\n      };\n      ref.on(\"value\", update);\n      return self;\n    };\n    identityMap = {};\n    ModelConstructor.find = function(id) {\n      return identityMap[id] != null ? identityMap[id] : identityMap[id] = ModelConstructor({\n        key: id\n      });\n    };\n    return ModelConstructor;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "models/drawable": {
      "path": "models/drawable",
      "content": "(function() {\n  module.exports = function(I, self) {\n    var img, updateImageURL;\n    img = new Image;\n    if (self.attrSync) {\n      self.attrSync(\"imageURL\");\n    } else {\n      self.attrObservable(\"imageURL\");\n    }\n    self.extend({\n      img: function() {\n        return img;\n      },\n      height: function() {\n        return img.height | 0;\n      },\n      width: function() {\n        return img.width | 0;\n      }\n    });\n    updateImageURL = function(url) {\n      if (url) {\n        return img.src = url;\n      }\n    };\n    self.imageURL.observe(updateImageURL);\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "models/member": {
      "path": "models/member",
      "content": "(function() {\n  var Base, Drawable;\n\n  Base = require(\"./base\");\n\n  Drawable = require(\"./drawable\");\n\n  module.exports = Base(\"members\", function(I, self) {\n    var updateTextPosition, wordElement;\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Model(I);\n    }\n    defaults(I, {\n      name: \"\",\n      roomId: null,\n      text: \"\",\n      x: 480,\n      y: 270\n    });\n    self.include(Drawable);\n    self.attrSync(\"x\", \"y\", \"text\", \"name\", \"roomId\");\n    wordElement = document.createElement(\"words\");\n    self.extend({\n      updatePosition: function(_arg) {\n        var x, y;\n        x = _arg.x, y = _arg.y;\n        self.x(x);\n        return self.y(y);\n      },\n      wordElement: function() {\n        return wordElement;\n      },\n      updatePresence: function(status) {\n        var presenceRef;\n        presenceRef = db.ref(\"presence/\" + (self.key()));\n        presenceRef.child(\"online\").onDisconnect().set(false);\n        presenceRef.child(\"lastSeen\").onDisconnect().set(db.TIMESTAMP);\n        return presenceRef.update({\n          online: true,\n          lastSeen: db.TIMESTAMP,\n          status: status\n        });\n      }\n    });\n    updateTextPosition = function() {\n      if (self.text()) {\n        wordElement.style.left = \"\" + (self.x()) + \"px\";\n        return wordElement.style.top = \"\" + (self.y() - self.height() / 2 - 30) + \"px\";\n      } else {\n        return wordElement.style.left = \"-100%\";\n      }\n    };\n    self.text.observe(function(text) {\n      wordElement.textContent = text;\n      return updateTextPosition();\n    });\n    self.x.observe(updateTextPosition);\n    self.y.observe(updateTextPosition);\n    self.imageURL.observe(updateTextPosition);\n    return self;\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "models/prop": {
      "path": "models/prop",
      "content": "(function() {\n  var Drawable, Model, Prop, identityMap;\n\n  Model = require(\"model\");\n\n  Drawable = require(\"./drawable\");\n\n  module.exports = Prop = function(I, self) {\n    var ref, table, update;\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Model(I);\n    }\n    defaults(I, {\n      x: 480,\n      y: 270\n    });\n    self.include(Drawable);\n    self.attrReader(\"key\", \"roomId\");\n    self.attrObservable(\"x\", \"y\");\n    update = function(snap) {\n      return self.update(snap.val());\n    };\n    table = db.ref(\"rooms/\" + (self.roomId()) + \"/props\");\n    ref = table.child(self.key());\n    self.extend({\n      connect: function() {},\n      disconnect: function() {\n        ref.off(\"value\", update);\n        return self;\n      },\n      updatePosition: function(_arg) {\n        var x, y;\n        x = _arg.x, y = _arg.y;\n        self.x(x);\n        return self.y(y);\n      },\n      update: function(data) {\n        if (!data) {\n          return;\n        }\n        stats.increment(\"props.update\");\n        Object.keys(data).forEach(function(key) {\n          return typeof self[key] === \"function\" ? self[key](data[key]) : void 0;\n        });\n        return self;\n      },\n      sync: function() {\n        return ref.update({\n          x: self.x(),\n          y: self.y()\n        });\n      }\n    });\n    ref.on(\"value\", update);\n    return self;\n  };\n\n  identityMap = {};\n\n  Prop.find = function(key) {\n    return identityMap[key] != null ? identityMap[key] : identityMap[key] = Prop({\n      key: key\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "models/room-event": {
      "path": "models/room-event",
      "content": "(function() {\n  var Model, RoomEvent, identityMap;\n\n  Model = require(\"model\");\n\n  module.exports = RoomEvent = function(I, self) {\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Model(I);\n    }\n    self.attrReader(\"key\", \"source\", \"type\", \"content\");\n    return self;\n  };\n\n  identityMap = {};\n\n  RoomEvent.createFromSnap = function(snap) {\n    var data, key;\n    key = snap.key;\n    if (identityMap[key]) {\n      return identityMap[key];\n    }\n    data = snap.val();\n    data.key = key;\n    return identityMap[key] = RoomEvent(data);\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "models/room": {
      "path": "models/room",
      "content": "(function() {\n  var Bindable, Drawable, Member, Model, Prop, Room, RoomEvent, V, identityMap;\n\n  Bindable = require(\"ui\").Bindable;\n\n  Model = require(\"model\");\n\n  Drawable = require(\"./drawable\");\n\n  Member = require(\"./member\");\n\n  Prop = require(\"./prop\");\n\n  RoomEvent = require(\"./room-event\");\n\n  module.exports = Room = function(I, self) {\n    var dataRef, eventsRef, membershipsRef, propsRef, ref, subscribeToMember, subscribeToProp, table, unsubscribeFromMember, unsubscribeFromProp, update;\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Model(I);\n    }\n    stats.increment(\"room.initialize\");\n    defaults(I, {\n      members: [],\n      events: [],\n      props: []\n    });\n    self.attrReader(\"key\");\n    self.include(Bindable, Drawable);\n    self.attrObservable(\"name\");\n    self.attrModels(\"members\", Member);\n    self.attrModels(\"props\", Prop);\n    self.attrModels(\"events\", RoomEvent);\n    table = db.ref(\"rooms\");\n    ref = table.child(self.key());\n    dataRef = db.ref(\"room-data/\" + (self.key()));\n    eventsRef = dataRef.child(\"events\");\n    membershipsRef = dataRef.child(\"memberships\");\n    propsRef = dataRef.child(\"props\");\n    subscribeToProp = function(snap) {\n      var key, prop, value;\n      stats.increment(\"room.subscribe-prop\");\n      key = snap.key;\n      value = snap.val();\n      prop = Prop.find(key);\n      prop.update(value);\n      if (!self.propByKey(key)) {\n        return self.props.push(prop);\n      }\n    };\n    unsubscribeFromProp = function(_arg) {\n      var key, prop;\n      key = _arg.key;\n      stats.increment(\"room.unsubscribe-prop\");\n      prop = self.propByKey(key);\n      if (prop) {\n        return self.props.remove(prop);\n      }\n    };\n    subscribeToMember = function(_arg) {\n      var key, member;\n      key = _arg.key;\n      stats.increment(\"room.subscribe-member\");\n      member = Member.find(key);\n      member.connect();\n      if (!self.memberByKey(key)) {\n        return self.members.push(member);\n      }\n    };\n    unsubscribeFromMember = function(_arg) {\n      var key, member;\n      key = _arg.key;\n      stats.increment(\"room.unsubscribe-member\");\n      member = self.memberByKey(key);\n      if (member) {\n        return self.members.remove(member);\n      }\n    };\n    self.extend({\n      addProp: function(_arg) {\n        var imageURL;\n        imageURL = _arg.imageURL;\n        return propsRef.push({\n          x: (Math.random() * 960) | 0,\n          y: (Math.random() * 540) | 0,\n          imageURL: imageURL\n        });\n      },\n      join: function(accountId) {\n        membershipsRef.child(accountId).onDisconnect().remove();\n        return membershipsRef.child(accountId).set(true);\n      },\n      leave: function(accountId) {\n        return membershipsRef.child(accountId).remove();\n      },\n      clearAllProps: function() {\n        return ref.child(\"props\").remove();\n      },\n      update: function(data) {\n        if (!data) {\n          return;\n        }\n        stats.increment(\"room.update\");\n        Object.keys(data).forEach(function(key) {\n          return typeof self[key] === \"function\" ? self[key](data[key]) : void 0;\n        });\n        return self;\n      },\n      addRoomEvent: function(data) {\n        return eventsRef.push(data);\n      },\n      memberByKey: function(key) {\n        var member;\n        member = self.members.filter(function(member) {\n          return member.key() === key;\n        })[0];\n        return member;\n      },\n      propByKey: function(key) {\n        var prop;\n        prop = self.props.filter(function(prop) {\n          return prop.key() === key;\n        })[0];\n        return prop;\n      },\n      numberOfCurrentOccupants: function() {\n        return self.members.length;\n      },\n      sync: function() {\n        return ref.update({\n          imageURL: self.imageURL(),\n          name: self.name()\n        });\n      }\n    });\n    update = function(snap) {\n      var data;\n      data = snap.val();\n      delete data.props;\n      delete data.memberships;\n      data.imageURL = data.backgroundURL;\n      return self.update(data);\n    };\n    ref.on(\"value\", update);\n    membershipsRef.on(\"child_added\", subscribeToMember);\n    membershipsRef.on(\"child_removed\", unsubscribeFromMember);\n    propsRef.on(\"child_added\", subscribeToProp);\n    propsRef.on(\"child_removed\", unsubscribeFromProp);\n    eventsRef.on(\"child_added\", function(snap) {\n      var roomEvent;\n      roomEvent = RoomEvent.createFromSnap(snap);\n      self.events.push(roomEvent);\n      return self.trigger(\"eventAdded\", roomEvent);\n    });\n    return self;\n  };\n\n  identityMap = {};\n\n  Room.find = function(id) {\n    if (!id) {\n      return;\n    }\n    stats.increment(\"room.find\");\n    return identityMap[id] != null ? identityMap[id] : identityMap[id] = Room({\n      key: id\n    });\n  };\n\n  V = function(fn) {\n    return function(data) {\n      return fn(data.val());\n    };\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "module/auth": {
      "path": "module/auth",
      "content": "(function() {\n  var LoginTemplate, Modal, Observable, UI, _ref;\n\n  _ref = UI = require(\"ui\"), Modal = _ref.Modal, Observable = _ref.Observable;\n\n  LoginTemplate = require(\"../templates/login\");\n\n  module.exports = function(I, self) {\n    var initializeAuth, monitorConnectionStatus;\n    monitorConnectionStatus = function() {\n      return db.ref(\".info/connected\").on(\"value\", function(snap) {\n        var connected;\n        connected = snap.val();\n        if (connected) {\n          self.connectionStatus(\"Connected\");\n          return stats.increment(\"connect\");\n        } else {\n          self.connectionStatus(\"Disconnected\");\n          return stats.increment(\"disconnected\");\n        }\n      });\n    };\n    initializeAuth = function() {\n      self.displayModalLoader(\"Initializing...\");\n      return firebase.auth().onAuthStateChanged(function(user) {\n        var loginTemplate;\n        stats.increment(\"authStateChanged\");\n        if (user) {\n          Modal.hide();\n          return self.firebaseUser(user);\n        } else {\n          loginTemplate = LoginTemplate(self);\n          return Modal.show(loginTemplate, {\n            cancellable: false\n          });\n        }\n      });\n    };\n    return self.extend({\n      connectionStatus: Observable(\"Disconnected\"),\n      firebaseUser: Observable(null),\n      initializeAuth: initializeAuth,\n      logout: function(e) {\n        if (e != null) {\n          e.preventDefault();\n        }\n        return firebase.auth().signOut();\n      },\n      anonLogin: function(e) {\n        e.preventDefault();\n        return firebase.auth().signInAnonymously();\n      },\n      googleLogin: function(e) {\n        var provider;\n        e.preventDefault();\n        provider = new firebase.auth.GoogleAuthProvider();\n        provider.addScope('profile');\n        provider.addScope('email');\n        return firebase.auth().signInWithPopup(provider);\n      },\n      facebookLogin: function(e) {\n        var provider;\n        e.preventDefault();\n        provider = new firebase.auth.FacebookAuthProvider();\n        return firebase.auth().signInWithPopup(provider);\n      },\n      twitterLogin: function(e) {\n        var provider;\n        e.preventDefault();\n        provider = new firebase.auth.TwitterAuthProvider();\n        return firebase.auth().signInWithPopup(provider);\n      },\n      githubLogin: function(e) {\n        var provider;\n        e.preventDefault();\n        provider = new firebase.auth.GithubAuthProvider();\n        provider.addScope('user:email');\n        return firebase.auth().signInWithPopup(provider);\n      }\n    });\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "module/renderer": {
      "path": "module/renderer",
      "content": "(function() {\n  var drawAvatar, drawRoom;\n\n  drawRoom = function(context, room) {\n    var backgroundImage, members, props;\n    backgroundImage = room.img();\n    members = room.members();\n    props = room.props();\n    if (backgroundImage != null ? backgroundImage.width : void 0) {\n      context.drawImage(backgroundImage, 0, 0, context.width, context.height);\n    }\n    return Object.values(members).concat(props).forEach(function(object) {\n      var height, img, width, x, y;\n      img = object.img();\n      width = img.width, height = img.height;\n      x = (object.x() - width / 2) | 0;\n      y = (object.y() - height / 2) | 0;\n      if (width && height) {\n        return context.drawImage(img, x, y);\n      }\n    });\n  };\n\n  drawAvatar = function(context, member) {\n    var height, img, width, x, y;\n    if (!member) {\n      return;\n    }\n    img = member.img();\n    width = img.width, height = img.height;\n    x = ((context.width - width) / 2) | 0;\n    y = ((context.height - height) / 2) | 0;\n    if (width && height) {\n      return context.drawImage(img, x, y);\n    }\n  };\n\n  module.exports = function(I, self) {\n    var animate, canvas, context, repaint;\n    canvas = document.createElement('canvas');\n    canvas.width = 960;\n    canvas.height = 540;\n    context = canvas.getContext('2d');\n    context.width = canvas.width;\n    context.height = canvas.height;\n    canvas.onclick = function(e) {\n      var currentTarget, left, pageX, pageY, top, x, y, _ref;\n      pageX = e.pageX, pageY = e.pageY, currentTarget = e.currentTarget;\n      _ref = currentTarget.getBoundingClientRect(), top = _ref.top, left = _ref.left;\n      x = pageX - left;\n      y = pageY - top;\n      return self.currentUser().update({\n        x: x,\n        y: y\n      }).sync(db);\n    };\n    repaint = function() {\n      var room, user;\n      context.fillStyle = 'white';\n      context.fillRect(0, 0, canvas.width, canvas.height);\n      if (room = self.currentRoom()) {\n        drawRoom(context, room);\n      } else if (user = self.currentUser()) {\n        drawAvatar(context, user);\n      }\n    };\n    animate = function() {\n      requestAnimationFrame(animate);\n      return repaint();\n    };\n    animate();\n    self.extend({\n      canvas: canvas\n    });\n    return self;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"width\":960,\"height\":540,\"remoteDependencies\":[\"https://www.gstatic.com/firebasejs/3.6.7/firebase.js\"],\"dependencies\":{\"analytics\":\"distri/google-analytics:v0.1.0\",\"model\":\"distri/model:master\",\"ui\":\"STRd6/ui:master\"}};",
      "type": "blob"
    },
    "presenters/chateau": {
      "path": "presenters/chateau",
      "content": "(function() {\n  var AvatarPresenter, AvatarTemplate, ChateauTemplate, LogPresenter, PropPresenter, PropTemplate, RoomPresenter, RoomTemplate;\n\n  AvatarTemplate = require(\"../templates/avatar\");\n\n  ChateauTemplate = require(\"../templates/chateau\");\n\n  PropTemplate = require(\"../templates/prop\");\n\n  RoomTemplate = require(\"../templates/room\");\n\n  AvatarPresenter = function(avatar, self) {\n    stats.increment(\"presenter.avatar\");\n    return AvatarTemplate(Object.assign({}, avatar, {\n      click: function(e) {\n        e.preventDefault();\n        return self.setAvatar(avatar.avatarURL);\n      }\n    }));\n  };\n\n  RoomPresenter = function(room, self) {\n    stats.increment(\"presenter.room\");\n    return RoomTemplate(Object.assign({}, room, {\n      click: function(e) {\n        e.preventDefault();\n        return self.joinRoom(room);\n      }\n    }));\n  };\n\n  PropPresenter = function(prop, self) {\n    stats.increment(\"presenter.prop\");\n    return PropTemplate(Object.assign({}, prop, {\n      click: function(e) {\n        e.preventDefault();\n        return self.addProp(prop);\n      }\n    }));\n  };\n\n  LogPresenter = function(event) {\n    var log, message, sender, _ref;\n    stats.increment(\"presenter.log\");\n    switch (event.type()) {\n      case \"chat\":\n        log = document.createElement(\"log\");\n        _ref = event.content(), sender = _ref.sender, message = _ref.message;\n        log.textContent = \"\" + sender + \": \" + message;\n        return log;\n    }\n  };\n\n  module.exports = function(self) {\n    var element, findOrInitRoomLogs, roomsLogElements;\n    roomsLogElements = {};\n    findOrInitRoomLogs = function(room) {\n      var key, logsElement;\n      key = room.key();\n      if (roomsLogElements[key]) {\n        return roomsLogElements[key];\n      }\n      logsElement = document.createElement('logs');\n      setTimeout(function() {\n        room.events.forEach(function(event) {\n          return logsElement.appendChild(LogPresenter(event));\n        });\n        return room.on(\"eventAdded\", function(event) {\n          return logsElement.appendChild(LogPresenter(event));\n        });\n      }, 0);\n      roomsLogElements[key] = logsElement;\n      return logsElement;\n    };\n    element = ChateauTemplate(Object.assign({}, self, {\n      toggleOpen: function(e) {\n        return e.currentTarget.parentElement.classList.toggle(\"show\");\n      },\n      avatars: function() {\n        return self.avatars.map(function(avatar) {\n          return AvatarPresenter(avatar, self);\n        });\n      },\n      props: function() {\n        return self.props.map(function(prop) {\n          return PropPresenter(prop, self);\n        });\n      },\n      rooms: function() {\n        return self.rooms.map(function(room) {\n          return RoomPresenter(room, self);\n        });\n      },\n      logs: function() {\n        var room;\n        room = self.currentRoom();\n        if (room) {\n          return findOrInitRoomLogs(room);\n        }\n      },\n      friends: function() {}\n    }));\n    return element;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "sha-upload": {
      "path": "sha-upload",
      "content": "(function() {\n  var Modal, Progress, UI, hex;\n\n  UI = require(\"ui\");\n\n  require(\"./extensions\");\n\n  Modal = UI.Modal, Progress = UI.Progress;\n\n  module.exports = function(firebase, file) {\n    return file.readAsArrayBuffer().then(function(buffer) {\n      return crypto.subtle.digest(\"SHA-256\", buffer);\n    }).then(hex).then(function(sha) {\n      console.log(sha);\n      return new Promise(function(resolve, reject) {\n        var progressView, ref, uploadTask;\n        ref = firebase.storage().ref(sha);\n        uploadTask = ref.put(file);\n        progressView = Progress({\n          value: 0,\n          max: 1\n        });\n        Modal.show(progressView.element, {\n          cancellable: false\n        });\n        return uploadTask.on('state_changed', function(snapshot) {\n          var progress;\n          progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n          return progressView.value(progress);\n        }, function(error) {\n          Modal.hide();\n          return reject(error);\n        }, function() {\n          Modal.hide();\n          return resolve(uploadTask.snapshot.downloadURL);\n        });\n      });\n    });\n  };\n\n  hex = function(buffer) {\n    buffer = new Uint8Array(buffer);\n    return Array.prototype.map.call(buffer, function(x) {\n      return ('00' + x.toString(16)).slice(-2);\n    }).join('');\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "style": {
      "path": "style",
      "content": "module.exports = \"* {\\n  box-sizing: border-box;\\n}\\nhtml,\\nbody {\\n  height: 100%;\\n}\\nbody {\\n  font-family: Sans-Serif;\\n  font-size: 14px;\\n  line-height: 18px;\\n  margin: 0;\\n  overflow: hidden;\\n}\\ninput {\\n  max-width: 100%;\\n}\\nlabel {\\n  display: block;\\n  margin: 1em 0;\\n}\\nlabel > h1 {\\n  font-size: 1em;\\n  line-height: 20px;\\n  margin: 0 0 4px 0;\\n}\\nlabel > h2 {\\n  display: inline-block;\\n  font-size: 1em;\\n  margin: 0 4px 0 0;\\n}\\nlabel > input[type=\\\"radio\\\"] {\\n  margin-right: 4px;\\n  vertical-align: baseline;\\n}\\nform {\\n  position: relative;\\n}\\nform > micro-controls {\\n  display: none;\\n}\\nform > micro-controls > button {\\n  font-size: 10px;\\n  margin-right: 4px;\\n}\\nform > micro-controls > button:last-child {\\n  margin-right: 0;\\n}\\nform > micro-controls > button.cancel {\\n  color: #f00;\\n}\\nform > micro-controls > button.cancel::before {\\n  content: \\\"❌\\\";\\n}\\nform > micro-controls > button.accept {\\n  color: #008000;\\n}\\nform > micro-controls > button.accept::before {\\n  content: \\\"✔️️\\\";\\n}\\nform.changed > micro-controls {\\n  display: block;\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n}\\ntab-drawer {\\n  display: block;\\n  height: 100%;\\n  left: 100%;\\n  position: absolute;\\n}\\ntab-drawer > * {\\n  background-color: #fff;\\n  border-left: 1px solid #808080;\\n  height: 100%;\\n  left: 0;\\n  position: absolute;\\n  transition-property: left, z-index;\\n  transition-duration: 0.25s;\\n  width: 200px;\\n  z-index: 0;\\n}\\ntab-drawer > * > tab {\\n  background-color: #fff;\\n  border: 1px solid #000;\\n  border-right: 0;\\n  border-bottom-left-radius: 4px;\\n  border-top-left-radius: 4px;\\n  cursor: pointer;\\n  display: block;\\n  font-size: 24px;\\n  font-weight: bold;\\n  height: 48px;\\n  line-height: 48px;\\n  padding: 0 0.5em;\\n  position: absolute;\\n  right: 100%;\\n  width: 150px;\\n  z-index: 0;\\n}\\ntab-drawer > * > tab::before {\\n  content: \\\"<\\\\a0\\\";\\n}\\ntab-drawer > *.show {\\n  left: -200px;\\n  z-index: 60;\\n}\\ntab-drawer > *.show > tab::before {\\n  content: \\\">\\\\a0\\\";\\n}\\ntab-drawer > *:first-child > tab {\\n  border-top: 0;\\n  border-top-left-radius: 0;\\n}\\ntab-drawer > *:nth-child(1) > tab {\\n  top: 0px;\\n}\\ntab-drawer > *:nth-child(2) > tab {\\n  top: 47px;\\n}\\ntab-drawer > *:nth-child(3) > tab {\\n  top: 94px;\\n}\\ntab-drawer > *:nth-child(4) > tab {\\n  top: 141px;\\n}\\ntab-drawer > *:nth-child(5) > tab {\\n  top: 188px;\\n}\\ntab-drawer > *:nth-child(6) > tab {\\n  top: 235px;\\n}\\ntab-drawer > *:nth-child(7) > tab {\\n  top: 282px;\\n}\\ntab-drawer > *:nth-child(8) > tab {\\n  top: 329px;\\n}\\ntab-drawer > *:nth-child(9) > tab {\\n  top: 376px;\\n}\\nchateau {\\n  display: flex;\\n  height: 100%;\\n  position: relative;\\n}\\nchateau > viewport {\\n  flex: 0 0 auto;\\n  height: 540px;\\n  margin: auto;\\n  position: relative;\\n  width: 960px;\\n}\\nchateau > viewport > word-area {\\n  display: block;\\n  height: 100%;\\n  left: 0;\\n  pointer-events: none;\\n  position: absolute;\\n  top: 0;\\n  width: 100%;\\n}\\nchateau > viewport > word-area > words {\\n  border: 1px solid #000;\\n  border-radius: 4px;\\n  background-color: #fff;\\n  padding: 0.5em;\\n  position: absolute;\\n  display: inline-block;\\n}\\nchateau > actions {\\n  position: absolute;\\n  bottom: 0;\\n  left: 0;\\n}\\nchateau > actions > form {\\n  display: inline-block;\\n  margin-right: 1em;\\n}\\navatar-control {\\n  display: block;\\n}\\navatar-control > avatars {\\n  display: block;\\n  height: 100%;\\n  overflow: auto;\\n  padding: 1em;\\n}\\navatar-control > avatars > avatar {\\n  display: block;\\n  margin-bottom: 1em;\\n}\\navatar-control > avatars > avatar:hover {\\n  background-color: #ffffe0;\\n}\\navatar-control > avatars > avatar > img {\\n  max-width: 100%;\\n}\\nprop-control {\\n  display: block;\\n}\\nprop-control > props {\\n  display: block;\\n  height: 100%;\\n  overflow: auto;\\n  padding: 1em;\\n}\\nprop-control > props > prop {\\n  display: block;\\n  margin-bottom: 1em;\\n}\\nprop-control > props > prop:hover {\\n  background-color: #ffffe0;\\n}\\nprop-control > props > prop > img {\\n  max-width: 100%;\\n}\\nroom-control {\\n  padding: 1em;\\n  width: 300px;\\n}\\nroom-control > actions {\\n  display: block;\\n  margin-bottom: 1em;\\n}\\nroom-control.show {\\n  left: -300px;\\n}\\nroom-control > rooms {\\n  display: block;\\n}\\nroom-control > rooms > room {\\n  display: flex;\\n  margin-bottom: 1em;\\n  width: 200px;\\n}\\nroom-control > rooms > room > img {\\n  border: 1px solid #808080;\\n  width: 82px;\\n  height: 47px;\\n  flex: 0 0 auto;\\n}\\nroom-control > rooms > room > div.details {\\n  flex: 1 1 auto;\\n  margin: auto;\\n  padding-left: 1em;\\n}\\nsound-control {\\n  display: block;\\n  padding: 1em;\\n}\\nsound-control > h2 {\\n  margin-top: 0;\\n}\\naccount-control {\\n  display: block;\\n  padding: 1em;\\n  padding-top: 0;\\n}\\nfriends-control {\\n  display: block;\\n}\\nfriends-control > friends {\\n  display: block;\\n  height: 100%;\\n  overflow: auto;\\n  padding: 1em;\\n}\\nfriends-control > friends > friend {\\n  border-bottom: 1px solid #808080;\\n  display: flex;\\n  margin-bottom: 0.5em;\\n  position: relative;\\n}\\nfriends-control > friends > friend > img.profile {\\n  border: 2px solid #808080;\\n  border-radius: 16px;\\n  flex: 0 0 auto;\\n  height: 32px;\\n  margin: 0 0.5em 0.5em 0;\\n  width: 32px;\\n}\\nfriends-control > friends > friend > online-status {\\n  background-color: #008000;\\n  border-radius: 6px;\\n  height: 12px;\\n  left: 20px;\\n  position: absolute;\\n  top: 20px;\\n  width: 12px;\\n}\\nfriends-control > friends > friend > info {\\n  flex: 1 1 auto;\\n}\\nfriends-control > friends > friend > info > .status-message {\\n  color: #808080;\\n}\\nfriends-control > friends > friend > time.last-seen {\\n  color: #808080;\\n  position: absolute;\\n  right: 0;\\n  top: 0;\\n}\\nlog-control {\\n  display: block;\\n}\\nlog-control > logs {\\n  display: block;\\n  height: 100%;\\n  overflow: auto;\\n  padding: 1em;\\n}\\nlog-control > logs > log {\\n  display: block;\\n}\\nform#login {\\n  display: block;\\n  padding: 2em;\\n}\\n#feedback {\\n  background-color: #673ab7;\\n  border: 2px solid #fff;\\n  border-top: 0;\\n  box-shadow: 1px 2px 5px #000;\\n  color: #fff;\\n  font-weight: bold;\\n  padding: 4px 0.5em;\\n  position: absolute;\\n  right: 200px;\\n  text-decoration: none;\\n  text-shadow: 1px 1px #000;\\n  top: 0;\\n  transition-property: padding-top;\\n  transition-duration: 0.25s;\\n}\\n#feedback:hover {\\n  padding-top: 1em;\\n}\\n\";",
      "type": "blob"
    },
    "templates/asset-form": {
      "path": "templates/asset-form",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"form\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n        __root.buffer(\"Use Image for:\\n\");\n      }));\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"input\", this, {\n          \"type\": \"radio\",\n          \"name\": \"selection\",\n          \"value\": \"avatar\",\n          \"checked\": \"true\"\n        }, function(__root) {}));\n        __root.buffer(__root.element(\"h2\", this, {}, function(__root) {\n          __root.buffer(\"Avatar\\n\");\n        }));\n      }));\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"input\", this, {\n          \"type\": \"radio\",\n          \"name\": \"selection\",\n          \"value\": \"background\"\n        }, function(__root) {}));\n        __root.buffer(__root.element(\"h2\", this, {}, function(__root) {\n          __root.buffer(\"Background\\n\");\n        }));\n      }));\n      __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n        __root.buffer(\"Submit\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/avatar-control": {
      "path": "templates/avatar-control",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"avatar-control\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"tab\", this, {\n        \"click\": this.toggleOpen\n      }, function(__root) {\n        __root.buffer(\"Avatar\\n\");\n      }));\n      __root.buffer(__root.element(\"avatars\", this, {}, function(__root) {\n        __root.buffer(this.avatars);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/avatar": {
      "path": "templates/avatar",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"avatar\", this, {\n      \"click\": this.click\n    }, function(__root) {\n      __root.buffer(__root.element(\"img\", this, {\n        \"src\": this.avatarURL\n      }, function(__root) {}));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/chateau": {
      "path": "templates/chateau",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var AvatarControl, FriendsControl, PropControl, RoomList, __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    AvatarControl = require(\"./avatar-control\");\n    FriendsControl = require(\"./friends-control\");\n    PropControl = require(\"./prop-control\");\n    RoomList = require(\"./room-list\");\n    __root.buffer(__root.element(\"chateau\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"viewport\", this, {}, function(__root) {\n        __root.buffer(this.canvas);\n        __root.buffer(__root.element(\"word-area\", this, {}, function(__root) {\n          __root.buffer(this.words);\n        }));\n      }));\n      __root.buffer(__root.element(\"actions\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"form\", this, {\n          \"submit\": this.saySubmit\n        }, function(__root) {\n          __root.buffer(__root.element(\"input\", this, {}, function(__root) {}));\n          __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n            __root.buffer(\"Speak\\n\");\n          }));\n        }));\n      }));\n      __root.buffer(__root.element(\"tab-drawer\", this, {}, function(__root) {\n        __root.buffer(RoomList(this));\n        __root.buffer(__root.element(\"log-control\", this, {}, function(__root) {\n          stats.increment(\"render.log-control\");\n          __root.buffer(__root.element(\"tab\", this, {\n            \"click\": this.toggleOpen\n          }, function(__root) {\n            __root.buffer(\"Log\\n\");\n          }));\n          __root.buffer(this.logs);\n        }));\n        __root.buffer(PropControl(this));\n        __root.buffer(__root.element(\"sound-control\", this, {}, function(__root) {\n          __root.buffer(__root.element(\"tab\", this, {\n            \"click\": this.toggleOpen\n          }, function(__root) {\n            __root.buffer(\"Sounds\\n\");\n          }));\n          __root.buffer(__root.element(\"h2\", this, {}, function(__root) {\n            __root.buffer(\"Coming Soon!\\n\");\n          }));\n        }));\n        __root.buffer(AvatarControl(this));\n        __root.buffer(FriendsControl(this));\n        __root.buffer(__root.element(\"account-control\", this, {}, function(__root) {\n          __root.buffer(__root.element(\"tab\", this, {\n            \"click\": this.toggleOpen\n          }, function(__root) {\n            __root.buffer(\"Account\\n\");\n          }));\n          __root.buffer(__root.element(\"form\", this, {\n            \"class\": [this.displayNameFormClass],\n            \"submit\": this.displayNameFormSubmit\n          }, function(__root) {\n            __root.buffer(__root.element(\"micro-controls\", this, {}, function(__root) {\n              __root.buffer(__root.element(\"button\", this, {\n                \"class\": [\"accept\"]\n              }, function(__root) {}));\n              __root.buffer(__root.element(\"button\", this, {\n                \"class\": [\"cancel\"],\n                \"click\": this.resetDisplayNameInput\n              }, function(__root) {}));\n            }));\n            __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n              __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n                __root.buffer(\"Display Name\\n\");\n              }));\n              __root.buffer(__root.element(\"input\", this, {\n                \"value\": this.displayNameInput\n              }, function(__root) {}));\n            }));\n          }));\n          __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n            __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n              __root.buffer(\"Account ID\\n\");\n            }));\n            __root.buffer(__root.element(\"span\", this, {}, function(__root) {\n              __root.buffer(this.currentAccountId);\n            }));\n          }));\n          __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n            __root.buffer(__root.element(\"button\", this, {\n              \"click\": this.logout\n            }, function(__root) {\n              __root.buffer(\"Sign Out\\n\");\n            }));\n          }));\n        }));\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/login": {
      "path": "templates/login",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"form\", this, {\n      id: [\"login\"]\n    }, function(__root) {\n      __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n        __root.buffer(\"Connect to Chateau\\n\");\n      }));\n      __root.buffer(__root.element(\"h2\", this, {}, function(__root) {\n        __root.buffer(\"Log in with\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.facebookLogin\n      }, function(__root) {\n        __root.buffer(\"Facebook\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.githubLogin\n      }, function(__root) {\n        __root.buffer(\"GitHub\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.googleLogin\n      }, function(__root) {\n        __root.buffer(\"Google\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/prop-control": {
      "path": "templates/prop-control",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"prop-control\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"tab\", this, {\n        \"click\": this.toggleOpen\n      }, function(__root) {\n        __root.buffer(\"Props\\n\");\n      }));\n      __root.buffer(__root.element(\"props\", this, {}, function(__root) {\n        __root.buffer(this.props);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/prop": {
      "path": "templates/prop",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"prop\", this, {\n      \"click\": this.click\n    }, function(__root) {\n      __root.buffer(__root.element(\"img\", this, {\n        \"src\": this.imageURL\n      }, function(__root) {}));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/room-list": {
      "path": "templates/room-list",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"room-control\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"tab\", this, {\n        \"click\": this.toggleOpen\n      }, function(__root) {\n        __root.buffer(\"Rooms\\n\");\n      }));\n      __root.buffer(__root.element(\"actions\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.createRoom\n        }, function(__root) {\n          __root.buffer(\"+ New\\n\");\n        }));\n      }));\n      __root.buffer(__root.element(\"rooms\", this, {}, function(__root) {\n        __root.buffer(this.rooms);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/room": {
      "path": "templates/room",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"room\", this, {\n      \"click\": this.click\n    }, function(__root) {\n      __root.buffer(__root.element(\"img\", this, {\n        \"src\": this.imageURL\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"div\", this, {\n        \"class\": [\"details\"]\n      }, function(__root) {\n        __root.buffer(__root.element(\"span\", this, {\n          \"class\": [\"name\"]\n        }, function(__root) {\n          __root.buffer(this.name);\n        }));\n        __root.buffer(__root.element(\"br\", this, {}, function(__root) {}));\n        __root.buffer(__root.element(\"span\", this, {\n          \"class\": [\"occupants\"]\n        }, function(__root) {\n          __root.buffer(\"👤 \");\n          __root.buffer(this.numberOfCurrentOccupants);\n        }));\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "util": {
      "path": "util",
      "content": "(function() {\n  var __slice = [].slice;\n\n  module.exports = {\n    defaults: function() {\n      var name, object, objects, target, _i, _len;\n      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      for (_i = 0, _len = objects.length; _i < _len; _i++) {\n        object = objects[_i];\n        for (name in object) {\n          if (!target.hasOwnProperty(name)) {\n            target[name] = object[name];\n          }\n        }\n      }\n      return target;\n    },\n    sortBy: function(attribute) {\n      return function(a, b) {\n        return a[attribute] - b[attribute];\n      };\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "templates/debug-control": {
      "path": "templates/debug-control",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"debug-control\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"tab\", this, {\n        \"click\": this.toggleOpen\n      }, function(__root) {\n        __root.buffer(\"Debug\\n\");\n      }));\n      __root.buffer(this.statsElement);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "templates/friends-control": {
      "path": "templates/friends-control",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var FriendTemplate, __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    FriendTemplate = require(\"./friend\");\n    __root.buffer(__root.element(\"friends-control\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"tab\", this, {\n        \"click\": this.toggleOpen\n      }, function(__root) {\n        __root.buffer(\"Friends\\n\");\n      }));\n      __root.buffer(__root.element(\"friends\", this, {}, function(__root) {\n        [0, 1, 2, 3].map(function() {\n          return __root.buffer(FriendTemplate());\n        });\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "models/presence": {
      "path": "models/presence",
      "content": "(function() {\n  var Base;\n\n  Base = require(\"./base\");\n\n  module.exports = Base(\"presence\", function(I, self) {\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Model(I);\n    }\n    self.attrSync(\"online\", \"lastSeen\", \"status\");\n    return self;\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "presenters/friends": {
      "path": "presenters/friends",
      "content": "(function() {\n  var Template;\n\n  Template = require(\"../templates/friends\");\n\n  module.exports = function(self) {\n    var element;\n    return element = Template(self);\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "templates/friend": {
      "path": "templates/friend",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"friend\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"img\", this, {\n        \"class\": [\"profile\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"online-status\", this, {}, function(__root) {}));\n      __root.buffer(__root.element(\"info\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"div\", this, {\n          \"class\": [\"name\"]\n        }, function(__root) {\n          __root.buffer(\"Duder\\n\");\n        }));\n        __root.buffer(__root.element(\"div\", this, {\n          \"class\": [\"status-message\"]\n        }, function(__root) {\n          __root.buffer(\"lul wut\\n\");\n        }));\n      }));\n      __root.buffer(__root.element(\"time\", this, {\n        \"class\": [\"last-seen\"]\n      }, function(__root) {\n        __root.buffer(\"Ages ago\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "lib/hamlet-runtime": {
      "path": "lib/hamlet-runtime",
      "content": "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.HamletRuntime = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  \"use strict\";\n  var Observable, Runtime, bindEvent, bindObservable, bufferTo, classes, createElement, empty, eventNames, get, id, isEvent, isFragment, makeElement, observeAttribute, observeAttributes, observeContent, specialBindings, valueBind, valueIndexOf;\n\n  Observable = require(\"o_0\");\n\n  eventNames = \"abort\\nblur\\nchange\\nclick\\ncontextmenu\\ndblclick\\ndrag\\ndragend\\ndragenter\\ndragexit\\ndragleave\\ndragover\\ndragstart\\ndrop\\nerror\\nfocus\\ninput\\nkeydown\\nkeypress\\nkeyup\\nload\\nmousedown\\nmousemove\\nmouseout\\nmouseover\\nmouseup\\nreset\\nresize\\nscroll\\nselect\\nsubmit\\ntouchcancel\\ntouchend\\ntouchenter\\ntouchleave\\ntouchmove\\ntouchstart\\nunload\".split(\"\\n\");\n\n  isEvent = function(name) {\n    return eventNames.indexOf(name) !== -1;\n  };\n\n  isFragment = function(node) {\n    return (node != null ? node.nodeType : void 0) === 11;\n  };\n\n  valueBind = function(element, value, context) {\n    Observable(function() {\n      var update;\n      value = Observable(value, context);\n      switch (element.nodeName) {\n        case \"SELECT\":\n          element.oninput = element.onchange = function() {\n            var optionValue, _ref, _value;\n            _ref = this.children[this.selectedIndex], optionValue = _ref.value, _value = _ref._value;\n            return value(_value || optionValue);\n          };\n          update = function(newValue) {\n            var options;\n            element._value = newValue;\n            if ((options = element._options)) {\n              if (newValue.value != null) {\n                return element.value = (typeof newValue.value === \"function\" ? newValue.value() : void 0) || newValue.value;\n              } else {\n                return element.selectedIndex = valueIndexOf(options, newValue);\n              }\n            } else {\n              return element.value = newValue;\n            }\n          };\n          return bindObservable(element, value, context, update);\n        default:\n          element.oninput = element.onchange = function() {\n            return value(element.value);\n          };\n          if (typeof element.attachEvent === \"function\") {\n            element.attachEvent(\"onkeydown\", function() {\n              return setTimeout(function() {\n                return value(element.value);\n              }, 0);\n            });\n          }\n          return bindObservable(element, value, context, function(newValue) {\n            if (element.value !== newValue) {\n              return element.value = newValue;\n            }\n          });\n      }\n    });\n  };\n\n  specialBindings = {\n    INPUT: {\n      checked: function(element, value, context) {\n        element.onchange = function() {\n          return typeof value === \"function\" ? value(element.checked) : void 0;\n        };\n        return bindObservable(element, value, context, function(newValue) {\n          return element.checked = newValue;\n        });\n      }\n    },\n    SELECT: {\n      options: function(element, values, context) {\n        var updateValues;\n        values = Observable(values, context);\n        updateValues = function(values) {\n          empty(element);\n          element._options = values;\n          return values.map(function(value, index) {\n            var option, optionName, optionValue;\n            option = createElement(\"option\");\n            option._value = value;\n            if (typeof value === \"object\") {\n              optionValue = (value != null ? value.value : void 0) || index;\n            } else {\n              optionValue = value.toString();\n            }\n            bindObservable(option, optionValue, value, function(newValue) {\n              return option.value = newValue;\n            });\n            optionName = (value != null ? value.name : void 0) || value;\n            bindObservable(option, optionName, value, function(newValue) {\n              return option.textContent = option.innerText = newValue;\n            });\n            element.appendChild(option);\n            if (value === element._value) {\n              element.selectedIndex = index;\n            }\n            return option;\n          });\n        };\n        return bindObservable(element, values, context, updateValues);\n      }\n    }\n  };\n\n  observeAttribute = function(element, context, name, value) {\n    var binding, nodeName, _ref;\n    nodeName = element.nodeName;\n    if (name === \"value\") {\n      valueBind(element, value);\n    } else if (binding = (_ref = specialBindings[nodeName]) != null ? _ref[name] : void 0) {\n      binding(element, value, context);\n    } else if (name.match(/^on/) && isEvent(name.substr(2))) {\n      bindEvent(element, name, value, context);\n    } else if (isEvent(name)) {\n      bindEvent(element, \"on\" + name, value, context);\n    } else {\n      bindObservable(element, value, context, function(newValue) {\n        if ((newValue != null) && newValue !== false) {\n          return element.setAttribute(name, newValue);\n        } else {\n          return element.removeAttribute(name);\n        }\n      });\n    }\n    return element;\n  };\n\n  observeAttributes = function(element, context, attributes) {\n    return Object.keys(attributes).forEach(function(name) {\n      var value;\n      value = attributes[name];\n      return observeAttribute(element, context, name, value);\n    });\n  };\n\n  bindObservable = function(element, value, context, update) {\n    var observable, observe, unobserve;\n    observable = Observable(value, context);\n    observe = function() {\n      observable.observe(update);\n      return update(observable());\n    };\n    unobserve = function() {\n      return observable.stopObserving(update);\n    };\n    observe();\n    return element;\n  };\n\n  bindEvent = function(element, name, fn, context) {\n    return element[name] = function() {\n      return fn.apply(context, arguments);\n    };\n  };\n\n  id = function(element, context, sources) {\n    var lastId, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(newId) {\n      return element.id = newId;\n    };\n    lastId = function() {\n      return value.last();\n    };\n    return bindObservable(element, lastId, context, update);\n  };\n\n  classes = function(element, context, sources) {\n    var classNames, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(classNames) {\n      return element.className = classNames;\n    };\n    classNames = function() {\n      return value.join(\" \");\n    };\n    return bindObservable(element, classNames, context, update);\n  };\n\n  createElement = function(name) {\n    return document.createElement(name);\n  };\n\n  observeContent = function(element, context, contentFn) {\n    var append, contents, update;\n    contents = [];\n    contentFn.call(context, {\n      buffer: bufferTo(context, contents),\n      element: makeElement\n    });\n    append = function(item) {\n      if (item == null) {\n\n      } else if (typeof item === \"string\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"number\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"boolean\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item.each === \"function\") {\n        return item.each(append);\n      } else if (typeof item.forEach === \"function\") {\n        return item.forEach(append);\n      } else {\n        return element.appendChild(item);\n      }\n    };\n    update = function(contents) {\n      empty(element);\n      return contents.forEach(append);\n    };\n    return update(contents);\n  };\n\n  bufferTo = function(context, collection) {\n    return function(content) {\n      if (typeof content === 'function') {\n        content = Observable(content, context);\n      }\n      collection.push(content);\n      return content;\n    };\n  };\n\n  makeElement = function(name, context, attributes, fn) {\n    var element;\n    if (attributes == null) {\n      attributes = {};\n    }\n    element = createElement(name);\n    Observable(function() {\n      if (attributes.id != null) {\n        id(element, context, attributes.id);\n        return delete attributes.id;\n      }\n    });\n    Observable(function() {\n      if (attributes[\"class\"] != null) {\n        classes(element, context, attributes[\"class\"]);\n        return delete attributes[\"class\"];\n      }\n    });\n    Observable(function() {\n      return observeAttributes(element, context, attributes);\n    }, context);\n    if (element.nodeName !== \"SELECT\") {\n      Observable(function() {\n        return observeContent(element, context, fn);\n      }, context);\n    }\n    return element;\n  };\n\n  Runtime = function(context) {\n    var self;\n    self = {\n      buffer: function(content) {\n        if (self.root) {\n          throw \"Cannot have multiple root elements\";\n        }\n        return self.root = content;\n      },\n      element: makeElement,\n      filter: function(name, content) {}\n    };\n    return self;\n  };\n\n  Runtime.VERSION = require(\"../package.json\").version;\n\n  Runtime.Observable = Observable;\n\n  module.exports = Runtime;\n\n  empty = function(node) {\n    var child, _results;\n    _results = [];\n    while (child = node.firstChild) {\n      _results.push(node.removeChild(child));\n    }\n    return _results;\n  };\n\n  valueIndexOf = function(options, value) {\n    if (typeof value === \"object\") {\n      return options.indexOf(value);\n    } else {\n      return options.map(function(option) {\n        return option.toString();\n      }).indexOf(value.toString());\n    }\n  };\n\n  get = function(x) {\n    if (typeof x === 'function') {\n      return x();\n    } else {\n      return x;\n    }\n  };\n\n}).call(this);\n\n},{\"../package.json\":3,\"o_0\":2}],2:[function(require,module,exports){\n(function (global){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],3:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"hamlet.coffee\",\n  \"version\": \"0.7.6\",\n  \"description\": \"Truly amazing templating!\",\n  \"devDependencies\": {\n    \"browserify\": \"^12.0.1\",\n    \"coffee-script\": \"~1.7.1\",\n    \"jsdom\": \"^7.2.0\",\n    \"mocha\": \"^2.3.3\"\n  },\n  \"dependencies\": {\n    \"hamlet-compiler\": \"0.7.0\",\n    \"o_0\": \"0.3.8\"\n  },\n  \"homepage\": \"hamlet.coffee\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/dr-coffee-labs/hamlet.git\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"script/prepublish\",\n    \"test\": \"script/test\"\n  },\n  \"files\": [\n    \"dist/\"\n  ],\n  \"main\": \"dist/runtime.js\"\n}\n\n},{}]},{},[1])(1)\n});",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "https://danielx.net/editor/"
  },
  "config": {
    "width": 960,
    "height": 540,
    "remoteDependencies": [
      "https://www.gstatic.com/firebasejs/3.6.7/firebase.js"
    ],
    "dependencies": {
      "analytics": "distri/google-analytics:v0.1.0",
      "model": "distri/model:master",
      "ui": "STRd6/ui:master"
    }
  },
  "entryPoint": "main",
  "remoteDependencies": [
    "https://www.gstatic.com/firebasejs/3.6.7/firebase.js"
  ],
  "repository": {
    "branch": "master",
    "default_branch": "master",
    "full_name": "STRd6/chateau",
    "homepage": null,
    "description": "Remake of thepalace.com",
    "html_url": "https://github.com/STRd6/chateau",
    "url": "https://api.github.com/repos/STRd6/chateau",
    "publishBranch": "gh-pages"
  },
  "dependencies": {
    "analytics": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "mode": "100644",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "mode": "100644",
          "content": "google-analytics\n================\n\nGoogle analytics for distri apps\n",
          "type": "blob"
        },
        "lib/analytics.js": {
          "path": "lib/analytics.js",
          "mode": "100644",
          "content": "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n",
          "type": "blob"
        },
        "main.coffee.md": {
          "path": "main.coffee.md",
          "mode": "100644",
          "content": "Google Analytics\n================\n\n    module.exports =\n      init: (id) ->\n        require \"./lib/analytics\"\n\n        global.ga('create', id, 'auto')\n        global.ga('send', 'pageview')\n",
          "type": "blob"
        },
        "test/main.coffee": {
          "path": "test/main.coffee",
          "mode": "100644",
          "content": "mocha.globals(\"ga\")\n\ndescribe \"analytics\", ->\n  it \"should put analytics on the page\", ->\n    GA = require \"../main\"\n\n    GA.init(\"UA-XXXX-Y\")\n\n  it \"should be a chill bro\", ->\n    ga(\"send\", \"duder\")\n",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "mode": "100644",
          "content": "version: \"0.1.0\"\n",
          "type": "blob"
        }
      },
      "distribution": {
        "lib/analytics": {
          "path": "lib/analytics",
          "content": "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n",
          "type": "blob"
        },
        "main": {
          "path": "main",
          "content": "(function() {\n  module.exports = {\n    init: function(id) {\n      require(\"./lib/analytics\");\n      global.ga('create', id, 'auto');\n      return global.ga('send', 'pageview');\n    }\n  };\n\n}).call(this);\n\n//# sourceURL=main.coffee",
          "type": "blob"
        },
        "test/main": {
          "path": "test/main",
          "content": "(function() {\n  mocha.globals(\"ga\");\n\n  describe(\"analytics\", function() {\n    it(\"should put analytics on the page\", function() {\n      var GA;\n      GA = require(\"../main\");\n      return GA.init(\"UA-XXXX-Y\");\n    });\n    return it(\"should be a chill bro\", function() {\n      return ga(\"send\", \"duder\");\n    });\n  });\n\n}).call(this);\n\n//# sourceURL=test/main.coffee",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.1.0\"};",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "http://strd6.github.io/editor/"
      },
      "version": "0.1.0",
      "entryPoint": "main",
      "repository": {
        "id": 17791404,
        "name": "google-analytics",
        "full_name": "distri/google-analytics",
        "owner": {
          "login": "distri",
          "id": 6005125,
          "avatar_url": "https://gravatar.com/avatar/192f3f168409e79c42107f081139d9f3?d=https%3A%2F%2Fidenticons.github.com%2Ff90c81ffc1498e260c820082f2e7ca5f.png&r=x",
          "gravatar_id": "192f3f168409e79c42107f081139d9f3",
          "url": "https://api.github.com/users/distri",
          "html_url": "https://github.com/distri",
          "followers_url": "https://api.github.com/users/distri/followers",
          "following_url": "https://api.github.com/users/distri/following{/other_user}",
          "gists_url": "https://api.github.com/users/distri/gists{/gist_id}",
          "starred_url": "https://api.github.com/users/distri/starred{/owner}{/repo}",
          "subscriptions_url": "https://api.github.com/users/distri/subscriptions",
          "organizations_url": "https://api.github.com/users/distri/orgs",
          "repos_url": "https://api.github.com/users/distri/repos",
          "events_url": "https://api.github.com/users/distri/events{/privacy}",
          "received_events_url": "https://api.github.com/users/distri/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/distri/google-analytics",
        "description": "Google analytics for distri apps",
        "fork": false,
        "url": "https://api.github.com/repos/distri/google-analytics",
        "forks_url": "https://api.github.com/repos/distri/google-analytics/forks",
        "keys_url": "https://api.github.com/repos/distri/google-analytics/keys{/key_id}",
        "collaborators_url": "https://api.github.com/repos/distri/google-analytics/collaborators{/collaborator}",
        "teams_url": "https://api.github.com/repos/distri/google-analytics/teams",
        "hooks_url": "https://api.github.com/repos/distri/google-analytics/hooks",
        "issue_events_url": "https://api.github.com/repos/distri/google-analytics/issues/events{/number}",
        "events_url": "https://api.github.com/repos/distri/google-analytics/events",
        "assignees_url": "https://api.github.com/repos/distri/google-analytics/assignees{/user}",
        "branches_url": "https://api.github.com/repos/distri/google-analytics/branches{/branch}",
        "tags_url": "https://api.github.com/repos/distri/google-analytics/tags",
        "blobs_url": "https://api.github.com/repos/distri/google-analytics/git/blobs{/sha}",
        "git_tags_url": "https://api.github.com/repos/distri/google-analytics/git/tags{/sha}",
        "git_refs_url": "https://api.github.com/repos/distri/google-analytics/git/refs{/sha}",
        "trees_url": "https://api.github.com/repos/distri/google-analytics/git/trees{/sha}",
        "statuses_url": "https://api.github.com/repos/distri/google-analytics/statuses/{sha}",
        "languages_url": "https://api.github.com/repos/distri/google-analytics/languages",
        "stargazers_url": "https://api.github.com/repos/distri/google-analytics/stargazers",
        "contributors_url": "https://api.github.com/repos/distri/google-analytics/contributors",
        "subscribers_url": "https://api.github.com/repos/distri/google-analytics/subscribers",
        "subscription_url": "https://api.github.com/repos/distri/google-analytics/subscription",
        "commits_url": "https://api.github.com/repos/distri/google-analytics/commits{/sha}",
        "git_commits_url": "https://api.github.com/repos/distri/google-analytics/git/commits{/sha}",
        "comments_url": "https://api.github.com/repos/distri/google-analytics/comments{/number}",
        "issue_comment_url": "https://api.github.com/repos/distri/google-analytics/issues/comments/{number}",
        "contents_url": "https://api.github.com/repos/distri/google-analytics/contents/{+path}",
        "compare_url": "https://api.github.com/repos/distri/google-analytics/compare/{base}...{head}",
        "merges_url": "https://api.github.com/repos/distri/google-analytics/merges",
        "archive_url": "https://api.github.com/repos/distri/google-analytics/{archive_format}{/ref}",
        "downloads_url": "https://api.github.com/repos/distri/google-analytics/downloads",
        "issues_url": "https://api.github.com/repos/distri/google-analytics/issues{/number}",
        "pulls_url": "https://api.github.com/repos/distri/google-analytics/pulls{/number}",
        "milestones_url": "https://api.github.com/repos/distri/google-analytics/milestones{/number}",
        "notifications_url": "https://api.github.com/repos/distri/google-analytics/notifications{?since,all,participating}",
        "labels_url": "https://api.github.com/repos/distri/google-analytics/labels{/name}",
        "releases_url": "https://api.github.com/repos/distri/google-analytics/releases{/id}",
        "created_at": "2014-03-16T03:39:25Z",
        "updated_at": "2014-03-16T03:39:25Z",
        "pushed_at": "2014-03-16T03:39:25Z",
        "git_url": "git://github.com/distri/google-analytics.git",
        "ssh_url": "git@github.com:distri/google-analytics.git",
        "clone_url": "https://github.com/distri/google-analytics.git",
        "svn_url": "https://github.com/distri/google-analytics",
        "homepage": null,
        "size": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "language": null,
        "has_issues": true,
        "has_downloads": true,
        "has_wiki": true,
        "forks_count": 0,
        "mirror_url": null,
        "open_issues_count": 0,
        "forks": 0,
        "open_issues": 0,
        "watchers": 0,
        "default_branch": "master",
        "master_branch": "master",
        "permissions": {
          "admin": true,
          "push": true,
          "pull": true
        },
        "organization": {
          "login": "distri",
          "id": 6005125,
          "avatar_url": "https://gravatar.com/avatar/192f3f168409e79c42107f081139d9f3?d=https%3A%2F%2Fidenticons.github.com%2Ff90c81ffc1498e260c820082f2e7ca5f.png&r=x",
          "gravatar_id": "192f3f168409e79c42107f081139d9f3",
          "url": "https://api.github.com/users/distri",
          "html_url": "https://github.com/distri",
          "followers_url": "https://api.github.com/users/distri/followers",
          "following_url": "https://api.github.com/users/distri/following{/other_user}",
          "gists_url": "https://api.github.com/users/distri/gists{/gist_id}",
          "starred_url": "https://api.github.com/users/distri/starred{/owner}{/repo}",
          "subscriptions_url": "https://api.github.com/users/distri/subscriptions",
          "organizations_url": "https://api.github.com/users/distri/orgs",
          "repos_url": "https://api.github.com/users/distri/repos",
          "events_url": "https://api.github.com/users/distri/events{/privacy}",
          "received_events_url": "https://api.github.com/users/distri/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "network_count": 0,
        "subscribers_count": 2,
        "branch": "v0.1.0",
        "publishBranch": "gh-pages"
      },
      "dependencies": {}
    },
    "model": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "Model\n=====\n\nThe `Model` module provides helper methods to compose nested data models.\n\nModels uses [Observable](/observable/docs) to keep the internal data in sync.\n",
          "mode": "100644",
          "type": "blob"
        },
        "core.coffee.md": {
          "path": "core.coffee.md",
          "content": "Core\n====\n\nThe Core module is used to add extended functionality to objects without\nextending `Object.prototype` directly.\n\n    Core = (I={}, self={}) ->\n      Object.assign self,\n\nExternal access to instance variables. Use of this property should be avoided\nin general, but can come in handy from time to time.\n\n>     #! example\n>     I =\n>       r: 255\n>       g: 0\n>       b: 100\n>\n>     myObject = Core(I)\n>\n>     [myObject.I.r, myObject.I.g, myObject.I.b]\n\n        I: I\n\nGenerates a public jQuery style getter / setter method for each `String` argument.\n\n>     #! example\n>     myObject = Core\n>       r: 255\n>       g: 0\n>       b: 100\n>\n>     myObject.attrAccessor \"r\", \"g\", \"b\"\n>\n>     myObject.r(254)\n\n        attrAccessor: (attrNames...) ->\n          attrNames.forEach (attrName) ->\n            self[attrName] = (newValue) ->\n              if arguments.length > 0\n                I[attrName] = newValue\n\n                return self\n              else\n                I[attrName]\n\n          return self\n\nGenerates a public jQuery style getter method for each String argument.\n\n>     #! example\n>     myObject = Core\n>       r: 255\n>       g: 0\n>       b: 100\n>\n>     myObject.attrReader \"r\", \"g\", \"b\"\n>\n>     [myObject.r(), myObject.g(), myObject.b()]\n\n        attrReader: (attrNames...) ->\n          attrNames.forEach (attrName) ->\n            self[attrName] = ->\n              I[attrName]\n\n          return self\n\nExtends this object with methods from the passed in object. A shortcut for Object.extend(self, methods)\n\n>     I =\n>       x: 30\n>       y: 40\n>       maxSpeed: 5\n>\n>     # we are using extend to give player\n>     # additional methods that Core doesn't have\n>     player = Core(I).extend\n>       increaseSpeed: ->\n>         I.maxSpeed += 1\n>\n>     player.increaseSpeed()\n\n        extend: (objects...) ->\n          Object.assign self, objects...\n\nIncludes a module in this object. A module is a constructor that takes two parameters, `I` and `self`\n\n>     myObject = Core()\n>     myObject.include(Bindable)\n\n>     # now you can bind handlers to functions\n>     myObject.bind \"someEvent\", ->\n>       alert(\"wow. that was easy.\")\n\n        include: (modules...) ->\n          for Module in modules\n            Module(I, self)\n\n          return self\n\n      return self\n\nExport\n\n    module.exports = Core\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee.md": {
          "path": "main.coffee.md",
          "content": "Model\n=====\n\nThe `Model` module provides helper methods to compose nested data models.\n\nModels uses [Observable](/observable/docs) to keep the internal data in sync.\n\n    Core = require \"./core\"\n    Observable = global.Observable ? require \"observable\"\n\n    module.exports = Model = (I={}, self=Core(I)) ->\n\n      self.extend\n\nBind a data model getter/setter to an attribute. The data model is bound directly to\nthe attribute and must be directly convertible to and from JSON.\n\n        attrData: (name, DataModel) ->\n          I[name] = DataModel(I[name])\n\n          Object.defineProperty self, name,\n            get: ->\n              I[name]\n            set: (value) ->\n              I[name] = DataModel(value)\n\nObserve any number of attributes as observables. For each attribute name passed in we expose a public getter/setter method and listen to changes when the value is set.\n\n        attrObservable: (names...) ->\n          names.forEach (name) ->\n            self[name] = Observable(I[name])\n\n            self[name].observe (newValue) ->\n              I[name] = newValue\n\n          return self\n\nObserve an attribute as a model. Treats the attribute given as an Observable\nmodel instance exposing a getter/setter method of the same name. The Model\nconstructor must be passed explicitly.\n\n        attrModel: (name, Model) ->\n          model = Model(I[name])\n\n          self[name] = Observable(model)\n\n          self[name].observe (newValue) ->\n            I[name] = newValue.I\n\n          return self\n\nObserve an attribute as an array of sub-models. This is the same as `attrModel`\nexcept the attribute is expected to be an array of models rather than a single one.\n\n        attrModels: (name, Model) ->\n          models = (I[name] or []).map (x) ->\n            Model(x)\n\n          self[name] = Observable(models)\n\n          self[name].observe (newValue) ->\n            I[name] = newValue.map (instance) ->\n              instance.I\n\n          return self\n\n        delegate: (names..., {to}) ->\n          names.forEach (name) ->\n            console.log \"delegating #{name} to #{to}\"\n            Object.defineProperty self, name,\n              get: ->\n                receiver = getValue self, to\n                receiver[name]\n              set: (value) ->\n                receiver = getValue self, to\n                setValue receiver, name, value\n\nThe JSON representation is kept up to date via the observable properites and resides in `I`.\n\n        toJSON: ->\n          I\n\nReturn our public object.\n\n      return self\n\n    isFn = (x) ->\n      typeof x is 'function'\n\n    getValue = (receiver, property) ->\n      if isFn receiver[property]\n        receiver[property]()\n      else\n        receiver[property]\n\n    setValue = (receiver, property, value) ->\n      target = receiver[property]\n\n      if isFn target\n        target.call(receiver, value)\n      else\n        receiver[property] = value\n\n    {defaults, extend} = require \"./util\"\n    Object.assign Model, {Core, Observable, defaults, extend}\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.2.0-pre.4\"\ndependencies:\n  observable: \"distri/observable:v0.3.8\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/core.coffee": {
          "path": "test/core.coffee",
          "content": "Core = require \"../core\"\n\nok = assert\nequals = assert.equal\ntest = it\n\ndescribe \"Core\", ->\n\n  test \"#extend\", ->\n    o = Core()\n\n    o.extend\n      test: \"jawsome\"\n\n    equals o.test, \"jawsome\"\n\n  test \"#attrAccessor\", ->\n    o = Core\n      test: \"my_val\"\n\n    o.attrAccessor(\"test\")\n\n    equals o.test(), \"my_val\"\n    equals o.test(\"new_val\"), o\n    equals o.test(), \"new_val\"\n\n  test \"#attrReader\", ->\n    o = Core\n      test: \"my_val\"\n\n    o.attrReader(\"test\")\n\n    equals o.test(), \"my_val\"\n    equals o.test(\"new_val\"), \"my_val\"\n    equals o.test(), \"my_val\"\n\n  test \"#include\", ->\n    o = Core\n      test: \"my_val\"\n\n    M = (I, self) ->\n      self.attrReader \"test\"\n\n      self.extend\n        test2: \"cool\"\n\n    ret = o.include M\n\n    equals ret, o, \"Should return self\"\n\n    equals o.test(), \"my_val\"\n    equals o.test2, \"cool\"\n\n  test \"#include multiple\", ->\n    o = Core\n      test: \"my_val\"\n\n    M = (I, self) ->\n      self.attrReader \"test\"\n\n      self.extend\n        test2: \"cool\"\n\n    M2 = (I, self) ->\n      self.extend\n        test2: \"coolio\"\n\n    o.include M, M2\n\n    equals o.test2, \"coolio\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/model.coffee": {
          "path": "test/model.coffee",
          "content": "Model = require \"../main\"\n\ndescribe 'Model', ->\n  # Association Testing model\n  Person = (I) ->\n    person = Model(I)\n\n    person.attrAccessor(\n      'firstName'\n      'lastName'\n      'suffix'\n    )\n\n    person.fullName = ->\n      \"#{@firstName()} #{@lastName()} #{@suffix()}\"\n\n    return person\n\n  describe \"#attrData\", ->\n    pointProto =\n      add: ({x, y}) ->\n        @x += x\n        @y += y\n\n    Point = ({x, y}) ->\n      Object.create pointProto,\n        x:\n          value: x\n        y:\n          value: y\n\n    it \"should expose a property mapping to the instance data\", ->\n      model = Model\n        position:\n          x: 5\n          y: 5\n\n      model.attrData \"position\", Point\n\n      assert model.position.add\n\n      model.position.x = 12\n      assert.equal model.position.x, model.I.position.x\n\n      model.position =\n        x: 9\n        y: 6\n\n      assert.equal model.position.y, 6\n      assert.equal model.I.position.x, 9\n\n  describe \"#attrObservable\", ->\n    it 'should allow for observing of attributes', ->\n      model = Model\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n\n    it 'should bind properties to observable attributes', ->\n      model = Model\n        name: \"Duder\"\n\n      model.attrObservable \"name\"\n\n      model.name(\"Dudeman\")\n\n      assert.equal model.name(), \"Dudeman\"\n      assert.equal model.name(), model.I.name\n\n  describe \"#attrModel\", ->\n    it \"should be a model instance\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      assert.equal model.person().fullName(), \"Duder Mannington Jr.\"\n\n    it \"should allow setting the associated model\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      otherPerson = Person\n        firstName: \"Mr.\"\n        lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      assert.equal model.person().firstName(), \"Mr.\"\n\n    it \"shouldn't update the instance properties after it's been replaced\", ->\n      model = Model\n        person:\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n\n      model.attrModel(\"person\", Person)\n\n      duder = model.person()\n\n      otherPerson = Person\n        firstName: \"Mr.\"\n        lastName: \"Man\"\n\n      model.person(otherPerson)\n\n      duder.firstName(\"Joe\")\n\n      assert.equal duder.I.firstName, \"Joe\"\n      assert.equal model.I.person.firstName, \"Mr.\"\n\n  describe \"#attrModels\", ->\n    it \"should have an array of model instances\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      assert.equal model.people()[0].fullName(), \"Duder Mannington Jr.\"\n\n    it \"should track pushes\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.push Person\n        firstName: \"JoJo\"\n        lastName: \"Loco\"\n\n      assert.equal model.people().length, 3\n      assert.equal model.I.people.length, 3\n\n    it \"should track pops\", ->\n      model = Model\n        people: [{\n          firstName: \"Duder\"\n          lastName: \"Mannington\"\n          suffix: \"Jr.\"\n        }, {\n          firstName: \"Mr.\"\n          lastName: \"Mannington\"\n          suffix: \"Sr.\"\n        }]\n\n      model.attrModels(\"people\", Person)\n\n      model.people.pop()\n\n      assert.equal model.people().length, 1\n      assert.equal model.I.people.length, 1\n\n  describe \"#delegate\", ->\n    it \"should delegate to another method\", ->\n      model = Model\n        position:\n          x: 1\n          y: 2\n          z: 3\n\n      model.attrReader \"position\"\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position().x, 5\n      assert.equal model.I.position.x, 5\n\n    it \"should delegate to another property\", ->\n      model = Model\n        position:\n          x: 1\n          y: 2\n          z: 3\n\n      model.position = model.I.position\n\n      model.delegate \"x\", \"y\", \"z\", to: \"position\"\n\n      assert.equal model.x, 1\n      assert.equal model.y, 2\n      assert.equal model.z, 3\n\n      model.x = 5\n\n      assert.equal model.position.x, 5\n      assert.equal model.I.position.x, 5\n\n    it \"should delegate to methods just fine\", ->\n      model = Model\n        size:\n          width: 10\n          height: 20\n\n      model.attrData \"size\", ({width, height}) ->\n        width: -> width\n        height: -> height\n\n      model.delegate \"width\", \"height\", to: \"size\"\n\n      assert.equal model.width(), 10\n      assert.equal model.height(), 20\n\n  describe \"#toJSON\", ->\n    it \"should return an object appropriate for JSON serialization\", ->\n      model = Model\n        test: true\n\n      assert model.toJSON().test\n\n  describe \"#observeAll\", ->\n    it \"should observe all attributes of a simple model\"\n    ->  # TODO\n      model = Model\n        test: true\n        yolo: \"4life\"\n\n      model.observeAll()\n\n      assert model.test()\n      assert.equal model.yolo(), \"4life\"\n\n    it \"should camel case underscored names\"\n\n  describe \".defaults\", ->\n    it \"should expose defaults method\", ->\n      assert Model.defaults\n\n  describe \".extend\", ->\n    it \"should expose extend method\", ->\n      assert Model.extend\n",
          "mode": "100644",
          "type": "blob"
        },
        "util.coffee": {
          "path": "util.coffee",
          "content": "module.exports =\n  defaults: (target, objects...) ->\n    for object in objects\n      for name of object\n        unless target.hasOwnProperty(name)\n          target[name] = object[name]\n\n    return target\n\n  extend: Object.assign\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "core": {
          "path": "core",
          "content": "(function() {\n  var Core,\n    __slice = [].slice;\n\n  Core = function(I, self) {\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = {};\n    }\n    Object.assign(self, {\n      I: I,\n      attrAccessor: function() {\n        var attrNames;\n        attrNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        attrNames.forEach(function(attrName) {\n          return self[attrName] = function(newValue) {\n            if (arguments.length > 0) {\n              I[attrName] = newValue;\n              return self;\n            } else {\n              return I[attrName];\n            }\n          };\n        });\n        return self;\n      },\n      attrReader: function() {\n        var attrNames;\n        attrNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        attrNames.forEach(function(attrName) {\n          return self[attrName] = function() {\n            return I[attrName];\n          };\n        });\n        return self;\n      },\n      extend: function() {\n        var objects;\n        objects = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return Object.assign.apply(Object, [self].concat(__slice.call(objects)));\n      },\n      include: function() {\n        var Module, modules, _i, _len;\n        modules = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        for (_i = 0, _len = modules.length; _i < _len; _i++) {\n          Module = modules[_i];\n          Module(I, self);\n        }\n        return self;\n      }\n    });\n    return self;\n  };\n\n  module.exports = Core;\n\n}).call(this);\n",
          "type": "blob"
        },
        "main": {
          "path": "main",
          "content": "(function() {\n  var Core, Model, Observable, defaults, extend, getValue, isFn, setValue, _ref, _ref1,\n    __slice = [].slice;\n\n  Core = require(\"./core\");\n\n  Observable = (_ref = global.Observable) != null ? _ref : require(\"observable\");\n\n  module.exports = Model = function(I, self) {\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = Core(I);\n    }\n    self.extend({\n      attrData: function(name, DataModel) {\n        I[name] = DataModel(I[name]);\n        return Object.defineProperty(self, name, {\n          get: function() {\n            return I[name];\n          },\n          set: function(value) {\n            return I[name] = DataModel(value);\n          }\n        });\n      },\n      attrObservable: function() {\n        var names;\n        names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        names.forEach(function(name) {\n          self[name] = Observable(I[name]);\n          return self[name].observe(function(newValue) {\n            return I[name] = newValue;\n          });\n        });\n        return self;\n      },\n      attrModel: function(name, Model) {\n        var model;\n        model = Model(I[name]);\n        self[name] = Observable(model);\n        self[name].observe(function(newValue) {\n          return I[name] = newValue.I;\n        });\n        return self;\n      },\n      attrModels: function(name, Model) {\n        var models;\n        models = (I[name] || []).map(function(x) {\n          return Model(x);\n        });\n        self[name] = Observable(models);\n        self[name].observe(function(newValue) {\n          return I[name] = newValue.map(function(instance) {\n            return instance.I;\n          });\n        });\n        return self;\n      },\n      delegate: function() {\n        var names, to, _arg, _i;\n        names = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), _arg = arguments[_i++];\n        to = _arg.to;\n        return names.forEach(function(name) {\n          console.log(\"delegating \" + name + \" to \" + to);\n          return Object.defineProperty(self, name, {\n            get: function() {\n              var receiver;\n              receiver = getValue(self, to);\n              return receiver[name];\n            },\n            set: function(value) {\n              var receiver;\n              receiver = getValue(self, to);\n              return setValue(receiver, name, value);\n            }\n          });\n        });\n      },\n      toJSON: function() {\n        return I;\n      }\n    });\n    return self;\n  };\n\n  isFn = function(x) {\n    return typeof x === 'function';\n  };\n\n  getValue = function(receiver, property) {\n    if (isFn(receiver[property])) {\n      return receiver[property]();\n    } else {\n      return receiver[property];\n    }\n  };\n\n  setValue = function(receiver, property, value) {\n    var target;\n    target = receiver[property];\n    if (isFn(target)) {\n      return target.call(receiver, value);\n    } else {\n      return receiver[property] = value;\n    }\n  };\n\n  _ref1 = require(\"./util\"), defaults = _ref1.defaults, extend = _ref1.extend;\n\n  Object.assign(Model, {\n    Core: Core,\n    Observable: Observable,\n    defaults: defaults,\n    extend: extend\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.2.0-pre.4\",\"dependencies\":{\"observable\":\"distri/observable:v0.3.8\"}};",
          "type": "blob"
        },
        "test/core": {
          "path": "test/core",
          "content": "(function() {\n  var Core, equals, ok, test;\n\n  Core = require(\"../core\");\n\n  ok = assert;\n\n  equals = assert.equal;\n\n  test = it;\n\n  describe(\"Core\", function() {\n    test(\"#extend\", function() {\n      var o;\n      o = Core();\n      o.extend({\n        test: \"jawsome\"\n      });\n      return equals(o.test, \"jawsome\");\n    });\n    test(\"#attrAccessor\", function() {\n      var o;\n      o = Core({\n        test: \"my_val\"\n      });\n      o.attrAccessor(\"test\");\n      equals(o.test(), \"my_val\");\n      equals(o.test(\"new_val\"), o);\n      return equals(o.test(), \"new_val\");\n    });\n    test(\"#attrReader\", function() {\n      var o;\n      o = Core({\n        test: \"my_val\"\n      });\n      o.attrReader(\"test\");\n      equals(o.test(), \"my_val\");\n      equals(o.test(\"new_val\"), \"my_val\");\n      return equals(o.test(), \"my_val\");\n    });\n    test(\"#include\", function() {\n      var M, o, ret;\n      o = Core({\n        test: \"my_val\"\n      });\n      M = function(I, self) {\n        self.attrReader(\"test\");\n        return self.extend({\n          test2: \"cool\"\n        });\n      };\n      ret = o.include(M);\n      equals(ret, o, \"Should return self\");\n      equals(o.test(), \"my_val\");\n      return equals(o.test2, \"cool\");\n    });\n    return test(\"#include multiple\", function() {\n      var M, M2, o;\n      o = Core({\n        test: \"my_val\"\n      });\n      M = function(I, self) {\n        self.attrReader(\"test\");\n        return self.extend({\n          test2: \"cool\"\n        });\n      };\n      M2 = function(I, self) {\n        return self.extend({\n          test2: \"coolio\"\n        });\n      };\n      o.include(M, M2);\n      return equals(o.test2, \"coolio\");\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "test/model": {
          "path": "test/model",
          "content": "(function() {\n  var Model;\n\n  Model = require(\"../main\");\n\n  describe('Model', function() {\n    var Person;\n    Person = function(I) {\n      var person;\n      person = Model(I);\n      person.attrAccessor('firstName', 'lastName', 'suffix');\n      person.fullName = function() {\n        return \"\" + (this.firstName()) + \" \" + (this.lastName()) + \" \" + (this.suffix());\n      };\n      return person;\n    };\n    describe(\"#attrData\", function() {\n      var Point, pointProto;\n      pointProto = {\n        add: function(_arg) {\n          var x, y;\n          x = _arg.x, y = _arg.y;\n          this.x += x;\n          return this.y += y;\n        }\n      };\n      Point = function(_arg) {\n        var x, y;\n        x = _arg.x, y = _arg.y;\n        return Object.create(pointProto, {\n          x: {\n            value: x\n          },\n          y: {\n            value: y\n          }\n        });\n      };\n      return it(\"should expose a property mapping to the instance data\", function() {\n        var model;\n        model = Model({\n          position: {\n            x: 5,\n            y: 5\n          }\n        });\n        model.attrData(\"position\", Point);\n        assert(model.position.add);\n        model.position.x = 12;\n        assert.equal(model.position.x, model.I.position.x);\n        model.position = {\n          x: 9,\n          y: 6\n        };\n        assert.equal(model.position.y, 6);\n        return assert.equal(model.I.position.x, 9);\n      });\n    });\n    describe(\"#attrObservable\", function() {\n      it('should allow for observing of attributes', function() {\n        var model;\n        model = Model({\n          name: \"Duder\"\n        });\n        model.attrObservable(\"name\");\n        model.name(\"Dudeman\");\n        return assert.equal(model.name(), \"Dudeman\");\n      });\n      return it('should bind properties to observable attributes', function() {\n        var model;\n        model = Model({\n          name: \"Duder\"\n        });\n        model.attrObservable(\"name\");\n        model.name(\"Dudeman\");\n        assert.equal(model.name(), \"Dudeman\");\n        return assert.equal(model.name(), model.I.name);\n      });\n    });\n    describe(\"#attrModel\", function() {\n      it(\"should be a model instance\", function() {\n        var model;\n        model = Model({\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        });\n        model.attrModel(\"person\", Person);\n        return assert.equal(model.person().fullName(), \"Duder Mannington Jr.\");\n      });\n      it(\"should allow setting the associated model\", function() {\n        var model, otherPerson;\n        model = Model({\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        });\n        model.attrModel(\"person\", Person);\n        otherPerson = Person({\n          firstName: \"Mr.\",\n          lastName: \"Man\"\n        });\n        model.person(otherPerson);\n        return assert.equal(model.person().firstName(), \"Mr.\");\n      });\n      return it(\"shouldn't update the instance properties after it's been replaced\", function() {\n        var duder, model, otherPerson;\n        model = Model({\n          person: {\n            firstName: \"Duder\",\n            lastName: \"Mannington\",\n            suffix: \"Jr.\"\n          }\n        });\n        model.attrModel(\"person\", Person);\n        duder = model.person();\n        otherPerson = Person({\n          firstName: \"Mr.\",\n          lastName: \"Man\"\n        });\n        model.person(otherPerson);\n        duder.firstName(\"Joe\");\n        assert.equal(duder.I.firstName, \"Joe\");\n        return assert.equal(model.I.person.firstName, \"Mr.\");\n      });\n    });\n    describe(\"#attrModels\", function() {\n      it(\"should have an array of model instances\", function() {\n        var model;\n        model = Model({\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        });\n        model.attrModels(\"people\", Person);\n        return assert.equal(model.people()[0].fullName(), \"Duder Mannington Jr.\");\n      });\n      it(\"should track pushes\", function() {\n        var model;\n        model = Model({\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        });\n        model.attrModels(\"people\", Person);\n        model.people.push(Person({\n          firstName: \"JoJo\",\n          lastName: \"Loco\"\n        }));\n        assert.equal(model.people().length, 3);\n        return assert.equal(model.I.people.length, 3);\n      });\n      return it(\"should track pops\", function() {\n        var model;\n        model = Model({\n          people: [\n            {\n              firstName: \"Duder\",\n              lastName: \"Mannington\",\n              suffix: \"Jr.\"\n            }, {\n              firstName: \"Mr.\",\n              lastName: \"Mannington\",\n              suffix: \"Sr.\"\n            }\n          ]\n        });\n        model.attrModels(\"people\", Person);\n        model.people.pop();\n        assert.equal(model.people().length, 1);\n        return assert.equal(model.I.people.length, 1);\n      });\n    });\n    describe(\"#delegate\", function() {\n      it(\"should delegate to another method\", function() {\n        var model;\n        model = Model({\n          position: {\n            x: 1,\n            y: 2,\n            z: 3\n          }\n        });\n        model.attrReader(\"position\");\n        model.delegate(\"x\", \"y\", \"z\", {\n          to: \"position\"\n        });\n        assert.equal(model.x, 1);\n        assert.equal(model.y, 2);\n        assert.equal(model.z, 3);\n        model.x = 5;\n        assert.equal(model.position().x, 5);\n        return assert.equal(model.I.position.x, 5);\n      });\n      it(\"should delegate to another property\", function() {\n        var model;\n        model = Model({\n          position: {\n            x: 1,\n            y: 2,\n            z: 3\n          }\n        });\n        model.position = model.I.position;\n        model.delegate(\"x\", \"y\", \"z\", {\n          to: \"position\"\n        });\n        assert.equal(model.x, 1);\n        assert.equal(model.y, 2);\n        assert.equal(model.z, 3);\n        model.x = 5;\n        assert.equal(model.position.x, 5);\n        return assert.equal(model.I.position.x, 5);\n      });\n      return it(\"should delegate to methods just fine\", function() {\n        var model;\n        model = Model({\n          size: {\n            width: 10,\n            height: 20\n          }\n        });\n        model.attrData(\"size\", function(_arg) {\n          var height, width;\n          width = _arg.width, height = _arg.height;\n          return {\n            width: function() {\n              return width;\n            },\n            height: function() {\n              return height;\n            }\n          };\n        });\n        model.delegate(\"width\", \"height\", {\n          to: \"size\"\n        });\n        assert.equal(model.width(), 10);\n        return assert.equal(model.height(), 20);\n      });\n    });\n    describe(\"#toJSON\", function() {\n      return it(\"should return an object appropriate for JSON serialization\", function() {\n        var model;\n        model = Model({\n          test: true\n        });\n        return assert(model.toJSON().test);\n      });\n    });\n    describe(\"#observeAll\", function() {\n      it(\"should observe all attributes of a simple model\");\n      (function() {\n        var model;\n        model = Model({\n          test: true,\n          yolo: \"4life\"\n        });\n        model.observeAll();\n        assert(model.test());\n        return assert.equal(model.yolo(), \"4life\");\n      });\n      return it(\"should camel case underscored names\");\n    });\n    describe(\".defaults\", function() {\n      return it(\"should expose defaults method\", function() {\n        return assert(Model.defaults);\n      });\n    });\n    return describe(\".extend\", function() {\n      return it(\"should expose extend method\", function() {\n        return assert(Model.extend);\n      });\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "util": {
          "path": "util",
          "content": "(function() {\n  var __slice = [].slice;\n\n  module.exports = {\n    defaults: function() {\n      var name, object, objects, target, _i, _len;\n      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      for (_i = 0, _len = objects.length; _i < _len; _i++) {\n        object = objects[_i];\n        for (name in object) {\n          if (!target.hasOwnProperty(name)) {\n            target[name] = object[name];\n          }\n        }\n      }\n      return target;\n    },\n    extend: Object.assign\n  };\n\n}).call(this);\n",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "config": {
        "version": "0.2.0-pre.4",
        "dependencies": {
          "observable": "distri/observable:v0.3.8"
        }
      },
      "version": "0.2.0-pre.4",
      "entryPoint": "main",
      "repository": {
        "branch": "master",
        "default_branch": "master",
        "full_name": "distri/model",
        "homepage": null,
        "description": null,
        "html_url": "https://github.com/distri/model",
        "url": "https://api.github.com/repos/distri/model",
        "publishBranch": "gh-pages"
      },
      "dependencies": {
        "observable": {
          "source": {
            "LICENSE": {
              "path": "LICENSE",
              "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
              "mode": "100644",
              "type": "blob"
            },
            "README.md": {
              "path": "README.md",
              "content": "[![Build Status](https://travis-ci.org/distri/observable.svg?branch=npm)](https://travis-ci.org/distri/observable)\n\nObservable\n==========\n\nInstallation\n------------\n\nNode\n\n    npm install o_0\n\nUsage\n-----\n\n    Observable = require \"o_0\"\n\nGet notified when the value changes.\n\n    observable = Observable 5\n\n    observable() # 5\n\n    observable.observe (newValue) ->\n      console.log newValue\n\n    observable 10 # logs 10 to console\n\nArrays\n------\n\nProxy array methods.\n\n    observable = Observable [1, 2, 3]\n\n    observable.forEach (value) ->\n      # 1, 2, 3\n\nFunctions\n---------\n\nAutomagically compute dependencies for observable functions.\n\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n    lastName \"Bro\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "main.coffee.md": {
              "path": "main.coffee.md",
              "content": "Observable\n==========\n\n`Observable` allows for observing arrays, functions, and objects.\n\nFunction dependencies are automagically observed.\n\nStandard array methods are proxied through to the underlying array.\n\n    module.exports = Observable = (value, context) ->\n\nReturn the object if it is already an observable object.\n\n      return value if typeof value?.observe is \"function\"\n\nMaintain a set of listeners to observe changes and provide a helper to notify each observer.\n\n      listeners = []\n\n      notify = (newValue) ->\n        copy(listeners).forEach (listener) ->\n          listener(newValue)\n\nOur observable function is stored as a reference to `self`.\n\nIf `value` is a function compute dependencies and listen to observables that it depends on.\n\n      if typeof value is 'function'\n        fn = value\n\nOur return function is a function that holds only a cached value which is updated\nwhen it's dependencies change.\n\nThe `magicDependency` call is so other functions can depend on this computed function the\nsame way we depend on other types of observables.\n\n        self = ->\n          # Automagic dependency observation\n          magicDependency(self)\n\n          return value\n\n        changed = ->\n          value = computeDependencies(self, fn, changed, context)\n          notify(value)\n\n        changed()\n\n      else\n\nWhen called with zero arguments it is treated as a getter. When called with one argument it is treated as a setter.\n\nChanges to the value will trigger notifications.\n\nThe value is always returned.\n\n        self = (newValue) ->\n          if arguments.length > 0\n            if value != newValue\n              value = newValue\n\n              notify(newValue)\n          else\n            # Automagic dependency observation\n            magicDependency(self)\n\n          return value\n\nThis `each` iterator is similar to [the Maybe monad](http://en.wikipedia.org/wiki/Monad_&#40;functional_programming&#41;#The_Maybe_monad) in that our observable may contain a single value or nothing at all.\n\n      self.each = (callback) ->\n        magicDependency(self)\n\n        if value?\n          [value].forEach (item) ->\n            callback.call(item, item)\n\n        return self\n\nIf the value is an array then proxy array methods and add notifications to mutation events.\n\n      if Array.isArray(value)\n        [\n          \"concat\"\n          \"every\"\n          \"filter\"\n          \"forEach\"\n          \"indexOf\"\n          \"join\"\n          \"lastIndexOf\"\n          \"map\"\n          \"reduce\"\n          \"reduceRight\"\n          \"slice\"\n          \"some\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            magicDependency(self)\n            value[method](args...)\n\n        [\n          \"pop\"\n          \"push\"\n          \"reverse\"\n          \"shift\"\n          \"splice\"\n          \"sort\"\n          \"unshift\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            notifyReturning value[method](args...)\n\n        # Provide length on a best effort basis because older browsers choke\n        if PROXY_LENGTH\n          Object.defineProperty self, 'length',\n            get: ->\n              magicDependency(self)\n              value.length\n            set: (length) ->\n              value.length = length\n              notifyReturning(value.length)\n\n        notifyReturning = (returnValue) ->\n          notify(value)\n\n          return returnValue\n\nAdd some extra helpful methods to array observables.\n\n        extend self,\n          each: (callback) ->\n            self.forEach (item, index) ->\n              callback.call(item, item, index, self)\n\n            return self\n\nRemove an element from the array and notify observers of changes.\n\n          remove: (object) ->\n            index = value.indexOf(object)\n\n            if index >= 0\n              notifyReturning value.splice(index, 1)[0]\n\n          get: (index) ->\n            magicDependency(self)\n            value[index]\n\n          first: ->\n            magicDependency(self)\n            value[0]\n\n          last: ->\n            magicDependency(self)\n            value[value.length-1]\n\n          size: ->\n            magicDependency(self)\n            value.length\n\n      extend self,\n        listeners: listeners\n\n        observe: (listener) ->\n          listeners.push listener\n\n        stopObserving: (fn) ->\n          remove listeners, fn\n\n        toggle: ->\n          self !value\n\n        increment: (n) ->\n          self value + n\n\n        decrement: (n) ->\n          self value - n\n\n        toString: ->\n          \"Observable(#{value})\"\n\n      return self\n\n    Observable.concat = ->\n      # Optimization: Manually copy arguments to an array\n      args = new Array(arguments.length)\n      for arg, i in arguments\n        args[i] = arguments[i]\n\n      collection = Observable(args)\n\n      o = Observable ->\n        flatten collection.map(splat)\n\n      o.push = collection.push\n\n      return o\n\nAppendix\n--------\n\nThe extend method adds one object's properties to another.\n\n    extend = (target) ->\n      # Optimization: iterate through arguments manually rather than pass to slice to create an array\n      for source, i in arguments\n        # The first argument is target, so skip it\n        if i > 0\n          for name of source\n            target[name] = source[name]\n\n      return target\n\nSuper hax for computing dependencies. This needs to be a shared global so that\ndifferent bundled versions of observable libraries can interoperate.\n\n    global.OBSERVABLE_ROOT_HACK = []\n\n    magicDependency = (self) ->\n      observerSet = last(global.OBSERVABLE_ROOT_HACK)\n      if observerSet\n        observerSet.add self\n\nOptimization: Keep the function containing the try-catch as small as possible.\n\n    tryCallWithFinallyPop = (fn, context) ->\n      try\n        fn.call(context)\n      finally\n        global.OBSERVABLE_ROOT_HACK.pop()\n\nAutomagically compute dependencies.\n\n    computeDependencies = (self, fn, update, context) ->\n      deps = new Set\n\n      global.OBSERVABLE_ROOT_HACK.push(deps)\n\n      value = tryCallWithFinallyPop fn, context\n\n      self._deps?.forEach (observable) ->\n        observable.stopObserving update\n\n      self._deps = deps\n\n      deps.forEach (observable) ->\n        observable.observe update\n\n      return value\n\nCheck if we can proxy function length property.\n\n    try\n      Object.defineProperty (->), 'length',\n        get: ->\n        set: ->\n\n      PROXY_LENGTH = true\n    catch\n      PROXY_LENGTH = false\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n\n    copy = (array) ->\n      array.concat([])\n\n    get = (arg) ->\n      if typeof arg is \"function\"\n        arg()\n      else\n        arg\n\n    splat = (item) ->\n      results = []\n\n      return results unless item?\n\n      if typeof item.forEach is \"function\"\n        item.forEach (i) ->\n          results.push i\n      else\n        result = get item\n\n        results.push result if result?\n\n      results\n\n    last = (array) ->\n      array[array.length - 1]\n\n    flatten = (array) ->\n      array.reduce (a, b) ->\n        a.concat(b)\n      , []\n",
              "mode": "100644",
              "type": "blob"
            },
            "pixie.cson": {
              "path": "pixie.cson",
              "content": "version: \"0.3.8\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "test/observable.coffee": {
              "path": "test/observable.coffee",
              "content": "global.Observable = require \"../main\"\n\ndescribe 'Observable', ->\n  it 'should create an observable for an object', ->\n    n = 5\n\n    observable = Observable(n)\n\n    assert.equal(observable(), n)\n\n  it 'should fire events when setting', ->\n    string = \"yolo\"\n\n    observable = Observable(string)\n    observable.observe (newValue) ->\n      assert.equal newValue, \"4life\"\n\n    observable(\"4life\")\n\n  it \"should not fire when setting to the same value\", ->\n    o = Observable 5\n\n    o.observe ->\n      assert false\n\n    o(5)\n\n  it 'should be idempotent', ->\n    o = Observable(5)\n\n    assert.equal o, Observable(o)\n\n  describe \"#each\", ->\n    it \"should be invoked once if there is an observable\", ->\n      o = Observable(5)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n        assert.equal value, 5\n\n      assert.equal called, 1\n\n    it \"should not be invoked if observable is null\", ->\n      o = Observable(null)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n\n      assert.equal called, 0\n\n    it \"should have the correct `this` scope for items\", (done) ->\n      o = Observable 5\n\n      o.each ->\n        assert.equal this, 5\n        done()\n\n    it \"should have the correct `this` scope for items in observable arrays\", ->\n      scopes = []\n\n      o = Observable [\"I'm\", \"an\", \"array\"]\n\n      o.each ->\n        scopes.push this\n\n      assert.equal scopes[0], \"I'm\"\n      assert.equal scopes[1], \"an\"\n      assert.equal scopes[2], \"array\"\n\n  it \"should allow for stopping observation\", ->\n    observable = Observable(\"string\")\n\n    called = 0\n    fn = (newValue) ->\n      called += 1\n      assert.equal newValue, \"4life\"\n\n    observable.observe fn\n\n    observable(\"4life\")\n\n    observable.stopObserving fn\n\n    observable(\"wat\")\n\n    assert.equal called, 1\n\n  it \"should increment\", ->\n    observable = Observable 1\n\n    observable.increment(5)\n\n    assert.equal observable(), 6\n\n  it \"should decremnet\", ->\n    observable = Observable 1\n\n    observable.decrement 5\n\n    assert.equal observable(), -4\n\n  it \"should toggle\", ->\n    observable = Observable false\n\n    observable.toggle()\n    assert.equal observable(), true\n\n    observable.toggle()\n    assert.equal observable(), false\n\n  it \"should trigger when toggling\", (done) ->\n    observable = Observable true\n    observable.observe (v) ->\n      assert.equal v, false\n      done()\n\n    observable.toggle()\n\n  it \"should have a nice toString\", ->\n    observable = Observable 5\n\n    assert.equal observable.toString(), \"Observable(5)\"\n\ndescribe \"Observable Array\", ->\n  it \"should proxy array methods\", ->\n    o = Observable [5]\n\n    o.map (n) ->\n      assert.equal n, 5\n\n  it \"should notify on mutation methods\", (done) ->\n    o = Observable []\n\n    o.observe (newValue) ->\n      assert.equal newValue[0], 1\n\n    o.push 1\n\n    done()\n\n  it \"should have an each method\", ->\n    o = Observable []\n\n    assert o.each\n\n  it \"#get\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.get(2), 2\n\n  it \"#first\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.first(), 0\n\n  it \"#last\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.last(), 3\n\n  it \"#remove\", (done) ->\n    o = Observable [0, 1, 2, 3]\n\n    o.observe (newValue) ->\n      assert.equal newValue.length, 3\n      setTimeout ->\n        done()\n      , 0\n\n    assert.equal o.remove(2), 2\n\n  it \"#remove non-existent element\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.remove(0), undefined\n\n  it \"should proxy the length property\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.length, 3\n\n    called = false\n    o.observe (value) ->\n      assert.equal value[0], 1\n      assert.equal value[1], undefined\n      called = true\n\n    o.length = 1\n    assert.equal o.length, 1\n    assert.equal called, true\n\n  it \"should auto detect conditionals of length as a dependency\", ->\n    observableArray = Observable [1, 2, 3]\n\n    o = Observable ->\n      if observableArray.length > 5\n        true\n      else\n        false\n\n    assert.equal o(), false\n\n    called = 0\n    o.observe ->\n      called += 1\n\n    observableArray.push 4, 5, 6\n\n    assert.equal called, 1\n\ndescribe \"Observable functions\", ->\n  it \"should compute dependencies\", (done) ->\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n      done()\n\n    lastName \"Bro\"\n\n  it \"should compute array#get as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.get(0)\n\n    assert.equal observableFn(), 0\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#first as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.first() + 1\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 6\n\n  it \"should compute array#last as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.last()\n\n    assert.equal observableFn(), 2\n\n    observableArray.pop()\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#size as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.size() * 2\n\n    assert.equal observableFn(), 6\n\n    observableArray.pop()\n    assert.equal observableFn(), 4\n    observableArray.shift()\n    assert.equal observableFn(), 2\n\n  it \"should allow double nesting\", (done) ->\n    bottom = Observable \"rad\"\n    middle = Observable ->\n      bottom()\n    top = Observable ->\n      middle()\n\n    top.observe (newValue) ->\n      assert.equal newValue, \"wat\"\n      assert.equal top(), newValue\n      assert.equal middle(), newValue\n\n      done()\n\n    bottom(\"wat\")\n\n  it \"should work with dynamic dependencies\", ->\n    observableArray = Observable []\n\n    dynamicObservable = Observable ->\n      observableArray.filter (item) ->\n        item.age() > 3\n\n    assert.equal dynamicObservable().length, 0\n\n    observableArray.push\n      age: Observable 1\n\n    observableArray()[0].age 5\n    assert.equal dynamicObservable().length, 1\n\n  it \"should work with context\", ->\n    model =\n      a: Observable \"Hello\"\n      b: Observable \"there\"\n\n    model.c = Observable ->\n      \"#{@a()} #{@b()}\"\n    , model\n\n    assert.equal model.c(), \"Hello there\"\n\n    model.b \"world\"\n\n    assert.equal model.c(), \"Hello world\"\n\n  it \"should be ok even if the function throws an exception\", ->\n    assert.throws ->\n      t = Observable ->\n        throw \"wat\"\n\n    # TODO: Should be able to find a test case that is affected by this rather that\n    # checking it directly\n    assert.equal global.OBSERVABLE_ROOT_HACK.length, 0\n\n  it \"should have an each method\", ->\n    o = Observable ->\n\n    assert o.each()\n\n  it \"should not invoke when returning undefined\", ->\n    o = Observable ->\n\n    o.each ->\n      assert false\n\n  it \"should invoke when returning any defined value\", (done) ->\n    o = Observable -> 5\n\n    o.each (n) ->\n      assert.equal n, 5\n      done()\n\n  it \"should work on an array dependency\", ->\n    oA = Observable [1, 2, 3]\n\n    o = Observable ->\n      oA()[0]\n\n    last = Observable ->\n      oA()[oA().length-1]\n\n    assert.equal o(), 1\n\n    oA.unshift 0\n\n    assert.equal o(), 0\n\n    oA.push 4\n\n    assert.equal last(), 4, \"Last should be 4\"\n\n  it \"should work with multiple dependencies\", ->\n    letter = Observable \"A\"\n    checked = ->\n      l = letter()\n      @name().indexOf(l) is 0\n\n    first = {name: Observable(\"Andrew\")}\n    first.checked = Observable checked, first\n\n    second = {name: Observable(\"Benjamin\")}\n    second.checked = Observable checked, second\n\n    assert.equal first.checked(), true\n    assert.equal second.checked(), false\n\n    assert.equal letter.listeners.length, 2\n\n    letter \"B\"\n\n    assert.equal first.checked(), false\n    assert.equal second.checked(), true\n\n  it \"shouldn't double count dependencies\", ->\n    dep = Observable \"yo\"\n\n    o = Observable ->\n      dep()\n      dep()\n      dep()\n\n    count = 0\n    o.observe ->\n      count += 1\n\n    dep('heyy')\n\n    assert.equal count, 1\n\n  it \"should work with nested observable construction\", ->\n    gen = Observable ->\n      Observable \"Duder\"\n\n    o = gen()\n\n    assert.equal o(), \"Duder\"\n\n    o(\"wat\")\n\n    assert.equal o(), \"wat\"\n\n  describe \"Scoping\", ->\n    it \"should be scoped to optional context\", (done) ->\n      model =\n        firstName: Observable \"Duder\"\n        lastName: Observable \"Man\"\n\n      model.name = Observable ->\n        \"#{@firstName()} #{@lastName()}\"\n      , model\n\n      model.name.observe (newValue) ->\n        assert.equal newValue, \"Duder Bro\"\n\n        done()\n\n      model.lastName \"Bro\"\n\n  describe \"concat\", ->\n    it \"should work with a single observable\", ->\n      observable = Observable \"something\"\n      observableArray = Observable.concat observable\n      assert.equal observableArray.last(), \"something\"\n\n      observable \"something else\"\n      assert.equal observableArray.last(), \"something else\"\n\n    it \"should work with an undefined observable\", ->\n      observable = Observable undefined\n      observableArray = Observable.concat observable\n      assert.equal observableArray.size(), 0\n\n      observable \"defined\"\n      assert.equal observableArray.size(), 1\n\n    it \"should work with undefined\", ->\n      observableArray = Observable.concat undefined\n      assert.equal observableArray.size(), 0\n\n    it \"should work with []\", ->\n      observableArray = Observable.concat []\n      assert.equal observableArray.size(), 0\n\n    it \"should return an observable array that changes based on changes in inputs\", ->\n      numbers = Observable [1, 2, 3]\n      letters = Observable [\"a\", \"b\", \"c\"]\n      item = Observable({})\n      nullable = Observable null\n\n      observableArray = Observable.concat numbers, \"literal\", letters, item, nullable\n\n      assert.equal observableArray().length, 3 + 1 + 3 + 1\n\n      assert.equal observableArray()[0], 1\n      assert.equal observableArray()[3], \"literal\"\n      assert.equal observableArray()[4], \"a\"\n      assert.equal observableArray()[7], item()\n\n      numbers.push 4\n\n      assert.equal observableArray().length, 9\n\n      nullable \"cool\"\n\n      assert.equal observableArray().length, 10\n\n    it \"should work with observable functions that return arrays\", ->\n      item = Observable(\"wat\")\n\n      computedArray = Observable ->\n        [item()]\n\n      observableArray = Observable.concat computedArray, computedArray\n\n      assert.equal observableArray().length, 2\n\n      assert.equal observableArray()[1], \"wat\"\n\n      item \"yolo\"\n\n      assert.equal observableArray()[1], \"yolo\"\n\n    it \"should have a push method\", ->\n      observableArray = Observable.concat()\n\n      observable = Observable \"hey\"\n\n      observableArray.push observable\n\n      assert.equal observableArray()[0], \"hey\"\n\n      observable \"wat\"\n\n      assert.equal observableArray()[0], \"wat\"\n\n      observableArray.push \"cool\"\n      observableArray.push \"radical\"\n\n      assert.equal observableArray().length, 3\n\n    it \"should be observable\", (done) ->\n      observableArray = Observable.concat()\n\n      observableArray.observe (items) ->\n        assert.equal items.length, 3\n        done()\n\n      observableArray.push [\"A\", \"B\", \"C\"]\n\n    it \"should have an each method\", ->\n      observableArray = Observable.concat([\"A\", \"B\", \"C\"])\n\n      n = 0\n      observableArray.each () ->\n        n += 1\n\n      assert.equal n, 3\n\n  describe \"nesting dependencies\", ->\n    it \"should update the correct observable\", ->\n      a = Observable \"a\"\n      b = Observable \"b\"\n\n      results = Observable ->\n        r = Observable.concat()\n\n        r.push a\n        r.push b\n\n        r\n\n      # TODO: Should this just be\n      #     results.first()\n      assert.equal results().first(), \"a\"\n\n      a(\"newA\")\n\n      assert.equal results().first(), \"newA\"\n",
              "mode": "100644",
              "type": "blob"
            }
          },
          "distribution": {
            "main": {
              "path": "main",
              "content": "(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n",
              "type": "blob"
            },
            "pixie": {
              "path": "pixie",
              "content": "module.exports = {\"version\":\"0.3.8\"};",
              "type": "blob"
            },
            "test/observable": {
              "path": "test/observable",
              "content": "(function() {\n  global.Observable = require(\"../main\");\n\n  describe('Observable', function() {\n    it('should create an observable for an object', function() {\n      var n, observable;\n      n = 5;\n      observable = Observable(n);\n      return assert.equal(observable(), n);\n    });\n    it('should fire events when setting', function() {\n      var observable, string;\n      string = \"yolo\";\n      observable = Observable(string);\n      observable.observe(function(newValue) {\n        return assert.equal(newValue, \"4life\");\n      });\n      return observable(\"4life\");\n    });\n    it(\"should not fire when setting to the same value\", function() {\n      var o;\n      o = Observable(5);\n      o.observe(function() {\n        return assert(false);\n      });\n      return o(5);\n    });\n    it('should be idempotent', function() {\n      var o;\n      o = Observable(5);\n      return assert.equal(o, Observable(o));\n    });\n    describe(\"#each\", function() {\n      it(\"should be invoked once if there is an observable\", function() {\n        var called, o;\n        o = Observable(5);\n        called = 0;\n        o.each(function(value) {\n          called += 1;\n          return assert.equal(value, 5);\n        });\n        return assert.equal(called, 1);\n      });\n      it(\"should not be invoked if observable is null\", function() {\n        var called, o;\n        o = Observable(null);\n        called = 0;\n        o.each(function(value) {\n          return called += 1;\n        });\n        return assert.equal(called, 0);\n      });\n      it(\"should have the correct `this` scope for items\", function(done) {\n        var o;\n        o = Observable(5);\n        return o.each(function() {\n          assert.equal(this, 5);\n          return done();\n        });\n      });\n      return it(\"should have the correct `this` scope for items in observable arrays\", function() {\n        var o, scopes;\n        scopes = [];\n        o = Observable([\"I'm\", \"an\", \"array\"]);\n        o.each(function() {\n          return scopes.push(this);\n        });\n        assert.equal(scopes[0], \"I'm\");\n        assert.equal(scopes[1], \"an\");\n        return assert.equal(scopes[2], \"array\");\n      });\n    });\n    it(\"should allow for stopping observation\", function() {\n      var called, fn, observable;\n      observable = Observable(\"string\");\n      called = 0;\n      fn = function(newValue) {\n        called += 1;\n        return assert.equal(newValue, \"4life\");\n      };\n      observable.observe(fn);\n      observable(\"4life\");\n      observable.stopObserving(fn);\n      observable(\"wat\");\n      return assert.equal(called, 1);\n    });\n    it(\"should increment\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.increment(5);\n      return assert.equal(observable(), 6);\n    });\n    it(\"should decremnet\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.decrement(5);\n      return assert.equal(observable(), -4);\n    });\n    it(\"should toggle\", function() {\n      var observable;\n      observable = Observable(false);\n      observable.toggle();\n      assert.equal(observable(), true);\n      observable.toggle();\n      return assert.equal(observable(), false);\n    });\n    it(\"should trigger when toggling\", function(done) {\n      var observable;\n      observable = Observable(true);\n      observable.observe(function(v) {\n        assert.equal(v, false);\n        return done();\n      });\n      return observable.toggle();\n    });\n    return it(\"should have a nice toString\", function() {\n      var observable;\n      observable = Observable(5);\n      return assert.equal(observable.toString(), \"Observable(5)\");\n    });\n  });\n\n  describe(\"Observable Array\", function() {\n    it(\"should proxy array methods\", function() {\n      var o;\n      o = Observable([5]);\n      return o.map(function(n) {\n        return assert.equal(n, 5);\n      });\n    });\n    it(\"should notify on mutation methods\", function(done) {\n      var o;\n      o = Observable([]);\n      o.observe(function(newValue) {\n        return assert.equal(newValue[0], 1);\n      });\n      o.push(1);\n      return done();\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable([]);\n      return assert(o.each);\n    });\n    it(\"#get\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.get(2), 2);\n    });\n    it(\"#first\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.first(), 0);\n    });\n    it(\"#last\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.last(), 3);\n    });\n    it(\"#remove\", function(done) {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      o.observe(function(newValue) {\n        assert.equal(newValue.length, 3);\n        return setTimeout(function() {\n          return done();\n        }, 0);\n      });\n      return assert.equal(o.remove(2), 2);\n    });\n    it(\"#remove non-existent element\", function() {\n      var o;\n      o = Observable([1, 2, 3]);\n      return assert.equal(o.remove(0), void 0);\n    });\n    it(\"should proxy the length property\", function() {\n      var called, o;\n      o = Observable([1, 2, 3]);\n      assert.equal(o.length, 3);\n      called = false;\n      o.observe(function(value) {\n        assert.equal(value[0], 1);\n        assert.equal(value[1], void 0);\n        return called = true;\n      });\n      o.length = 1;\n      assert.equal(o.length, 1);\n      return assert.equal(called, true);\n    });\n    return it(\"should auto detect conditionals of length as a dependency\", function() {\n      var called, o, observableArray;\n      observableArray = Observable([1, 2, 3]);\n      o = Observable(function() {\n        if (observableArray.length > 5) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n      assert.equal(o(), false);\n      called = 0;\n      o.observe(function() {\n        return called += 1;\n      });\n      observableArray.push(4, 5, 6);\n      return assert.equal(called, 1);\n    });\n  });\n\n  describe(\"Observable functions\", function() {\n    it(\"should compute dependencies\", function(done) {\n      var firstName, lastName, o;\n      firstName = Observable(\"Duder\");\n      lastName = Observable(\"Man\");\n      o = Observable(function() {\n        return \"\" + (firstName()) + \" \" + (lastName());\n      });\n      o.observe(function(newValue) {\n        assert.equal(newValue, \"Duder Bro\");\n        return done();\n      });\n      return lastName(\"Bro\");\n    });\n    it(\"should compute array#get as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.get(0);\n      });\n      assert.equal(observableFn(), 0);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#first as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.first() + 1;\n      });\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 6);\n    });\n    it(\"should compute array#last as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.last();\n      });\n      assert.equal(observableFn(), 2);\n      observableArray.pop();\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#size as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.size() * 2;\n      });\n      assert.equal(observableFn(), 6);\n      observableArray.pop();\n      assert.equal(observableFn(), 4);\n      observableArray.shift();\n      return assert.equal(observableFn(), 2);\n    });\n    it(\"should allow double nesting\", function(done) {\n      var bottom, middle, top;\n      bottom = Observable(\"rad\");\n      middle = Observable(function() {\n        return bottom();\n      });\n      top = Observable(function() {\n        return middle();\n      });\n      top.observe(function(newValue) {\n        assert.equal(newValue, \"wat\");\n        assert.equal(top(), newValue);\n        assert.equal(middle(), newValue);\n        return done();\n      });\n      return bottom(\"wat\");\n    });\n    it(\"should work with dynamic dependencies\", function() {\n      var dynamicObservable, observableArray;\n      observableArray = Observable([]);\n      dynamicObservable = Observable(function() {\n        return observableArray.filter(function(item) {\n          return item.age() > 3;\n        });\n      });\n      assert.equal(dynamicObservable().length, 0);\n      observableArray.push({\n        age: Observable(1)\n      });\n      observableArray()[0].age(5);\n      return assert.equal(dynamicObservable().length, 1);\n    });\n    it(\"should work with context\", function() {\n      var model;\n      model = {\n        a: Observable(\"Hello\"),\n        b: Observable(\"there\")\n      };\n      model.c = Observable(function() {\n        return \"\" + (this.a()) + \" \" + (this.b());\n      }, model);\n      assert.equal(model.c(), \"Hello there\");\n      model.b(\"world\");\n      return assert.equal(model.c(), \"Hello world\");\n    });\n    it(\"should be ok even if the function throws an exception\", function() {\n      assert.throws(function() {\n        var t;\n        return t = Observable(function() {\n          throw \"wat\";\n        });\n      });\n      return assert.equal(global.OBSERVABLE_ROOT_HACK.length, 0);\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable(function() {});\n      return assert(o.each());\n    });\n    it(\"should not invoke when returning undefined\", function() {\n      var o;\n      o = Observable(function() {});\n      return o.each(function() {\n        return assert(false);\n      });\n    });\n    it(\"should invoke when returning any defined value\", function(done) {\n      var o;\n      o = Observable(function() {\n        return 5;\n      });\n      return o.each(function(n) {\n        assert.equal(n, 5);\n        return done();\n      });\n    });\n    it(\"should work on an array dependency\", function() {\n      var last, o, oA;\n      oA = Observable([1, 2, 3]);\n      o = Observable(function() {\n        return oA()[0];\n      });\n      last = Observable(function() {\n        return oA()[oA().length - 1];\n      });\n      assert.equal(o(), 1);\n      oA.unshift(0);\n      assert.equal(o(), 0);\n      oA.push(4);\n      return assert.equal(last(), 4, \"Last should be 4\");\n    });\n    it(\"should work with multiple dependencies\", function() {\n      var checked, first, letter, second;\n      letter = Observable(\"A\");\n      checked = function() {\n        var l;\n        l = letter();\n        return this.name().indexOf(l) === 0;\n      };\n      first = {\n        name: Observable(\"Andrew\")\n      };\n      first.checked = Observable(checked, first);\n      second = {\n        name: Observable(\"Benjamin\")\n      };\n      second.checked = Observable(checked, second);\n      assert.equal(first.checked(), true);\n      assert.equal(second.checked(), false);\n      assert.equal(letter.listeners.length, 2);\n      letter(\"B\");\n      assert.equal(first.checked(), false);\n      return assert.equal(second.checked(), true);\n    });\n    it(\"shouldn't double count dependencies\", function() {\n      var count, dep, o;\n      dep = Observable(\"yo\");\n      o = Observable(function() {\n        dep();\n        dep();\n        return dep();\n      });\n      count = 0;\n      o.observe(function() {\n        return count += 1;\n      });\n      dep('heyy');\n      return assert.equal(count, 1);\n    });\n    it(\"should work with nested observable construction\", function() {\n      var gen, o;\n      gen = Observable(function() {\n        return Observable(\"Duder\");\n      });\n      o = gen();\n      assert.equal(o(), \"Duder\");\n      o(\"wat\");\n      return assert.equal(o(), \"wat\");\n    });\n    describe(\"Scoping\", function() {\n      return it(\"should be scoped to optional context\", function(done) {\n        var model;\n        model = {\n          firstName: Observable(\"Duder\"),\n          lastName: Observable(\"Man\")\n        };\n        model.name = Observable(function() {\n          return \"\" + (this.firstName()) + \" \" + (this.lastName());\n        }, model);\n        model.name.observe(function(newValue) {\n          assert.equal(newValue, \"Duder Bro\");\n          return done();\n        });\n        return model.lastName(\"Bro\");\n      });\n    });\n    describe(\"concat\", function() {\n      it(\"should work with a single observable\", function() {\n        var observable, observableArray;\n        observable = Observable(\"something\");\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.last(), \"something\");\n        observable(\"something else\");\n        return assert.equal(observableArray.last(), \"something else\");\n      });\n      it(\"should work with an undefined observable\", function() {\n        var observable, observableArray;\n        observable = Observable(void 0);\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.size(), 0);\n        observable(\"defined\");\n        return assert.equal(observableArray.size(), 1);\n      });\n      it(\"should work with undefined\", function() {\n        var observableArray;\n        observableArray = Observable.concat(void 0);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should work with []\", function() {\n        var observableArray;\n        observableArray = Observable.concat([]);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should return an observable array that changes based on changes in inputs\", function() {\n        var item, letters, nullable, numbers, observableArray;\n        numbers = Observable([1, 2, 3]);\n        letters = Observable([\"a\", \"b\", \"c\"]);\n        item = Observable({});\n        nullable = Observable(null);\n        observableArray = Observable.concat(numbers, \"literal\", letters, item, nullable);\n        assert.equal(observableArray().length, 3 + 1 + 3 + 1);\n        assert.equal(observableArray()[0], 1);\n        assert.equal(observableArray()[3], \"literal\");\n        assert.equal(observableArray()[4], \"a\");\n        assert.equal(observableArray()[7], item());\n        numbers.push(4);\n        assert.equal(observableArray().length, 9);\n        nullable(\"cool\");\n        return assert.equal(observableArray().length, 10);\n      });\n      it(\"should work with observable functions that return arrays\", function() {\n        var computedArray, item, observableArray;\n        item = Observable(\"wat\");\n        computedArray = Observable(function() {\n          return [item()];\n        });\n        observableArray = Observable.concat(computedArray, computedArray);\n        assert.equal(observableArray().length, 2);\n        assert.equal(observableArray()[1], \"wat\");\n        item(\"yolo\");\n        return assert.equal(observableArray()[1], \"yolo\");\n      });\n      it(\"should have a push method\", function() {\n        var observable, observableArray;\n        observableArray = Observable.concat();\n        observable = Observable(\"hey\");\n        observableArray.push(observable);\n        assert.equal(observableArray()[0], \"hey\");\n        observable(\"wat\");\n        assert.equal(observableArray()[0], \"wat\");\n        observableArray.push(\"cool\");\n        observableArray.push(\"radical\");\n        return assert.equal(observableArray().length, 3);\n      });\n      it(\"should be observable\", function(done) {\n        var observableArray;\n        observableArray = Observable.concat();\n        observableArray.observe(function(items) {\n          assert.equal(items.length, 3);\n          return done();\n        });\n        return observableArray.push([\"A\", \"B\", \"C\"]);\n      });\n      return it(\"should have an each method\", function() {\n        var n, observableArray;\n        observableArray = Observable.concat([\"A\", \"B\", \"C\"]);\n        n = 0;\n        observableArray.each(function() {\n          return n += 1;\n        });\n        return assert.equal(n, 3);\n      });\n    });\n    return describe(\"nesting dependencies\", function() {\n      return it(\"should update the correct observable\", function() {\n        var a, b, results;\n        a = Observable(\"a\");\n        b = Observable(\"b\");\n        results = Observable(function() {\n          var r;\n          r = Observable.concat();\n          r.push(a);\n          r.push(b);\n          return r;\n        });\n        assert.equal(results().first(), \"a\");\n        a(\"newA\");\n        return assert.equal(results().first(), \"newA\");\n      });\n    });\n  });\n\n}).call(this);\n",
              "type": "blob"
            }
          },
          "progenitor": {
            "url": "https://danielx.net/editor/"
          },
          "config": {
            "version": "0.3.8"
          },
          "version": "0.3.8",
          "entryPoint": "main",
          "repository": {
            "branch": "v0.3.8",
            "default_branch": "master",
            "full_name": "distri/observable",
            "homepage": "http://observable.us",
            "description": null,
            "html_url": "https://github.com/distri/observable",
            "url": "https://api.github.com/repos/distri/observable",
            "publishBranch": "gh-pages"
          },
          "dependencies": {}
        }
      }
    },
    "ui": {
      "source": {
        "LICENSE": {
          "path": "LICENSE",
          "content": "MIT License\n\nCopyright (c) 2016 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
          "mode": "100644",
          "type": "blob"
        },
        "NOTES.md": {
          "path": "NOTES.md",
          "content": "Notes\n=====\n\nWrapping simple promise returning handlers around the modal should make it easy\nto prompt.\n",
          "mode": "100644",
          "type": "blob"
        },
        "README.md": {
          "path": "README.md",
          "content": "UI\n===\n\nArtisanal User Interface\n\nMenus\n-----\n\n- Context Menu\n- Menu Bar\n- Nested submenus\n\nSimple DSL for creating menus and binding to handlers.\n\n```\n{ContextMenu} = require \"ui\"\n\ncontextMenu = ContextMenu()\ndocument.body.appendChild contextMenu.element\n```\n\nModals\n------\n\n- Alert\n- Confirm\n- Prompt\n\nPromise returning prompts, confirms, etc.\n\nActions\n-------\n\nHotkeys, help text, icons, enabled/disabled states.\n\nZ-Indexes\n---------\n\nIs there a sane way to do z-indexes? Right now I'm just listing them.\n\nModal: 1000\nContext Menu: 2000\n",
          "mode": "100644",
          "type": "blob"
        },
        "TODO.md": {
          "path": "TODO.md",
          "content": "TODO\n====\n\nModals\n  ✔️Alert\n  ✔️Prompt\n  ✔Confirm\n  ✔General\n\nMenus\n  ✔️Menu Bar\n  ✔️Context Menu\n  ✔️Keyboard Navigation (Up, Down, Left, Right)\n  ✔️Accelerator Keys\n  ✔️Display Hotkeys\n  ✔️Indicate Enabled/Disabled\n  ✔️Nested Submenus\n\nToaster/Popup Notifications\n  Animations\n  Native notifications?\n\nGlobal Hotkeys\n\nLoader / Progress\n\nDocumentation\n  Modals\n  Menus\n  Context Menus\n  Hotkeys\n  Windows\n\nExamples\n  Modal Progress Bar\n\nWindows\n  ✔Draggable\n  ✔Resizable (Need to add invisible overlay when moving the mouse so iframes don't jank up the resize)\n  ✔Close\n  Maximize\n  ✔Z-Index\n  Option Menu\n\nTOMAYBE\n=======\n\nTile Windows\n\nForms\n\nTables/Grids\n\nLists\n\nFile Trees\n",
          "mode": "100644",
          "type": "blob"
        },
        "action.coffee": {
          "path": "action.coffee",
          "content": "###\nAction\n======\n\nActions have a function to call, a hotkey, and a function that determines\nwhether or not they are disabled. This is so we can present them in the UI for\nmenus.\n\nThe hotkey is for display purposes only and needs to be listened to by a\nseparate mechanism to perform. [TODO] The action can be executed like a regular\nfunction (instead of needing to use call).\n\nActions may have icons and help text as well.\n\n###\n\nObservable = require \"observable\"\n\n# TODO: This is just a test for toggling disabled state\nmodule.exports = (fn, hotkey) ->\n  disabled = Observable false\n  setInterval ->\n    disabled.toggle()\n  , 1000\n\n  disabled: disabled\n  hotkey: ->\n    hotkey\n  call: (args...) ->\n    fn.call(args...)\n",
          "mode": "100644",
          "type": "blob"
        },
        "demo.coffee": {
          "path": "demo.coffee",
          "content": "{ContextMenu, MenuBar, Modal, Observable, Util:{parseMenu}, Progress, Style, Table, Window} = require \"./export\"\n\n{o} = require \"./util\"\n\nnotepadMenuText = require \"./samples/notepad-menu\"\nnotepadMenuParsed = parseMenu notepadMenuText\n\nFormSampleTemplate = require \"./samples/test-form\"\n\nstyle = document.createElement \"style\"\nstyle.innerHTML = Style.all\ndocument.head.appendChild style\n\nsampleMenuParsed = parseMenu \"\"\"\n  [M]odal\n    [A]lert\n    [C]onfirm\n    [P]rompt\n    [F]orm\n    P[r]ogress\n  [T]est Nesting\n    Test[1]\n      Hello\n      Wat\n    Test[2]\n      [N]ested\n      [R]ad\n        So Rad\n        Hella\n          Hecka\n            Super Hecka\n              Wicked\n  [W]indow\n    New [I]mage -> newImage\n    New [P]ixel -> newPixel\n    New [T]ext -> newText\n    New [S]preadsheet -> newSheet\n\"\"\"\n{element} = MenuBar\n  items: sampleMenuParsed,\n  handlers:\n    alert: ->\n      Modal.alert \"yolo\"\n    prompt: ->\n      Modal.prompt \"Pretty cool, eh?\", \"Yeah!\"\n      .then console.log\n    confirm: ->\n      Modal.confirm \"Jawsome!\"\n      .then console.log\n    form: ->\n      Modal.form FormSampleTemplate()\n      .then console.log\n    progress: ->\n      initialMessage = \"Reticulating splines\"\n      progressView = Progress\n        value: 0\n        max: 2\n        message: initialMessage\n\n      Modal.show progressView.element,\n        cancellable: false\n\n      intervalId = setInterval ->\n        newValue = progressView.value() + 1/60\n        ellipsesCount = Math.floor(newValue * 4) % 4\n        ellipses = [0...ellipsesCount].map ->\n          \".\"\n        .join(\"\")\n        progressView.value(newValue)\n        progressView.message(initialMessage + ellipses)\n        if newValue > 2\n          clearInterval intervalId\n          Modal.hide()\n      , 15\n    newImage: ->\n      img = document.createElement \"img\"\n      img.src = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/data/pI1mvEvxcXJk4mNHNUW-kZsNJsrPDXcAtgguyYETRXQ\"\n\n      addWindow\n        title: \"Yoo\"\n        content: img\n\n    newPixel: ->\n      frame = document.createElement \"iframe\"\n      frame.src = \"https://danielx.net/pixel-editor/embedded/\"\n\n      addWindow\n        title: \"Pixel\"\n        content: frame\n\n    newText: ->\n      textarea = document.createElement \"textarea\"\n\n      addWindow\n        title: \"Notepad.exe\"\n        content: textarea\n\n    newSheet: ->\n      data = [0...5].map (i) ->\n        id: i\n        name: \"yolo\"\n        color: \"#FF0000\"\n\n      InputTemplate = require \"./templates/input\"\n      RowElement = (datum) ->\n        tr = document.createElement \"tr\"\n        types = [\n          \"number\"\n          \"text\"\n          \"color\"\n        ]\n\n        Object.keys(datum).forEach (key, i) ->\n          td = document.createElement \"td\"\n          td.appendChild InputTemplate\n            value: o datum, key\n            type: types[i]\n\n          tr.appendChild td\n\n        return tr\n\n      {element} = tableView = Table {\n        data\n        RowElement\n      }\n\n      menuBar = MenuBar\n        items: parseMenu \"\"\"\n          Insert\n            Row -> insertRow\n          Help\n            About\n        \"\"\"\n        handlers:\n          about: ->\n            Modal.alert \"Spreadsheet v0.0.1 by Daniel X Moore\"\n          insertRow: ->\n            data.push\n              id: 50\n              name: \"new\"\n              color: \"#FF00FF\"\n\n            tableView.render()\n\n      addWindow\n        title: \"Spreadsheet [DEMO VERSION]\"\n        content: element\n        menuBar: menuBar.element\n\ndocument.body.appendChild element\n\ndesktop = document.createElement \"desktop\"\ndocument.body.appendChild desktop\n\ncontextMenu = ContextMenu\n  items: sampleMenuParsed[1][1]\n  handlers: {}\n\ndesktop.addEventListener \"contextmenu\", (e) ->\n  if e.target is desktop\n    e.preventDefault()\n\n    contextMenu.display\n      inElement: document.body\n      x: e.pageX\n      y: e.pageY\n\naddWindow = ({title, menuBar, content}) ->\n  menuBar ?= MenuBar(items: notepadMenuParsed, handlers: {}).element\n  title ?= \"Hello\"\n\n  windowView = Window\n    title: title\n    menuBar: menuBar\n    content: content\n\n  desktop.appendChild windowView.element\n\n  return windowView\n",
          "mode": "100644",
          "type": "blob"
        },
        "export.coffee": {
          "path": "export.coffee",
          "content": "Action = require \"./action\"\nContextMenuView = require \"./views/context-menu\"\nModal = require \"./modal\"\nMenuView = require \"./views/menu\"\nMenuBarView = require \"./views/menu-bar\"\nMenuItemView = require \"./views/menu-item\"\nObservable = require \"observable\"\nProgressView = require \"./views/progress\"\nStyle = require \"./style\"\nTableView = require \"./views/table\"\nWindowView = require \"./views/window\"\n\nmodule.exports = {\n  Action: Action\n  Bindable: require \"bindable\"\n  ContextMenu: ContextMenuView\n  Modal\n  Menu: MenuView\n  MenuBar: MenuBarView\n  MenuItem: MenuItemView\n  Observable: Observable\n  Progress: ProgressView\n  Style\n  Table: TableView\n  Util:\n    parseMenu: require \"./lib/indent-parse\"\n  Window: WindowView\n}\n",
          "mode": "100644",
          "type": "blob"
        },
        "hotkeys.coffee": {
          "path": "hotkeys.coffee",
          "content": "###\nHotkeys\n=======\n\nBind hotkeys\n\n    Hotkey = require \"hotkey\"\n\n    Hotkey \"ctrl+r\", ->\n      alert \"radical!\"\n\nWe'd like to be able to generate a list of hotkeys with descriptions.\n\nQuestions\n---------\n\nShould we just use Mousetrap?\n\nMaybe, but it may have different semantics with preventDefault/defaultPrevented.\n\nShould we allow binding to specific elements?\n\nImagine a windowing OS where non-iframe apps are inside draggable windows. We'd\nlike to have each 'app' able to have its own hotkeys and at the same time have\nglobal OS level hotkeys.\n\nShould `defaultPrevented` prevent executing the hotkey action? Yes\n\nShould executing a hotkey preventDefault? Yes\n\n###\n\n# TODO: This is just a rough outline\nmodule.exports = (element) ->\n  handlers = {}\n\n  handle = (event) ->\n    {key} = event\n\n    modifiersActive = [\"alt\", \"ctrl\", \"meta\", \"shift\"].filter (modifier) ->\n      event[\"#{modifier}Key\"]\n\n    combo = modifiersActive.concat(key).join(\"+\")\n\n    # TODO: Don't trigger \"plain\" events in input/text fields\n\n    handlers[combo]?(e)\n",
          "mode": "100644",
          "type": "blob"
        },
        "lib/assert.coffee": {
          "path": "lib/assert.coffee",
          "content": "module.exports = (condition, message) ->\n  throw new Error message unless condition\n",
          "mode": "100644",
          "type": "blob"
        },
        "lib/indent-parse.coffee": {
          "path": "lib/indent-parse.coffee",
          "content": "top = (stack) ->\n  stack[stack.length - 1]\n\nparse = (source) ->\n  stack = [[]]\n  indentation = /^(  )*/\n  depth = 0\n\n  source.split(\"\\n\").forEach (line, lineNumber) ->\n    match = line.match(indentation)[0]\n    text = line.replace(match, \"\")\n    newDepth = match.length / 2\n\n    return unless text.trim().length\n    current = text\n\n    if newDepth > depth\n      unless newDepth is depth + 1\n        throw new Error \"Unexpected indentation on line #{lineNumber}\"\n      # We're one level further in\n      # Convert the simple string to a [label, items] pair\n      items = []\n      prev = top(stack)\n      prev.push [prev.pop(), items]\n      stack.push items\n    else if newDepth < depth\n      # Pop stack to correct depth\n      stack = stack.slice(0, newDepth + 1)\n\n    depth = newDepth\n\n    top(stack).push current\n\n  return stack[0]\n\nmodule.exports = parse\n",
          "mode": "100644",
          "type": "blob"
        },
        "main.coffee": {
          "path": "main.coffee",
          "content": "if PACKAGE.name is \"ROOT\"\n  require \"./demo\"\nelse\n  module.exports = require \"./export\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "modal.coffee": {
          "path": "modal.coffee",
          "content": "###\nModal\n\nDisplay modal alerts or dialogs.\n\nModal has promise returning equivalents of the native browser:\n\n- Alert\n- Confirm\n- Prompt\n\nThese accept the same arguments and return a promise fulfilled with\nthe same return value as the native methods.\n\nYou can display any element in the modal:\n\n    modal.show myElement\n\n###\n\n{formDataToObject, handle, empty} = require \"./util\"\n\nPromptTemplate = require \"./templates/modal/prompt\"\nModalTemplate = require \"./templates/modal\"\n\nmodal = ModalTemplate()\n\ncancellable = true\nmodal.onclick = (e) ->\n  if e.target is modal and cancellable\n    Modal.hide()\n\ndocument.addEventListener \"keydown\", (e) ->\n  unless e.defaultPrevented\n    if e.key is \"Escape\" and cancellable\n      e.preventDefault()\n      Modal.hide()\n\ndocument.body.appendChild modal\n\ncloseHandler = null\n\nprompt = (params) ->\n  new Promise (resolve) ->\n    element = PromptTemplate params\n\n    Modal.show element,\n      cancellable: false\n      closeHandler: resolve\n    element.querySelector(params.focus)?.focus()\n\nmodule.exports = Modal =\n  show: (element, options) ->\n    if typeof options is \"function\"\n      closeHandler = options\n    else\n      closeHandler = options?.closeHandler\n      if options?.cancellable?\n        cancellable = options.cancellable\n\n    empty(modal).appendChild(element)\n    modal.classList.add \"active\"\n\n  hide: (dataForHandler) ->\n    closeHandler?(dataForHandler)\n    modal.classList.remove \"active\"\n    cancellable = true\n    empty(modal)\n\n  alert: (message) ->\n    prompt\n      title: \"Alert\"\n      message: message\n      focus: \"button\"\n      confirm: handle ->\n        Modal.hide()\n\n  prompt: (message, defaultValue=\"\") ->\n    prompt\n      title: \"Prompt\"\n      message: message\n      focus: \"input\"\n      defaultValue: defaultValue\n      cancel: handle ->\n        Modal.hide(null)\n      confirm: handle ->\n        Modal.hide modal.querySelector(\"input\").value\n\n  confirm: (message) ->\n    prompt\n      title: \"Confirm\"\n      message: message\n      focus: \"button\"\n      cancel: handle ->\n        Modal.hide(false)\n      confirm: handle ->\n        Modal.hide(true)\n\n  form: (formElement) ->\n    new Promise (resolve) ->\n      submitHandler = handle (e) ->\n        formData = new FormData(formElement)\n        result = formDataToObject(formData)\n        Modal.hide(result)\n\n      formElement.addEventListener \"submit\", submitHandler\n\n      Modal.show formElement, (result) ->\n        formElement.removeEventListener \"submit\", submitHandler\n        resolve(result)\n",
          "mode": "100644",
          "type": "blob"
        },
        "pixie.cson": {
          "path": "pixie.cson",
          "content": "version: \"0.1.2\"\nentryPoint: \"main\"\nremoteDependencies: [\n]\ndependencies:\n  observable: \"distri/observable:master\"\n  bindable: \"distri/bindable:master\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "samples/notepad-menu.coffee": {
          "path": "samples/notepad-menu.coffee",
          "content": "module.exports = \"\"\"\n  [F]ile\n    [N]ew\n    [O]pen\n    [S]ave\n    Save [A]s\n    -\n    Page Set[u]p\n    [P]rint\n    -\n    E[x]it\n  [E]dit\n    [U]ndo\n    Redo\n    -\n    Cu[t]\n    [C]opy\n    [P]aste\n    De[l]ete\n    -\n    [F]ind\n    Find [N]ext\n    [R]eplace\n    [G]o To\n    -\n    Select [A]ll\n    Time/[D]ate\n  F[o]rmat\n    [W]ord Wrap\n    [F]ont...\n  [V]iew\n    [S]tatus Bar\n  [H]elp\n    View [H]elp\n    -\n    [A]bout Notepad\n\"\"\"\n",
          "mode": "100644",
          "type": "blob"
        },
        "samples/test-form.jadelet": {
          "path": "samples/test-form.jadelet",
          "content": "form\n  h1 Cool Form Bro\n  p\n    a(href=\"https://yolo.biz\") Yolo\n  input(name=\"yolo\")\n  input(name=\"x\" value=\"Lorem\")\n  input(name=\"y\" value=\"florem\")\n  input(name=\"z\" type=\"number\" value=5)\n  input(name=\"file\" type=\"file\")\n  textarea(name=\"text\")\n  button Submit\n",
          "mode": "100644",
          "type": "blob"
        },
        "style.coffee": {
          "path": "style.coffee",
          "content": "styles = {}\n\nall = \"\"\"\n  main\n  loader\n  menu\n  modal\n  table\n  window\n\"\"\".split(\"\\n\").map (stylePath) ->\n  content = require \"./style/#{stylePath}\"\n  styles[stylePath] = content\n\n  return content\n.join(\"\\n\")\n\nstyles.all = all\n\nmodule.exports = styles\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/loader.styl": {
          "path": "style/loader.styl",
          "content": "// Loader\nloader\n  display: block\n  padding: 1em\n\n  > p:empty\n    margin: 0\n\n  > progress\n    display: block\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/main.styl": {
          "path": "style/main.styl",
          "content": "*\n  box-sizing: border-box\n\nbody\n  display: flex\n  flex-direction: column\n  font-family: Sans-Serif\n  font-size: 14px\n  line-height: 18px\n  margin: 0\n\nbody, html\n  height: 100%\n\ninput, textarea, keygen, select, button\n  font-size: inherit\n  font-family: inherit\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/menu.styl": {
          "path": "style/menu.styl",
          "content": "// Menus\nno-select()\n  user-select: none\n  -moz-user-select: none\n  -webkit-user-select: none\n  -ms-user-select: none\n\nmenu\n  no-select()\n\n  background-color: lightgrey\n  border-bottom: 1px solid rgba(0, 0, 0, 0.5)\n  margin: 0\n  z-index: 1\n\n  &:focus\n    outline: none\n\nmenu.context\n  z-index: 2000\n\nmenu-item\n  display: block\n  list-style-type: none\n\n  &.active\n    background-color: #000080\n    color: white\n\n  > label\n    display: flex\n    padding: 0 0.25em\n    white-space: nowrap\n\n    > *\n      flex: 1 1 auto\n\n    > span.hotkey\n      margin-left: 1em\n\n      &:empty\n        margin-left: 0\n\n    > .decoration\n      flex: 0 1 auto\n      line-height: 1em\n      text-align: right\n      margin-left: 0.5em\n\n      &:empty\n        margin-left: 0\n\n  &[disabled]\n    color: gray\n\n    &.active\n      background-color: rgba(0, 0, 0, 0.125)\n\nmenu.options\n  border-top: 1px solid rgba(255, 255, 255, 0.5)\n  border-left: 1px solid rgba(255, 255, 255, 0.5)\n  border-right: 1px solid rgba(0, 0, 0, 0.5)\n\n  box-shadow: 2px 2px 1px rgba(0, 0, 0, 0.5)\n\n  display: none\n\n  padding: 2px\n  padding-bottom: 3px\n  position: absolute\n\n  &.active\n    display: block\n\n  // Submenu\n  > menu-item.menu\n    position: relative\n\n    > menu\n      position: absolute\n      left: 100%\n      top: -3px\n      margin-left: 1px\n\nmenu-item.menu.active\n  > menu\n    background-color: lightgrey\n    color: black\n    display: block\n\nmenu.bar\n  display: block\n  flex: 0 0 auto\n  margin: 0\n  padding: 0\n  position: initial\n  white-space: nowrap\n  overflow: hidden\n\n  > menu-item\n    display: inline-block\n    > label > .decoration\n      display: none\n\n  &.accelerator-active\n    span.accelerator\n      text-decoration: underline\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/modal.styl": {
          "path": "style/modal.styl",
          "content": "#modal\n  align-items: center\n  background-color: rgba(0, 0, 0, 0.25)\n  display: none\n  justify-content: center\n  position: absolute\n  z-index: 1000\n  top: 0\n  width: 100%\n  height: 100%\n\n  &.active\n    display: flex\n\n  > *\n    background-color: white\n    border: 1px solid rgba(0, 0, 0, 0.5)\n    box-shadow: 2px 2px 6px rgb(0, 0, 0, 0.5)\n    max-width: 90%\n    max-height: 90%\n\n  > form\n    display: block\n    padding: 1em\n\n    > h1\n      font-size: 1.5em\n      margin: 0\n\n    > input, textarea\n      display: block\n      margin-bottom: 1em\n      width: 100%\n\n    > button\n      margin-right: 1em\n      &:last-child\n        margin-right: 0\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/table.styl": {
          "path": "style/table.styl",
          "content": "container\n  display: block\n  height: 100%\n  overflow: auto\n  width: 100%\n\ntable\n  border-collapse: collapse\n  width: 100%\n\nth\n  text-align: left\n\nthead\n  border-bottom: 1px solid black\n\ntd > input\n  border: none\n  background-color: transparent\n  width: 100%\n  height: 100%\n  padding: 0\n\ntr:nth-child(even)\n  background-color: #EEE\n",
          "mode": "100644",
          "type": "blob"
        },
        "style/window.styl": {
          "path": "style/window.styl",
          "content": "no-select()\n  user-select: none\n  -moz-user-select: none\n  -webkit-user-select: none\n  -ms-user-select: none\n\ndesktop\n  no-select()\n\n  display: block\n  flex: 1 0 auto\n\nwindow\n  no-select()\n\n  background-color: lightgrey\n  border: 4px double black\n  display: flex\n  flex-direction: column\n  position: absolute\n\n  > header\n    border-bottom: 1px solid black\n    cursor: default\n    display: flex\n    flex: 0 0 auto\n\n    > close, > control\n      color: white\n      display: inline-block\n      flex: 0 0 auto\n      font-family: monospace\n      width: 18px\n      text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px -1px 0px #000, 0px 1px 0px #000, 1px 1px 0px #808080\n      text-align: center\n\n    > title-bar\n      background-color: #000080\n      border-color: black\n      border-style: solid\n      border-width: 0 1px\n      color: white\n      display: inline-block\n      flex: 1 1 auto\n      overflow: hidden\n      padding: 0 2px\n      text-align: center\n      text-overflow: ellipsis\n      white-space: nowrap\n\n  > viewport\n    background-color: white\n    display: flex\n    height: 100%\n    overflow: auto\n    position: relative\n    z-index: 0\n\n    > *\n      margin: auto\n\n    > textarea\n      font-family: monospace\n      height: 100%\n      resize: none\n      width: 100%\n\n    > iframe\n      border: none\n      height: 100%\n      width: 100%\n      position: absolute\n\n  > resize\n    display: block\n    position: absolute\n\n    &.e, &.w\n      cursor: ew-resize\n\n    &.n, &.s\n      cursor: ns-resize\n\n    &.h\n      height: 4px\n      width: 100%\n\n    &.v\n      height: 100%\n      width: 4px\n\n    &.w\n      left: -4px\n    &.e\n      right: -4px\n    &.n\n      top: -4px\n    &.s\n      bottom: -4px\n\n    &.n.w\n      cursor: nw-resize\n\n    &.n.e\n      cursor: ne-resize\n\n    &.s.e\n      cursor: se-resize\n\n    &.s.w\n      cursor: sw-resize\n\n    &.n.v\n      height: 23px\n      border-bottom: 1px solid black\n\n    &.s.v\n      height: 23px\n      border-top: 1px solid black\n\n    &.e.h\n      border-left: 1px solid black\n      width: 23px\n\n    &.w.h\n      border-right: 1px solid black\n      width: 23px\n\nframe-guard\n  display: block\n  height: 100%\n  pointer-events: none\n  position: absolute\n  width: 100%\n  z-index: 100000\n\n  &.active\n    pointer-events: auto\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/input.jadelet": {
          "path": "templates/input.jadelet",
          "content": "input(@value @type)\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/menu-item.jadelet": {
          "path": "templates/menu-item.jadelet",
          "content": "menu-item(@class @click @mousemove @disabled)\n  label\n    = @title\n    span.hotkey= @hotkey\n    span.decoration= @decoration\n  = @content\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/menu-separator.jadelet": {
          "path": "templates/menu-separator.jadelet",
          "content": "menu-item\n  hr\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/menu.jadelet": {
          "path": "templates/menu.jadelet",
          "content": "menu(@class @click @style)= @items\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/modal.jadelet": {
          "path": "templates/modal.jadelet",
          "content": "#modal\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/modal/prompt.jadelet": {
          "path": "templates/modal/prompt.jadelet",
          "content": "form(submit=@confirm tabindex=-1)\n  h1= @title\n  p= @message\n  - if @defaultValue?\n    input(type=\"text\" value=@defaultValue)\n  button OK\n  - if @cancel\n    button(click=@cancel) Cancel\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/progress.jadelet": {
          "path": "templates/progress.jadelet",
          "content": "loader\n  p= @message\n  progress(@class @value @max)\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/table.jadelet": {
          "path": "templates/table.jadelet",
          "content": "container\n  table(@keydown)\n    thead\n      tr\n        - @headers.forEach (header) ->\n          th= header\n    tbody\n",
          "mode": "100644",
          "type": "blob"
        },
        "templates/window.jadelet": {
          "path": "templates/window.jadelet",
          "content": "window\n  resize.n.h\n  resize.e.v\n  resize.s.h\n  resize.w.v\n  resize.n.e.h\n  resize.n.e.v\n  resize.n.w.h\n  resize.n.w.v\n  resize.s.e.h\n  resize.s.e.v\n  resize.s.w.h\n  resize.s.w.v\n  header\n    control -\n    title-bar= @title\n    close(click=@close) X\n  = @menuBar\n  viewport\n    = @content\n\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/menu.coffee": {
          "path": "test/menu.coffee",
          "content": "parse = require \"../lib/indent-parse\"\n\ndescribe \"Menu Parser\", ->\n  it \"should parse menus into lists\", ->\n    data = \"\"\"\n      File\n    \"\"\"\n\n    results = parse(data)\n    assert.deepEqual [\"File\"], results\n\n  it \"should parse empty\", ->\n    data = \"\"\"\n    \"\"\"\n\n    assert.deepEqual [], parse(data)\n\n  it \"should deal with nesting ok\", ->\n    data = \"\"\"\n      File\n        Open\n        Save\n      Edit\n        Copy\n        Paste\n      Help\n    \"\"\"\n\n    results = parse(data)\n    assert.deepEqual [\n      [\"File\", [\"Open\", \"Save\"]]\n      [\"Edit\", [\"Copy\", \"Paste\"]]\n      \"Help\"\n    ], results\n\n  it \"should parse big ol' menus\", ->\n    results = parse \"\"\"\n      File\n        New\n        Open\n        Save\n        Save As\n      Edit\n        Undo\n        Redo\n        -\n        Cut\n        Copy\n        Paste\n        Delete\n        -\n        Find\n        Find Next\n        Replace\n        Go To\n        -\n        Select All\n        Time/Date\n      Format\n        Word Wrap\n        Font...\n      View\n        Status Bar\n      Help\n        View Help\n        -\n        About Notepad\n    \"\"\"\n\n    assert.deepEqual [\n      [\"File\", [\"New\", \"Open\", \"Save\", \"Save As\"]]\n      [\"Edit\", [\"Undo\", \"Redo\", \"-\", \"Cut\", \"Copy\", \"Paste\", \"Delete\", \"-\", \"Find\", \"Find Next\", \"Replace\", \"Go To\", \"-\", \"Select All\", \"Time/Date\"]]\n      [\"Format\", [\"Word Wrap\", \"Font...\"]]\n      [\"View\", [\"Status Bar\"]]\n      [\"Help\", [\"View Help\", \"-\", \"About Notepad\"]]\n    ], results\n\n  it \"should parse hella nested menus\", ->\n    results = parse \"\"\"\n      File\n        Special\n          Nested\n            Super\n              Awesome\n    \"\"\"\n\n    assert.deepEqual [\n      [\"File\", [\n        [\"Special\", [\n          [\"Nested\", [\n            [\"Super\", [\n              \"Awesome\"\n            ]]\n          ]]\n        ]]\n      ]]\n    ], results\n",
          "mode": "100644",
          "type": "blob"
        },
        "test/modal.coffee": {
          "path": "test/modal.coffee",
          "content": "PACKAGE.name = \"test\"\n\n{Modal} = require \"../main\"\n\ndescribe \"Modal\", ->\n  it \"shoud be totally chill\", ->\n    element = document.createElement \"p\"\n\n    called = false\n    handler = (value) ->\n      called = true\n      assert.equal value, \"yolo\"\n\n    Modal.show(element, handler)\n    Modal.hide('yolo')\n\n    assert called\n",
          "mode": "100644",
          "type": "blob"
        },
        "util.coffee": {
          "path": "util.coffee",
          "content": "Observable = require \"observable\"\n\nA = (attr) ->\n  (x) -> x[attr]\n\nF = (methodName) ->\n  (x) -> x[methodName]()\n\n# Observable attribute helper\no = (object, name) ->\n  attribute = Observable(object[name])\n\n  attribute.observe (newValue) ->\n    object[name] = newValue\n\n  return attribute\n\n# Handle events by preventing the default action\nhandle = (fn) ->\n  (e) ->\n    return if e?.defaultPrevented\n    e?.preventDefault()\n    fn.call(this, e)\n\n# I hope I don't hate myself for this later\n# S for Safe invoke, invoke the method of the object, if it exists and is a\n# function, otherwise return the provided default value\nS = (object, method, defaultValue) ->\n  ->\n    if typeof object?[method] is 'function'\n      object[method]()\n    else\n      defaultValue\n\nasElement = A('element')\n\naccelerateItem = (items, key) ->\n  [acceleratedItem] = items.filter (item) ->\n    item.accelerator is key\n\n  if acceleratedItem\n    # TODO: should there be some kind of exec rather than click action?\n    acceleratedItem.click()\n\nisDescendant = (element, ancestor) ->\n  return unless element\n\n  while (parent = element.parentElement)\n    return true if element is ancestor\n    element = parent\n\nadvance = (list, amount) ->\n  [currentItem] = list.filter (item) ->\n    item.active()\n\n  activeItemIndex = list.indexOf(currentItem) + amount\n\n  if activeItemIndex < 0\n    activeItemIndex = list.length - 1\n  else if activeItemIndex >= list.length\n    activeItemIndex = 0\n\n  list[activeItemIndex]\n\n# TODO: Nested objects?\n# TODO: Convert keys ending in [] to array entries?\n# Just keeping it simple and crushing duplicate names\nformDataToObject = (formData) ->\n  Array.from(formData.entries()).reduce (object, [key, value]) ->\n    object[key] = value\n\n    object\n  , {}\n\n# Get the view associated with a dom element\n# This will let us use the dom tree rather than manage a separate tree\n# to dispatch events at the view level\n# the assumption is that a .view property is written to the root element in the\n# view when rendering a view's template element\nelementView = (element) ->\n  return unless element\n  return element.view if element.view\n  elementView element.parentElement\n\n# Remove all children from a dom node\nempty = (node) ->\n  while node.hasChildNodes()\n    node.removeChild(node.lastChild)\n\n  return node\n\nmodule.exports =\n  htmlEscape: (string) ->\n    String(string).replace /[&<>\"'\\/]/g, (s) ->\n      entityMap[s]\n\n  A: A\n  F: F\n  S: S\n  o: o\n\n  advance: advance\n  asElement: asElement\n  accelerateItem: accelerateItem\n  elementView: elementView\n  empty: empty\n  formDataToObject: formDataToObject\n  handle: handle\n  isDescendant: isDescendant\n\nentityMap =\n  \"&\": \"&amp;\"\n  \"<\": \"&lt;\"\n  \">\": \"&gt;\"\n  '\"': '&quot;'\n  \"'\": '&#39;'\n  \"/\": '&#x2F;'\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/context-menu.coffee": {
          "path": "views/context-menu.coffee",
          "content": "###\nContextMenu\n\nDisplay a context menu!\n\nQuestions:\n\nShould we be able to update the options in the menu after creation?\n\n###\n\n\nObservable = require \"observable\"\n\nMenuView = require \"./menu\"\n\n{isDescendant} = require \"../util\"\n\nmodule.exports = ({items, handlers}) ->\n  activeItem = Observable null\n  top = Observable \"\"\n  left = Observable \"\"\n\n  contextRoot =\n    activeItem: activeItem\n    handlers: handlers\n\n  self = MenuView\n    items: items\n    contextRoot: contextRoot\n    classes: -> [\"context\", \"options\"]\n    style: ->\n      \"top: #{top()}px; left: #{left()}px\"\n\n  element = self.element\n  element.view = self\n\n  self.contextRoot = contextRoot\n  self.display = ({inElement, x, y}) ->\n    top(y)\n    left(x)\n\n    # The element must be added to the dom before it can be activated\n    # it must be visible before it can be focused\n    (inElement or document.body).appendChild element\n    activeItem self\n    element.focus()\n\n  # This must be attached to the document body so we can de-activate when\n  # a person presses the mouse outside of our menu\n  # TODO: How should we clean up this global listener?\n  document.addEventListener \"mousedown\", (e) ->\n    unless isDescendant(e.target, element)\n      activeItem null\n\n  element.setAttribute(\"tabindex\", \"-1\")\n  element.addEventListener \"keydown\", (e) ->\n    {key} = e\n\n    switch key\n      when \"ArrowLeft\", \"ArrowUp\", \"ArrowRight\", \"ArrowDown\"\n        e.preventDefault()\n        direction = key.replace(\"Arrow\", \"\")\n\n        currentItem = activeItem()\n\n        if currentItem\n          currentItem.cursor(direction)\n\n      when \"Escape\"\n        activeItem null\n\n  return self\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu-bar.coffee": {
          "path": "views/menu-bar.coffee",
          "content": "# The MenuBar is a list MenuItems arranged in a bar across the top of a page or\n# window.\n\nObservable = require \"observable\"\n\nMenuView = require \"./menu\"\n\n{isDescendant, advance} = require \"../util\"\n\nmodule.exports = ({items, handlers}) ->\n  acceleratorActive = Observable false\n  # Track active menus and item for navigation\n  activeItem = Observable null\n  previouslyFocusedElement = null\n\n  contextRoot =\n    activeItem: activeItem\n    handlers: handlers\n\n  self = MenuView\n    classes: ->\n      [\n        \"bar\"\n        \"accelerator-active\" if acceleratorActive()\n      ]\n    items: items\n    contextRoot: contextRoot\n\n  element = self.element\n\n  # Redefine cursor movement\n  self.cursor = (direction) ->\n    switch direction\n      when \"Right\"\n        self.advance(1)\n      when \"Left\"\n        self.advance(-1)\n\n  # Redefine expand to down and not right on menu items\n  self.items.forEach (item) ->\n    item.horizontal = true\n    item.cursor = (direction) ->\n      console.log \"Item\", direction\n      if direction is \"Down\"\n        item.submenu?.advance(1)\n      else if direction is \"Up\"\n        item.submenu?.advance(-1)\n      else\n        item.parent.cursor direction\n\n  deactivate = ->\n    activeItem null\n    acceleratorActive false\n    # De-activate menu and focus previously focused element\n    previouslyFocusedElement?.focus()\n\n  document.addEventListener \"mousedown\", (e) ->\n    unless isDescendant(e.target, element)\n      acceleratorActive false\n      activeItem null\n\n  document.addEventListener \"keydown\", (e) ->\n    {key} = e\n    switch key\n      when \"Enter\"\n        activeItem()?.click()\n      when \"Alt\"\n        menuIsActive = false\n        if acceleratorActive() or menuIsActive\n          deactivate()\n        else\n          # Store previously focused element\n          # Get menu ready for accelerating!\n          previouslyFocusedElement = document.activeElement\n          element.focus()\n          activeItem self unless activeItem()\n          acceleratorActive true\n\n  # Dispatch the key to the active menu element\n  accelerateIfActive = (key) ->\n    if acceleratorActive()\n      activeItem()?.accelerate(key)\n\n  # We need to be able to focus the menu to receive keyboard events on it\n  element.setAttribute(\"tabindex\", \"-1\")\n  element.addEventListener \"keydown\", (e) ->\n    {key} = e\n\n    switch key\n      when \"ArrowLeft\", \"ArrowUp\", \"ArrowRight\", \"ArrowDown\"\n        e.preventDefault()\n        direction = key.replace(\"Arrow\", \"\")\n\n        currentItem = activeItem()\n\n        if currentItem\n          currentItem.cursor(direction)\n\n      when \"Escape\"\n        deactivate()\n      else\n        # Only prevent default if we successfully accelerated?\n        accelerated = accelerateIfActive(key.toLowerCase())\n        if accelerated?\n          e.preventDefault()\n\n  return self\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu-item.coffee": {
          "path": "views/menu-item.coffee",
          "content": "{advance, htmlEscape, asElement, F, S, isDescendant, accelerateItem, handle} = require \"../util\"\n\nMenuItemTemplate = require \"../templates/menu-item\"\n\n# MenuItemView\n# An item that appears in menus\nmodule.exports = ({label, MenuView, items, contextRoot, parent}) ->\n  self = {}\n\n  {activeItem, handlers} = contextRoot\n  # TODO: This gets called per menu item when the state changes\n  # Could we shift it a little to only be called for the relevant subtree?\n  active = ->\n    isDescendant activeItem()?.element, element\n\n  self.active = active\n\n  if items\n    submenu = MenuView({\n      items\n      contextRoot\n      parent: self\n    })\n    content = submenu.element\n\n  # Hook in to Action objects so we can display hotkeys\n  # and enabled/disabled statuses.\n  [labelText, actionName] = formatAction label\n  [title, accelerator] = formatLabel labelText\n  action = handlers[actionName]\n  disabled = S(action, \"disabled\", false)\n  hotkey = S(action, \"hotkey\", \"\")\n\n  click = (e) ->\n    return if disabled()\n    return if e?.defaultPrevented\n    e?.preventDefault()\n\n    if submenu\n      activeItem submenu\n      return\n\n    console.log \"Handling\", actionName\n\n    action?.call?(handlers)\n\n    # TODO: More cleanup than just clearing the active item, like also we\n    # should clear accelerator state, and maybe return focus to previously\n    # focused element.\n    # contextRoot.finish?\n    activeItem null\n\n  element = MenuItemTemplate\n    class: ->\n      [\n        \"menu\" if items\n        \"active\" if active()\n      ]\n    click: click\n\n    mousemove: (e) ->\n      # Click to activate top level menus unless a menu is already active\n      # then hover to show.\n      return unless activeItem()\n\n      if !e.defaultPrevented and isDescendant(e.target, element)\n        # Note: We're using preventDefault to prevent handling the\n        # activation above the first element that handles it\n        e.preventDefault()\n\n        activeItem self\n\n    title: title\n    content: content\n    decoration: \"▸\" if items\n    hotkey: hotkey\n    disabled: disabled\n\n  Object.assign self,\n    accelerator: accelerator\n    accelerate: (key) ->\n      if submenu\n        submenu.accelerate key\n      else\n        parent.accelerate key\n    click: click\n    parent: parent\n    element: element\n    submenu: submenu\n    cursor: (direction) ->\n      console.log \"Item Cursor\", direction\n      if submenu and direction is \"Right\"\n        # Select the first navigable item of the submenu\n        activeItem submenu.navigableItems[0]\n      else if parent.parent and direction is \"Left\"\n        # parent is the menu,\n        # parent.parent is the item in the menu containing the parent\n        if parent.parent.horizontal\n          parent.parent.cursor(direction)\n        else\n          activeItem parent.parent\n      else\n        parent.cursor(direction)\n\n  return self\n\n# Parse out custom action symbol from entries like:\n#\n#     [F]ont... -> showFont\n#\n# Falling back to formatting the action title\nformatAction = (labelText) ->\n  [title, action] = labelText.split(\"->\").map F(\"trim\")\n\n  action ?= title.replace(/[^A-Za-z0-9]/g, \"\")\n  action = action.charAt(0).toLowerCase() + action.substring(1)\n\n  return [title, action]\n\nformatLabel = (labelText) ->\n  accelerator = undefined\n  # Parse out accelerator keys for underlining when alt is pressed\n  titleHTML = htmlEscape(labelText).replace /\\[([^\\]]+)\\]/, (match, $1) ->\n    accelerator = $1.toLowerCase()\n    \"<span class=\\\"accelerator\\\">#{$1}</span>\"\n\n  span = document.createElement \"span\"\n  span.innerHTML = titleHTML\n\n  return [span, accelerator]\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu-separator.coffee": {
          "path": "views/menu-separator.coffee",
          "content": "MenuSeparatorTemplate = require \"../templates/menu-separator\"\n\nmodule.exports = ->\n  element: MenuSeparatorTemplate()\n  separator: true\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/menu.coffee": {
          "path": "views/menu.coffee",
          "content": "Observable = require \"observable\"\n\nassert = require \"../lib/assert\"\n\n{advance, accelerateItem, asElement, F, S, htmlEscape, handle, isDescendant} = require \"../util\"\n\nMenuTemplate = require \"../templates/menu\"\nMenuItemTemplate = require \"../templates/menu-item\"\n\nSeparatorView = require \"./menu-separator\"\nMenuItemView = require \"./menu-item\"\n\n# MenuView\n#\n# items is an array of item data\n# An item datum is either a string\n# or a pair of [label:string, items...]\n#\n# ex. [\n#   \"Cool\"\n#   [\"Submenu\", [\n#     \"Yo\",\n#     \"Wat\"\n#   ]]\n# ]\n#\nmodule.exports = MenuView = ({items, classes, style, contextRoot, parent}) ->\n  self = {}\n\n  classes ?= -> [\"options\"]\n\n  {activeItem} = contextRoot\n\n  # Promote item data to MenuItemViews\n  items = items.map (item) ->\n    switch\n      when item is \"-\"\n        SeparatorView()\n      when Array.isArray(item)\n        assert item.length is 2\n        [label, submenuItems] = item\n        MenuItemView\n          label: label\n          items: submenuItems\n          MenuView: MenuView\n          contextRoot: contextRoot\n          parent: self\n      else\n        MenuItemView\n          label: item\n          contextRoot: contextRoot\n          parent: self\n\n  navigableItems = items.filter (item) ->\n    !item.separator\n\n  # TODO: This gets called per menu item when the state changes\n  # Could we shift it a little to only be called for the relevant subtree?\n  # Possible solution: find the common ancestor of the new active and the previous\n  # active and only update the necessary ones\n  active = ->\n    isDescendant activeItem()?.element, self.element\n\n  Object.assign self,\n    accelerate: (key) ->\n      accelerateItem(items, key)\n    cursor: (direction) ->\n      switch direction\n        when \"Up\"\n          self.advance(-1)\n        when \"Down\"\n          self.advance(1)\n        else\n          parent.parent?.cursor(direction)\n    parent: parent\n    items: items\n    advance: (n) ->\n      activeItem advance(navigableItems, n)\n    navigableItems: navigableItems\n    element: MenuTemplate\n      style: style\n      class: ->\n        [\n          \"active\" if active()\n        ].concat classes()\n      click: handle (e) ->\n        activeItem self\n      items: items.map asElement\n\n  return self\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/progress.coffee": {
          "path": "views/progress.coffee",
          "content": "Template = require \"../templates/progress\"\n\nObservable = require \"observable\"\n\nmodule.exports = (params={}) ->\n  {value, max, message} = params\n  value = Observable value or 0\n  max = Observable max\n  message = Observable message\n\n  element = Template\n    value: value\n    max: max\n    message: message\n\n  element: element\n  value: value\n  message: message\n  max: max\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/table.coffee": {
          "path": "views/table.coffee",
          "content": "{empty} = require \"../util\"\n\nTableTemplate = require \"../templates/table\"\n\n# Focus same cell in next row\nadvanceRow = (path, prev) ->\n  [td] = path.filter (element) ->\n    element.tagName is \"TD\"\n  return unless td\n\n  tr = td.parentElement\n  cellIndex = Array::indexOf.call(tr.children, td)\n  if prev\n    nextRowElement = tr.previousSibling\n  else\n    nextRowElement = tr.nextSibling\n\n  if nextRowElement\n    input = nextRowElement.children[cellIndex].querySelector('input')\n    input?.focus()\n\n# The table view takes source data and a constructor that returns a row element\n# for each source datum\n\n# The view will have the ability to filter/sort the data.\n\nTableView = ({data, headers, RowElement}) ->\n  headers ?= Object.keys data[0]\n\n  containerElement = TableTemplate\n    headers: headers\n    keydown: (event) ->\n      {key, path} = event\n      switch key\n        when \"Enter\", \"ArrowDown\"\n          event.preventDefault()\n          advanceRow path\n        when \"ArrowUp\"\n          event.preventDefault()\n          advanceRow path, true\n        # TODO: Left and Right\n        # Left and Right are trickier because you may want to navigate within a text input\n        # ... actually up and down get trickier too if we imagine text areas or\n        # even fancier inputs that may have their own controls...\n\n  tableBody = containerElement.querySelector('tbody')\n\n  filterFn = (datum) ->\n    true\n\n  filterAndSort = (data, filterFn, sortFn) ->\n    filterFn ?= -> true\n    filteredData = data.filter(filterFn)\n\n    if sortFn\n      filteredData.sort(sortFn)\n    else\n      filteredData\n\n  rowElements = ->\n    filterAndSort(data, filterFn, null).map RowElement\n\n  update = ->\n    empty tableBody\n    rowElements().forEach (element) ->\n      tableBody.appendChild element\n\n  update()\n\n  element: containerElement\n  render: update\n\nmodule.exports = TableView\n",
          "mode": "100644",
          "type": "blob"
        },
        "views/window.coffee": {
          "path": "views/window.coffee",
          "content": "WindowTemplate = require \"../templates/window\"\n\n{elementView} = require \"../util\"\n\n# We need an invisible full screen overlay to keep iframes from eating our\n# mousemove events\nframeGuard = document.createElement \"frame-guard\"\ndocument.body.appendChild frameGuard\n\ntopIndex = 0\nraiseToTop = (view) ->\n  return unless typeof view.zIndex is 'function'\n  zIndex = view.zIndex()\n  return if zIndex is topIndex\n  topIndex += 1\n\n  view.zIndex(topIndex)\n\n# Drag Handling\nactiveDrag = null\ndragStart = null\ndocument.addEventListener \"mousedown\", (e) ->\n  {target} = e\n\n  view = elementView target\n  if view\n    # TODO: only raise widows?\n    raiseToTop view\n\n  if target.tagName is \"TITLE-BAR\"\n    frameGuard.classList.add(\"active\")\n    dragStart = e\n    activeDrag = view\n\ndocument.addEventListener \"mousemove\", (e) ->\n  if activeDrag\n    {clientX:prevX, clientY:prevY} = dragStart\n    {clientX:x, clientY:y} = e\n\n    dx = x - prevX\n    dy = y - prevY\n\n    activeDrag.x activeDrag.x() + dx\n    activeDrag.y activeDrag.y() + dy\n\n    dragStart = e\n\n# Resize Handling\nactiveResize = null\nresizeStart = null\nresizeInitial = null\ndocument.addEventListener \"mousedown\", (e) ->\n  {target} = e\n\n  if target.tagName is \"RESIZE\"\n    frameGuard.classList.add(\"active\")\n    resizeStart = e\n    activeResize = target\n    {width, height, x, y} = elementView activeResize\n    resizeInitial =\n      width: width()\n      height: height()\n      x: x()\n      y: y()\n\ndocument.addEventListener \"mousemove\", (e) ->\n  if activeResize\n    {clientX:startX, clientY:startY} = resizeStart\n    {clientX:x, clientY:y} = e\n\n    dx = x - startX\n    dy = y - startY\n\n    width = resizeInitial.width\n    height = resizeInitial.height\n\n    if activeResize.classList.contains(\"e\")\n      width += dx\n\n    if activeResize.classList.contains(\"w\")\n      width -= dx\n\n    if activeResize.classList.contains(\"s\")\n      height += dy\n\n    if activeResize.classList.contains(\"n\")\n      height -= dy\n\n    width = Math.max(width, 200)\n    height = Math.max(height, 50)\n\n    actualDeltaX = width - resizeInitial.width\n    actualDeltaY = height - resizeInitial.height\n\n    view = elementView activeResize\n    if activeResize.classList.contains(\"n\")\n      view.y resizeInitial.y- actualDeltaY\n\n    if activeResize.classList.contains(\"w\")\n      view.x resizeInitial.x- actualDeltaX\n\n    view.width width\n    view.height height\n\n    view.trigger \"resize\"\n\ndocument.addEventListener \"mouseup\", ->\n  activeDrag = null\n  activeResize = null\n  frameGuard.classList.remove(\"active\")\n\nBindable = require \"bindable\"\nObservable = require \"observable\"\n\nmodule.exports = (params) ->\n  self = Bindable()\n\n  x = Observable params.x ? 50\n  y = Observable params.y ? 50\n  width = Observable params.width ? 400\n  height = Observable params.height ? 300\n  title = Observable params.title ? \"Untitled\"\n\n  topIndex += 1\n  zIndex = Observable params.zIndex ? topIndex\n\n  element = WindowTemplate\n    title: title\n    menuBar: params.menuBar\n    content: params.content\n    close: ->\n      self.close()\n\n  styleBind(y, element, \"top\", \"px\")\n  styleBind(x, element, \"left\", \"px\")\n  styleBind(height, element, \"height\", \"px\")\n  styleBind(width, element, \"width\", \"px\")\n  styleBind(zIndex, element, \"zIndex\")\n\n  Object.assign self,\n    element: element\n    title: title\n    x: x\n    y: y\n    width: width\n    height: height\n    zIndex: zIndex\n    close: ->\n      # TODO: Allow prompt to cancel\n      # Maybe we count on people to override this method if they want\n      element.remove()\n\n  element.view = self\n\n  return self\n\nstyleBind = (observable, element, attr, suffix=\"\") ->\n  update = (newValue) ->\n    newValue = parseInt newValue\n\n    if newValue?\n      element.style[attr] = \"#{newValue}#{suffix}\"\n\n  observable.observe update\n\n  update(observable())\n",
          "mode": "100644",
          "type": "blob"
        }
      },
      "distribution": {
        "action": {
          "path": "action",
          "content": "\n/*\nAction\n======\n\nActions have a function to call, a hotkey, and a function that determines\nwhether or not they are disabled. This is so we can present them in the UI for\nmenus.\n\nThe hotkey is for display purposes only and needs to be listened to by a\nseparate mechanism to perform. [TODO] The action can be executed like a regular\nfunction (instead of needing to use call).\n\nActions may have icons and help text as well.\n */\n\n(function() {\n  var Observable,\n    __slice = [].slice;\n\n  Observable = require(\"observable\");\n\n  module.exports = function(fn, hotkey) {\n    var disabled;\n    disabled = Observable(false);\n    setInterval(function() {\n      return disabled.toggle();\n    }, 1000);\n    return {\n      disabled: disabled,\n      hotkey: function() {\n        return hotkey;\n      },\n      call: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return fn.call.apply(fn, args);\n      }\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "demo": {
          "path": "demo",
          "content": "(function() {\n  var ContextMenu, FormSampleTemplate, MenuBar, Modal, Observable, Progress, Style, Table, Window, addWindow, contextMenu, desktop, element, notepadMenuParsed, notepadMenuText, o, parseMenu, sampleMenuParsed, style, _ref, _ref1;\n\n  _ref = require(\"./export\"), ContextMenu = _ref.ContextMenu, MenuBar = _ref.MenuBar, Modal = _ref.Modal, Observable = _ref.Observable, (_ref1 = _ref.Util, parseMenu = _ref1.parseMenu), Progress = _ref.Progress, Style = _ref.Style, Table = _ref.Table, Window = _ref.Window;\n\n  o = require(\"./util\").o;\n\n  notepadMenuText = require(\"./samples/notepad-menu\");\n\n  notepadMenuParsed = parseMenu(notepadMenuText);\n\n  FormSampleTemplate = require(\"./samples/test-form\");\n\n  style = document.createElement(\"style\");\n\n  style.innerHTML = Style.all;\n\n  document.head.appendChild(style);\n\n  sampleMenuParsed = parseMenu(\"[M]odal\\n  [A]lert\\n  [C]onfirm\\n  [P]rompt\\n  [F]orm\\n  P[r]ogress\\n[T]est Nesting\\n  Test[1]\\n    Hello\\n    Wat\\n  Test[2]\\n    [N]ested\\n    [R]ad\\n      So Rad\\n      Hella\\n        Hecka\\n          Super Hecka\\n            Wicked\\n[W]indow\\n  New [I]mage -> newImage\\n  New [P]ixel -> newPixel\\n  New [T]ext -> newText\\n  New [S]preadsheet -> newSheet\");\n\n  element = MenuBar({\n    items: sampleMenuParsed,\n    handlers: {\n      alert: function() {\n        return Modal.alert(\"yolo\");\n      },\n      prompt: function() {\n        return Modal.prompt(\"Pretty cool, eh?\", \"Yeah!\").then(console.log);\n      },\n      confirm: function() {\n        return Modal.confirm(\"Jawsome!\").then(console.log);\n      },\n      form: function() {\n        return Modal.form(FormSampleTemplate()).then(console.log);\n      },\n      progress: function() {\n        var initialMessage, intervalId, progressView;\n        initialMessage = \"Reticulating splines\";\n        progressView = Progress({\n          value: 0,\n          max: 2,\n          message: initialMessage\n        });\n        Modal.show(progressView.element, {\n          cancellable: false\n        });\n        return intervalId = setInterval(function() {\n          var ellipses, ellipsesCount, newValue, _i, _results;\n          newValue = progressView.value() + 1 / 60;\n          ellipsesCount = Math.floor(newValue * 4) % 4;\n          ellipses = (function() {\n            _results = [];\n            for (var _i = 0; 0 <= ellipsesCount ? _i < ellipsesCount : _i > ellipsesCount; 0 <= ellipsesCount ? _i++ : _i--){ _results.push(_i); }\n            return _results;\n          }).apply(this).map(function() {\n            return \".\";\n          }).join(\"\");\n          progressView.value(newValue);\n          progressView.message(initialMessage + ellipses);\n          if (newValue > 2) {\n            clearInterval(intervalId);\n            return Modal.hide();\n          }\n        }, 15);\n      },\n      newImage: function() {\n        var img;\n        img = document.createElement(\"img\");\n        img.src = \"https://s3.amazonaws.com/whimsyspace-databucket-1g3p6d9lcl6x1/danielx/data/pI1mvEvxcXJk4mNHNUW-kZsNJsrPDXcAtgguyYETRXQ\";\n        return addWindow({\n          title: \"Yoo\",\n          content: img\n        });\n      },\n      newPixel: function() {\n        var frame;\n        frame = document.createElement(\"iframe\");\n        frame.src = \"https://danielx.net/pixel-editor/embedded/\";\n        return addWindow({\n          title: \"Pixel\",\n          content: frame\n        });\n      },\n      newText: function() {\n        var textarea;\n        textarea = document.createElement(\"textarea\");\n        return addWindow({\n          title: \"Notepad.exe\",\n          content: textarea\n        });\n      },\n      newSheet: function() {\n        var InputTemplate, RowElement, data, menuBar, tableView;\n        data = [0, 1, 2, 3, 4].map(function(i) {\n          return {\n            id: i,\n            name: \"yolo\",\n            color: \"#FF0000\"\n          };\n        });\n        InputTemplate = require(\"./templates/input\");\n        RowElement = function(datum) {\n          var tr, types;\n          tr = document.createElement(\"tr\");\n          types = [\"number\", \"text\", \"color\"];\n          Object.keys(datum).forEach(function(key, i) {\n            var td;\n            td = document.createElement(\"td\");\n            td.appendChild(InputTemplate({\n              value: o(datum, key),\n              type: types[i]\n            }));\n            return tr.appendChild(td);\n          });\n          return tr;\n        };\n        element = (tableView = Table({\n          data: data,\n          RowElement: RowElement\n        })).element;\n        menuBar = MenuBar({\n          items: parseMenu(\"Insert\\n  Row -> insertRow\\nHelp\\n  About\"),\n          handlers: {\n            about: function() {\n              return Modal.alert(\"Spreadsheet v0.0.1 by Daniel X Moore\");\n            },\n            insertRow: function() {\n              data.push({\n                id: 50,\n                name: \"new\",\n                color: \"#FF00FF\"\n              });\n              return tableView.render();\n            }\n          }\n        });\n        return addWindow({\n          title: \"Spreadsheet [DEMO VERSION]\",\n          content: element,\n          menuBar: menuBar.element\n        });\n      }\n    }\n  }).element;\n\n  document.body.appendChild(element);\n\n  desktop = document.createElement(\"desktop\");\n\n  document.body.appendChild(desktop);\n\n  contextMenu = ContextMenu({\n    items: sampleMenuParsed[1][1],\n    handlers: {}\n  });\n\n  desktop.addEventListener(\"contextmenu\", function(e) {\n    if (e.target === desktop) {\n      e.preventDefault();\n      return contextMenu.display({\n        inElement: document.body,\n        x: e.pageX,\n        y: e.pageY\n      });\n    }\n  });\n\n  addWindow = function(_arg) {\n    var content, menuBar, title, windowView;\n    title = _arg.title, menuBar = _arg.menuBar, content = _arg.content;\n    if (menuBar == null) {\n      menuBar = MenuBar({\n        items: notepadMenuParsed,\n        handlers: {}\n      }).element;\n    }\n    if (title == null) {\n      title = \"Hello\";\n    }\n    windowView = Window({\n      title: title,\n      menuBar: menuBar,\n      content: content\n    });\n    desktop.appendChild(windowView.element);\n    return windowView;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "export": {
          "path": "export",
          "content": "(function() {\n  var Action, ContextMenuView, MenuBarView, MenuItemView, MenuView, Modal, Observable, ProgressView, Style, TableView, WindowView;\n\n  Action = require(\"./action\");\n\n  ContextMenuView = require(\"./views/context-menu\");\n\n  Modal = require(\"./modal\");\n\n  MenuView = require(\"./views/menu\");\n\n  MenuBarView = require(\"./views/menu-bar\");\n\n  MenuItemView = require(\"./views/menu-item\");\n\n  Observable = require(\"observable\");\n\n  ProgressView = require(\"./views/progress\");\n\n  Style = require(\"./style\");\n\n  TableView = require(\"./views/table\");\n\n  WindowView = require(\"./views/window\");\n\n  module.exports = {\n    Action: Action,\n    Bindable: require(\"bindable\"),\n    ContextMenu: ContextMenuView,\n    Modal: Modal,\n    Menu: MenuView,\n    MenuBar: MenuBarView,\n    MenuItem: MenuItemView,\n    Observable: Observable,\n    Progress: ProgressView,\n    Style: Style,\n    Table: TableView,\n    Util: {\n      parseMenu: require(\"./lib/indent-parse\")\n    },\n    Window: WindowView\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "hotkeys": {
          "path": "hotkeys",
          "content": "\n/*\nHotkeys\n=======\n\nBind hotkeys\n\n    Hotkey = require \"hotkey\"\n\n    Hotkey \"ctrl+r\", ->\n      alert \"radical!\"\n\nWe'd like to be able to generate a list of hotkeys with descriptions.\n\nQuestions\n---------\n\nShould we just use Mousetrap?\n\nMaybe, but it may have different semantics with preventDefault/defaultPrevented.\n\nShould we allow binding to specific elements?\n\nImagine a windowing OS where non-iframe apps are inside draggable windows. We'd\nlike to have each 'app' able to have its own hotkeys and at the same time have\nglobal OS level hotkeys.\n\nShould `defaultPrevented` prevent executing the hotkey action? Yes\n\nShould executing a hotkey preventDefault? Yes\n */\n\n(function() {\n  module.exports = function(element) {\n    var handle, handlers;\n    handlers = {};\n    return handle = function(event) {\n      var combo, key, modifiersActive;\n      key = event.key;\n      modifiersActive = [\"alt\", \"ctrl\", \"meta\", \"shift\"].filter(function(modifier) {\n        return event[\"\" + modifier + \"Key\"];\n      });\n      combo = modifiersActive.concat(key).join(\"+\");\n      return typeof handlers[combo] === \"function\" ? handlers[combo](e) : void 0;\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "lib/assert": {
          "path": "lib/assert",
          "content": "(function() {\n  module.exports = function(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "lib/indent-parse": {
          "path": "lib/indent-parse",
          "content": "(function() {\n  var parse, top;\n\n  top = function(stack) {\n    return stack[stack.length - 1];\n  };\n\n  parse = function(source) {\n    var depth, indentation, stack;\n    stack = [[]];\n    indentation = /^(  )*/;\n    depth = 0;\n    source.split(\"\\n\").forEach(function(line, lineNumber) {\n      var current, items, match, newDepth, prev, text;\n      match = line.match(indentation)[0];\n      text = line.replace(match, \"\");\n      newDepth = match.length / 2;\n      if (!text.trim().length) {\n        return;\n      }\n      current = text;\n      if (newDepth > depth) {\n        if (newDepth !== depth + 1) {\n          throw new Error(\"Unexpected indentation on line \" + lineNumber);\n        }\n        items = [];\n        prev = top(stack);\n        prev.push([prev.pop(), items]);\n        stack.push(items);\n      } else if (newDepth < depth) {\n        stack = stack.slice(0, newDepth + 1);\n      }\n      depth = newDepth;\n      return top(stack).push(current);\n    });\n    return stack[0];\n  };\n\n  module.exports = parse;\n\n}).call(this);\n",
          "type": "blob"
        },
        "main": {
          "path": "main",
          "content": "(function() {\n  if (PACKAGE.name === \"ROOT\") {\n    require(\"./demo\");\n  } else {\n    module.exports = require(\"./export\");\n  }\n\n}).call(this);\n",
          "type": "blob"
        },
        "modal": {
          "path": "modal",
          "content": "\n/*\nModal\n\nDisplay modal alerts or dialogs.\n\nModal has promise returning equivalents of the native browser:\n\n- Alert\n- Confirm\n- Prompt\n\nThese accept the same arguments and return a promise fulfilled with\nthe same return value as the native methods.\n\nYou can display any element in the modal:\n\n    modal.show myElement\n */\n\n(function() {\n  var Modal, ModalTemplate, PromptTemplate, cancellable, closeHandler, empty, formDataToObject, handle, modal, prompt, _ref;\n\n  _ref = require(\"./util\"), formDataToObject = _ref.formDataToObject, handle = _ref.handle, empty = _ref.empty;\n\n  PromptTemplate = require(\"./templates/modal/prompt\");\n\n  ModalTemplate = require(\"./templates/modal\");\n\n  modal = ModalTemplate();\n\n  cancellable = true;\n\n  modal.onclick = function(e) {\n    if (e.target === modal && cancellable) {\n      return Modal.hide();\n    }\n  };\n\n  document.addEventListener(\"keydown\", function(e) {\n    if (!e.defaultPrevented) {\n      if (e.key === \"Escape\" && cancellable) {\n        e.preventDefault();\n        return Modal.hide();\n      }\n    }\n  });\n\n  document.body.appendChild(modal);\n\n  closeHandler = null;\n\n  prompt = function(params) {\n    return new Promise(function(resolve) {\n      var element, _ref1;\n      element = PromptTemplate(params);\n      Modal.show(element, {\n        cancellable: false,\n        closeHandler: resolve\n      });\n      return (_ref1 = element.querySelector(params.focus)) != null ? _ref1.focus() : void 0;\n    });\n  };\n\n  module.exports = Modal = {\n    show: function(element, options) {\n      if (typeof options === \"function\") {\n        closeHandler = options;\n      } else {\n        closeHandler = options != null ? options.closeHandler : void 0;\n        if ((options != null ? options.cancellable : void 0) != null) {\n          cancellable = options.cancellable;\n        }\n      }\n      empty(modal).appendChild(element);\n      return modal.classList.add(\"active\");\n    },\n    hide: function(dataForHandler) {\n      if (typeof closeHandler === \"function\") {\n        closeHandler(dataForHandler);\n      }\n      modal.classList.remove(\"active\");\n      cancellable = true;\n      return empty(modal);\n    },\n    alert: function(message) {\n      return prompt({\n        title: \"Alert\",\n        message: message,\n        focus: \"button\",\n        confirm: handle(function() {\n          return Modal.hide();\n        })\n      });\n    },\n    prompt: function(message, defaultValue) {\n      if (defaultValue == null) {\n        defaultValue = \"\";\n      }\n      return prompt({\n        title: \"Prompt\",\n        message: message,\n        focus: \"input\",\n        defaultValue: defaultValue,\n        cancel: handle(function() {\n          return Modal.hide(null);\n        }),\n        confirm: handle(function() {\n          return Modal.hide(modal.querySelector(\"input\").value);\n        })\n      });\n    },\n    confirm: function(message) {\n      return prompt({\n        title: \"Confirm\",\n        message: message,\n        focus: \"button\",\n        cancel: handle(function() {\n          return Modal.hide(false);\n        }),\n        confirm: handle(function() {\n          return Modal.hide(true);\n        })\n      });\n    },\n    form: function(formElement) {\n      return new Promise(function(resolve) {\n        var submitHandler;\n        submitHandler = handle(function(e) {\n          var formData, result;\n          formData = new FormData(formElement);\n          result = formDataToObject(formData);\n          return Modal.hide(result);\n        });\n        formElement.addEventListener(\"submit\", submitHandler);\n        return Modal.show(formElement, function(result) {\n          formElement.removeEventListener(\"submit\", submitHandler);\n          return resolve(result);\n        });\n      });\n    }\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "pixie": {
          "path": "pixie",
          "content": "module.exports = {\"version\":\"0.1.2\",\"entryPoint\":\"main\",\"remoteDependencies\":[],\"dependencies\":{\"observable\":\"distri/observable:master\",\"bindable\":\"distri/bindable:master\"}};",
          "type": "blob"
        },
        "samples/notepad-menu": {
          "path": "samples/notepad-menu",
          "content": "(function() {\n  module.exports = \"[F]ile\\n  [N]ew\\n  [O]pen\\n  [S]ave\\n  Save [A]s\\n  -\\n  Page Set[u]p\\n  [P]rint\\n  -\\n  E[x]it\\n[E]dit\\n  [U]ndo\\n  Redo\\n  -\\n  Cu[t]\\n  [C]opy\\n  [P]aste\\n  De[l]ete\\n  -\\n  [F]ind\\n  Find [N]ext\\n  [R]eplace\\n  [G]o To\\n  -\\n  Select [A]ll\\n  Time/[D]ate\\nF[o]rmat\\n  [W]ord Wrap\\n  [F]ont...\\n[V]iew\\n  [S]tatus Bar\\n[H]elp\\n  View [H]elp\\n  -\\n  [A]bout Notepad\";\n\n}).call(this);\n",
          "type": "blob"
        },
        "samples/test-form": {
          "path": "samples/test-form",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"form\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n        __root.buffer(\"Cool Form Bro\\n\");\n      }));\n      __root.buffer(__root.element(\"p\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"a\", this, {\n          \"href\": \"https://yolo.biz\"\n        }, function(__root) {\n          __root.buffer(\"Yolo\\n\");\n        }));\n      }));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"yolo\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"x\",\n        \"value\": \"Lorem\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"y\",\n        \"value\": \"florem\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"z\",\n        \"type\": \"number\",\n        \"value\": 5\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"input\", this, {\n        \"name\": \"file\",\n        \"type\": \"file\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"textarea\", this, {\n        \"name\": \"text\"\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n        __root.buffer(\"Submit\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "style": {
          "path": "style",
          "content": "(function() {\n  var all, styles;\n\n  styles = {};\n\n  all = \"main\\nloader\\nmenu\\nmodal\\ntable\\nwindow\".split(\"\\n\").map(function(stylePath) {\n    var content;\n    content = require(\"./style/\" + stylePath);\n    styles[stylePath] = content;\n    return content;\n  }).join(\"\\n\");\n\n  styles.all = all;\n\n  module.exports = styles;\n\n}).call(this);\n",
          "type": "blob"
        },
        "style/loader": {
          "path": "style/loader",
          "content": "module.exports = \"loader {\\n  display: block;\\n  padding: 1em;\\n}\\nloader > p:empty {\\n  margin: 0;\\n}\\nloader > progress {\\n  display: block;\\n}\\n\";",
          "type": "blob"
        },
        "style/main": {
          "path": "style/main",
          "content": "module.exports = \"* {\\n  box-sizing: border-box;\\n}\\nbody {\\n  display: flex;\\n  flex-direction: column;\\n  font-family: Sans-Serif;\\n  font-size: 14px;\\n  line-height: 18px;\\n  margin: 0;\\n}\\nbody,\\nhtml {\\n  height: 100%;\\n}\\ninput,\\ntextarea,\\nkeygen,\\nselect,\\nbutton {\\n  font-size: inherit;\\n  font-family: inherit;\\n}\\n\";",
          "type": "blob"
        },
        "style/menu": {
          "path": "style/menu",
          "content": "module.exports = \"menu {\\n  user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  background-color: #d3d3d3;\\n  border-bottom: 1px solid rgba(0,0,0,0.5);\\n  margin: 0;\\n  z-index: 1;\\n}\\nmenu:focus {\\n  outline: none;\\n}\\nmenu.context {\\n  z-index: 2000;\\n}\\nmenu-item {\\n  display: block;\\n  list-style-type: none;\\n}\\nmenu-item.active {\\n  background-color: #000080;\\n  color: #fff;\\n}\\nmenu-item > label {\\n  display: flex;\\n  padding: 0 0.25em;\\n  white-space: nowrap;\\n}\\nmenu-item > label > * {\\n  flex: 1 1 auto;\\n}\\nmenu-item > label > span.hotkey {\\n  margin-left: 1em;\\n}\\nmenu-item > label > span.hotkey:empty {\\n  margin-left: 0;\\n}\\nmenu-item > label > .decoration {\\n  flex: 0 1 auto;\\n  line-height: 1em;\\n  text-align: right;\\n  margin-left: 0.5em;\\n}\\nmenu-item > label > .decoration:empty {\\n  margin-left: 0;\\n}\\nmenu-item[disabled] {\\n  color: #808080;\\n}\\nmenu-item[disabled].active {\\n  background-color: rgba(0,0,0,0.125);\\n}\\nmenu.options {\\n  border-top: 1px solid rgba(255,255,255,0.5);\\n  border-left: 1px solid rgba(255,255,255,0.5);\\n  border-right: 1px solid rgba(0,0,0,0.5);\\n  box-shadow: 2px 2px 1px rgba(0,0,0,0.5);\\n  display: none;\\n  padding: 2px;\\n  padding-bottom: 3px;\\n  position: absolute;\\n}\\nmenu.options.active {\\n  display: block;\\n}\\nmenu.options > menu-item.menu {\\n  position: relative;\\n}\\nmenu.options > menu-item.menu > menu {\\n  position: absolute;\\n  left: 100%;\\n  top: -3px;\\n  margin-left: 1px;\\n}\\nmenu-item.menu.active > menu {\\n  background-color: #d3d3d3;\\n  color: #000;\\n  display: block;\\n}\\nmenu.bar {\\n  display: block;\\n  flex: 0 0 auto;\\n  margin: 0;\\n  padding: 0;\\n  position: initial;\\n  white-space: nowrap;\\n  overflow: hidden;\\n}\\nmenu.bar > menu-item {\\n  display: inline-block;\\n}\\nmenu.bar > menu-item > label > .decoration {\\n  display: none;\\n}\\nmenu.bar.accelerator-active span.accelerator {\\n  text-decoration: underline;\\n}\\n\";",
          "type": "blob"
        },
        "style/modal": {
          "path": "style/modal",
          "content": "module.exports = \"#modal {\\n  align-items: center;\\n  background-color: rgba(0,0,0,0.25);\\n  display: none;\\n  justify-content: center;\\n  position: absolute;\\n  z-index: 1000;\\n  top: 0;\\n  width: 100%;\\n  height: 100%;\\n}\\n#modal.active {\\n  display: flex;\\n}\\n#modal > * {\\n  background-color: #fff;\\n  border: 1px solid rgba(0,0,0,0.5);\\n  box-shadow: 2px 2px 6px #000;\\n  max-width: 90%;\\n  max-height: 90%;\\n}\\n#modal > form {\\n  display: block;\\n  padding: 1em;\\n}\\n#modal > form > h1 {\\n  font-size: 1.5em;\\n  margin: 0;\\n}\\n#modal > form > input,\\n#modal > form textarea {\\n  display: block;\\n  margin-bottom: 1em;\\n  width: 100%;\\n}\\n#modal > form > button {\\n  margin-right: 1em;\\n}\\n#modal > form > button:last-child {\\n  margin-right: 0;\\n}\\n\";",
          "type": "blob"
        },
        "style/table": {
          "path": "style/table",
          "content": "module.exports = \"container {\\n  display: block;\\n  height: 100%;\\n  overflow: auto;\\n  width: 100%;\\n}\\ntable {\\n  border-collapse: collapse;\\n  width: 100%;\\n}\\nth {\\n  text-align: left;\\n}\\nthead {\\n  border-bottom: 1px solid #000;\\n}\\ntd > input {\\n  border: none;\\n  background-color: transparent;\\n  width: 100%;\\n  height: 100%;\\n  padding: 0;\\n}\\ntr:nth-child(even) {\\n  background-color: #eee;\\n}\\n\";",
          "type": "blob"
        },
        "style/window": {
          "path": "style/window",
          "content": "module.exports = \"desktop {\\n  user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  display: block;\\n  flex: 1 0 auto;\\n}\\nwindow {\\n  user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  background-color: #d3d3d3;\\n  border: 4px double #000;\\n  display: flex;\\n  flex-direction: column;\\n  position: absolute;\\n}\\nwindow > header {\\n  border-bottom: 1px solid #000;\\n  cursor: default;\\n  display: flex;\\n  flex: 0 0 auto;\\n}\\nwindow > header > close,\\nwindow > header > control {\\n  color: #fff;\\n  display: inline-block;\\n  flex: 0 0 auto;\\n  font-family: monospace;\\n  width: 18px;\\n  text-shadow: 1px 0px 0px #000, -1px 0px 0px #000, 0px -1px 0px #000, 0px 1px 0px #000, 1px 1px 0px #808080;\\n  text-align: center;\\n}\\nwindow > header > title-bar {\\n  background-color: #000080;\\n  border-color: #000;\\n  border-style: solid;\\n  border-width: 0 1px;\\n  color: #fff;\\n  display: inline-block;\\n  flex: 1 1 auto;\\n  overflow: hidden;\\n  padding: 0 2px;\\n  text-align: center;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n}\\nwindow > viewport {\\n  background-color: #fff;\\n  display: flex;\\n  height: 100%;\\n  overflow: auto;\\n  position: relative;\\n  z-index: 0;\\n}\\nwindow > viewport > * {\\n  margin: auto;\\n}\\nwindow > viewport > textarea {\\n  font-family: monospace;\\n  height: 100%;\\n  resize: none;\\n  width: 100%;\\n}\\nwindow > viewport > iframe {\\n  border: none;\\n  height: 100%;\\n  width: 100%;\\n  position: absolute;\\n}\\nwindow > resize {\\n  display: block;\\n  position: absolute;\\n}\\nwindow > resize.e,\\nwindow > resize.w {\\n  cursor: ew-resize;\\n}\\nwindow > resize.n,\\nwindow > resize.s {\\n  cursor: ns-resize;\\n}\\nwindow > resize.h {\\n  height: 4px;\\n  width: 100%;\\n}\\nwindow > resize.v {\\n  height: 100%;\\n  width: 4px;\\n}\\nwindow > resize.w {\\n  left: -4px;\\n}\\nwindow > resize.e {\\n  right: -4px;\\n}\\nwindow > resize.n {\\n  top: -4px;\\n}\\nwindow > resize.s {\\n  bottom: -4px;\\n}\\nwindow > resize.n.w {\\n  cursor: nw-resize;\\n}\\nwindow > resize.n.e {\\n  cursor: ne-resize;\\n}\\nwindow > resize.s.e {\\n  cursor: se-resize;\\n}\\nwindow > resize.s.w {\\n  cursor: sw-resize;\\n}\\nwindow > resize.n.v {\\n  height: 23px;\\n  border-bottom: 1px solid #000;\\n}\\nwindow > resize.s.v {\\n  height: 23px;\\n  border-top: 1px solid #000;\\n}\\nwindow > resize.e.h {\\n  border-left: 1px solid #000;\\n  width: 23px;\\n}\\nwindow > resize.w.h {\\n  border-right: 1px solid #000;\\n  width: 23px;\\n}\\nframe-guard {\\n  display: block;\\n  height: 100%;\\n  pointer-events: none;\\n  position: absolute;\\n  width: 100%;\\n  z-index: 100000;\\n}\\nframe-guard.active {\\n  pointer-events: auto;\\n}\\n\";",
          "type": "blob"
        },
        "templates/input": {
          "path": "templates/input",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"input\", this, {\n      \"value\": this.value,\n      \"type\": this.type\n    }, function(__root) {}));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/menu-item": {
          "path": "templates/menu-item",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"menu-item\", this, {\n      \"class\": [this[\"class\"]],\n      \"click\": this.click,\n      \"mousemove\": this.mousemove,\n      \"disabled\": this.disabled\n    }, function(__root) {\n      __root.buffer(__root.element(\"label\", this, {}, function(__root) {\n        __root.buffer(this.title);\n        __root.buffer(__root.element(\"span\", this, {\n          \"class\": [\"hotkey\"]\n        }, function(__root) {\n          __root.buffer(this.hotkey);\n        }));\n        __root.buffer(__root.element(\"span\", this, {\n          \"class\": [\"decoration\"]\n        }, function(__root) {\n          __root.buffer(this.decoration);\n        }));\n      }));\n      __root.buffer(this.content);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/menu-separator": {
          "path": "templates/menu-separator",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"menu-item\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"hr\", this, {}, function(__root) {}));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/menu": {
          "path": "templates/menu",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"menu\", this, {\n      \"class\": [this[\"class\"]],\n      \"click\": this.click,\n      \"style\": this.style\n    }, function(__root) {\n      __root.buffer(this.items);\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/modal": {
          "path": "templates/modal",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"div\", this, {\n      id: [\"modal\"]\n    }, function(__root) {}));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/modal/prompt": {
          "path": "templates/modal/prompt",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"form\", this, {\n      \"submit\": this.confirm,\n      \"tabindex\": -1\n    }, function(__root) {\n      __root.buffer(__root.element(\"h1\", this, {}, function(__root) {\n        __root.buffer(this.title);\n      }));\n      __root.buffer(__root.element(\"p\", this, {}, function(__root) {\n        __root.buffer(this.message);\n      }));\n      if (this.defaultValue != null) {\n        __root.buffer(__root.element(\"input\", this, {\n          \"type\": \"text\",\n          \"value\": this.defaultValue\n        }, function(__root) {}));\n      }\n      __root.buffer(__root.element(\"button\", this, {}, function(__root) {\n        __root.buffer(\"OK\\n\");\n      }));\n      if (this.cancel) {\n        __root.buffer(__root.element(\"button\", this, {\n          \"click\": this.cancel\n        }, function(__root) {\n          __root.buffer(\"Cancel\\n\");\n        }));\n      }\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/progress": {
          "path": "templates/progress",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"loader\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"p\", this, {}, function(__root) {\n        __root.buffer(this.message);\n      }));\n      __root.buffer(__root.element(\"progress\", this, {\n        \"class\": [this[\"class\"]],\n        \"value\": this.value,\n        \"max\": this.max\n      }, function(__root) {}));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/table": {
          "path": "templates/table",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"container\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"table\", this, {\n        \"keydown\": this.keydown\n      }, function(__root) {\n        __root.buffer(__root.element(\"thead\", this, {}, function(__root) {\n          __root.buffer(__root.element(\"tr\", this, {}, function(__root) {\n            this.headers.forEach(function(header) {\n              return __root.buffer(__root.element(\"th\", this, {}, function(__root) {\n                __root.buffer(header);\n              }));\n            });\n          }));\n        }));\n        __root.buffer(__root.element(\"tbody\", this, {}, function(__root) {}));\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "templates/window": {
          "path": "templates/window",
          "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/hamlet-runtime\")(this);\n    __root.buffer(__root.element(\"window\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"e\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"w\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"e\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"e\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"w\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"n\", \"w\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"e\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"e\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"w\", \"h\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"resize\", this, {\n        \"class\": [\"s\", \"w\", \"v\"]\n      }, function(__root) {}));\n      __root.buffer(__root.element(\"header\", this, {}, function(__root) {\n        __root.buffer(__root.element(\"control\", this, {}, function(__root) {\n          __root.buffer(\"-\\n\");\n        }));\n        __root.buffer(__root.element(\"title-bar\", this, {}, function(__root) {\n          __root.buffer(this.title);\n        }));\n        __root.buffer(__root.element(\"close\", this, {\n          \"click\": this.close\n        }, function(__root) {\n          __root.buffer(\"X\\n\");\n        }));\n      }));\n      __root.buffer(this.menuBar);\n      __root.buffer(__root.element(\"viewport\", this, {}, function(__root) {\n        __root.buffer(this.content);\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
          "type": "blob"
        },
        "test/menu": {
          "path": "test/menu",
          "content": "(function() {\n  var parse;\n\n  parse = require(\"../lib/indent-parse\");\n\n  describe(\"Menu Parser\", function() {\n    it(\"should parse menus into lists\", function() {\n      var data, results;\n      data = \"File\";\n      results = parse(data);\n      return assert.deepEqual([\"File\"], results);\n    });\n    it(\"should parse empty\", function() {\n      var data;\n      data = \"\";\n      return assert.deepEqual([], parse(data));\n    });\n    it(\"should deal with nesting ok\", function() {\n      var data, results;\n      data = \"File\\n  Open\\n  Save\\nEdit\\n  Copy\\n  Paste\\nHelp\";\n      results = parse(data);\n      return assert.deepEqual([[\"File\", [\"Open\", \"Save\"]], [\"Edit\", [\"Copy\", \"Paste\"]], \"Help\"], results);\n    });\n    it(\"should parse big ol' menus\", function() {\n      var results;\n      results = parse(\"File\\n  New\\n  Open\\n  Save\\n  Save As\\nEdit\\n  Undo\\n  Redo\\n  -\\n  Cut\\n  Copy\\n  Paste\\n  Delete\\n  -\\n  Find\\n  Find Next\\n  Replace\\n  Go To\\n  -\\n  Select All\\n  Time/Date\\nFormat\\n  Word Wrap\\n  Font...\\nView\\n  Status Bar\\nHelp\\n  View Help\\n  -\\n  About Notepad\");\n      return assert.deepEqual([[\"File\", [\"New\", \"Open\", \"Save\", \"Save As\"]], [\"Edit\", [\"Undo\", \"Redo\", \"-\", \"Cut\", \"Copy\", \"Paste\", \"Delete\", \"-\", \"Find\", \"Find Next\", \"Replace\", \"Go To\", \"-\", \"Select All\", \"Time/Date\"]], [\"Format\", [\"Word Wrap\", \"Font...\"]], [\"View\", [\"Status Bar\"]], [\"Help\", [\"View Help\", \"-\", \"About Notepad\"]]], results);\n    });\n    return it(\"should parse hella nested menus\", function() {\n      var results;\n      results = parse(\"File\\n  Special\\n    Nested\\n      Super\\n        Awesome\");\n      return assert.deepEqual([[\"File\", [[\"Special\", [[\"Nested\", [[\"Super\", [\"Awesome\"]]]]]]]]], results);\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "test/modal": {
          "path": "test/modal",
          "content": "(function() {\n  var Modal;\n\n  PACKAGE.name = \"test\";\n\n  Modal = require(\"../main\").Modal;\n\n  describe(\"Modal\", function() {\n    return it(\"shoud be totally chill\", function() {\n      var called, element, handler;\n      element = document.createElement(\"p\");\n      called = false;\n      handler = function(value) {\n        called = true;\n        return assert.equal(value, \"yolo\");\n      };\n      Modal.show(element, handler);\n      Modal.hide('yolo');\n      return assert(called);\n    });\n  });\n\n}).call(this);\n",
          "type": "blob"
        },
        "util": {
          "path": "util",
          "content": "(function() {\n  var A, F, Observable, S, accelerateItem, advance, asElement, elementView, empty, entityMap, formDataToObject, handle, isDescendant, o;\n\n  Observable = require(\"observable\");\n\n  A = function(attr) {\n    return function(x) {\n      return x[attr];\n    };\n  };\n\n  F = function(methodName) {\n    return function(x) {\n      return x[methodName]();\n    };\n  };\n\n  o = function(object, name) {\n    var attribute;\n    attribute = Observable(object[name]);\n    attribute.observe(function(newValue) {\n      return object[name] = newValue;\n    });\n    return attribute;\n  };\n\n  handle = function(fn) {\n    return function(e) {\n      if (e != null ? e.defaultPrevented : void 0) {\n        return;\n      }\n      if (e != null) {\n        e.preventDefault();\n      }\n      return fn.call(this, e);\n    };\n  };\n\n  S = function(object, method, defaultValue) {\n    return function() {\n      if (typeof (object != null ? object[method] : void 0) === 'function') {\n        return object[method]();\n      } else {\n        return defaultValue;\n      }\n    };\n  };\n\n  asElement = A('element');\n\n  accelerateItem = function(items, key) {\n    var acceleratedItem;\n    acceleratedItem = items.filter(function(item) {\n      return item.accelerator === key;\n    })[0];\n    if (acceleratedItem) {\n      return acceleratedItem.click();\n    }\n  };\n\n  isDescendant = function(element, ancestor) {\n    var parent;\n    if (!element) {\n      return;\n    }\n    while ((parent = element.parentElement)) {\n      if (element === ancestor) {\n        return true;\n      }\n      element = parent;\n    }\n  };\n\n  advance = function(list, amount) {\n    var activeItemIndex, currentItem;\n    currentItem = list.filter(function(item) {\n      return item.active();\n    })[0];\n    activeItemIndex = list.indexOf(currentItem) + amount;\n    if (activeItemIndex < 0) {\n      activeItemIndex = list.length - 1;\n    } else if (activeItemIndex >= list.length) {\n      activeItemIndex = 0;\n    }\n    return list[activeItemIndex];\n  };\n\n  formDataToObject = function(formData) {\n    return Array.from(formData.entries()).reduce(function(object, _arg) {\n      var key, value;\n      key = _arg[0], value = _arg[1];\n      object[key] = value;\n      return object;\n    }, {});\n  };\n\n  elementView = function(element) {\n    if (!element) {\n      return;\n    }\n    if (element.view) {\n      return element.view;\n    }\n    return elementView(element.parentElement);\n  };\n\n  empty = function(node) {\n    while (node.hasChildNodes()) {\n      node.removeChild(node.lastChild);\n    }\n    return node;\n  };\n\n  module.exports = {\n    htmlEscape: function(string) {\n      return String(string).replace(/[&<>\"'\\/]/g, function(s) {\n        return entityMap[s];\n      });\n    },\n    A: A,\n    F: F,\n    S: S,\n    o: o,\n    advance: advance,\n    asElement: asElement,\n    accelerateItem: accelerateItem,\n    elementView: elementView,\n    empty: empty,\n    formDataToObject: formDataToObject,\n    handle: handle,\n    isDescendant: isDescendant\n  };\n\n  entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/context-menu": {
          "path": "views/context-menu",
          "content": "\n/*\nContextMenu\n\nDisplay a context menu!\n\nQuestions:\n\nShould we be able to update the options in the menu after creation?\n */\n\n(function() {\n  var MenuView, Observable, isDescendant;\n\n  Observable = require(\"observable\");\n\n  MenuView = require(\"./menu\");\n\n  isDescendant = require(\"../util\").isDescendant;\n\n  module.exports = function(_arg) {\n    var activeItem, contextRoot, element, handlers, items, left, self, top;\n    items = _arg.items, handlers = _arg.handlers;\n    activeItem = Observable(null);\n    top = Observable(\"\");\n    left = Observable(\"\");\n    contextRoot = {\n      activeItem: activeItem,\n      handlers: handlers\n    };\n    self = MenuView({\n      items: items,\n      contextRoot: contextRoot,\n      classes: function() {\n        return [\"context\", \"options\"];\n      },\n      style: function() {\n        return \"top: \" + (top()) + \"px; left: \" + (left()) + \"px\";\n      }\n    });\n    element = self.element;\n    element.view = self;\n    self.contextRoot = contextRoot;\n    self.display = function(_arg1) {\n      var inElement, x, y;\n      inElement = _arg1.inElement, x = _arg1.x, y = _arg1.y;\n      top(y);\n      left(x);\n      (inElement || document.body).appendChild(element);\n      activeItem(self);\n      return element.focus();\n    };\n    document.addEventListener(\"mousedown\", function(e) {\n      if (!isDescendant(e.target, element)) {\n        return activeItem(null);\n      }\n    });\n    element.setAttribute(\"tabindex\", \"-1\");\n    element.addEventListener(\"keydown\", function(e) {\n      var currentItem, direction, key;\n      key = e.key;\n      switch (key) {\n        case \"ArrowLeft\":\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n        case \"ArrowDown\":\n          e.preventDefault();\n          direction = key.replace(\"Arrow\", \"\");\n          currentItem = activeItem();\n          if (currentItem) {\n            return currentItem.cursor(direction);\n          }\n          break;\n        case \"Escape\":\n          return activeItem(null);\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu-bar": {
          "path": "views/menu-bar",
          "content": "(function() {\n  var MenuView, Observable, advance, isDescendant, _ref;\n\n  Observable = require(\"observable\");\n\n  MenuView = require(\"./menu\");\n\n  _ref = require(\"../util\"), isDescendant = _ref.isDescendant, advance = _ref.advance;\n\n  module.exports = function(_arg) {\n    var accelerateIfActive, acceleratorActive, activeItem, contextRoot, deactivate, element, handlers, items, previouslyFocusedElement, self;\n    items = _arg.items, handlers = _arg.handlers;\n    acceleratorActive = Observable(false);\n    activeItem = Observable(null);\n    previouslyFocusedElement = null;\n    contextRoot = {\n      activeItem: activeItem,\n      handlers: handlers\n    };\n    self = MenuView({\n      classes: function() {\n        return [\"bar\", acceleratorActive() ? \"accelerator-active\" : void 0];\n      },\n      items: items,\n      contextRoot: contextRoot\n    });\n    element = self.element;\n    self.cursor = function(direction) {\n      switch (direction) {\n        case \"Right\":\n          return self.advance(1);\n        case \"Left\":\n          return self.advance(-1);\n      }\n    };\n    self.items.forEach(function(item) {\n      item.horizontal = true;\n      return item.cursor = function(direction) {\n        var _ref1, _ref2;\n        console.log(\"Item\", direction);\n        if (direction === \"Down\") {\n          return (_ref1 = item.submenu) != null ? _ref1.advance(1) : void 0;\n        } else if (direction === \"Up\") {\n          return (_ref2 = item.submenu) != null ? _ref2.advance(-1) : void 0;\n        } else {\n          return item.parent.cursor(direction);\n        }\n      };\n    });\n    deactivate = function() {\n      activeItem(null);\n      acceleratorActive(false);\n      return previouslyFocusedElement != null ? previouslyFocusedElement.focus() : void 0;\n    };\n    document.addEventListener(\"mousedown\", function(e) {\n      if (!isDescendant(e.target, element)) {\n        acceleratorActive(false);\n        return activeItem(null);\n      }\n    });\n    document.addEventListener(\"keydown\", function(e) {\n      var key, menuIsActive, _ref1;\n      key = e.key;\n      switch (key) {\n        case \"Enter\":\n          return (_ref1 = activeItem()) != null ? _ref1.click() : void 0;\n        case \"Alt\":\n          menuIsActive = false;\n          if (acceleratorActive() || menuIsActive) {\n            return deactivate();\n          } else {\n            previouslyFocusedElement = document.activeElement;\n            element.focus();\n            if (!activeItem()) {\n              activeItem(self);\n            }\n            return acceleratorActive(true);\n          }\n      }\n    });\n    accelerateIfActive = function(key) {\n      var _ref1;\n      if (acceleratorActive()) {\n        return (_ref1 = activeItem()) != null ? _ref1.accelerate(key) : void 0;\n      }\n    };\n    element.setAttribute(\"tabindex\", \"-1\");\n    element.addEventListener(\"keydown\", function(e) {\n      var accelerated, currentItem, direction, key;\n      key = e.key;\n      switch (key) {\n        case \"ArrowLeft\":\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n        case \"ArrowDown\":\n          e.preventDefault();\n          direction = key.replace(\"Arrow\", \"\");\n          currentItem = activeItem();\n          if (currentItem) {\n            return currentItem.cursor(direction);\n          }\n          break;\n        case \"Escape\":\n          return deactivate();\n        default:\n          accelerated = accelerateIfActive(key.toLowerCase());\n          if (accelerated != null) {\n            return e.preventDefault();\n          }\n      }\n    });\n    return self;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu-item": {
          "path": "views/menu-item",
          "content": "(function() {\n  var F, MenuItemTemplate, S, accelerateItem, advance, asElement, formatAction, formatLabel, handle, htmlEscape, isDescendant, _ref;\n\n  _ref = require(\"../util\"), advance = _ref.advance, htmlEscape = _ref.htmlEscape, asElement = _ref.asElement, F = _ref.F, S = _ref.S, isDescendant = _ref.isDescendant, accelerateItem = _ref.accelerateItem, handle = _ref.handle;\n\n  MenuItemTemplate = require(\"../templates/menu-item\");\n\n  module.exports = function(_arg) {\n    var MenuView, accelerator, action, actionName, active, activeItem, click, content, contextRoot, disabled, element, handlers, hotkey, items, label, labelText, parent, self, submenu, title, _ref1, _ref2;\n    label = _arg.label, MenuView = _arg.MenuView, items = _arg.items, contextRoot = _arg.contextRoot, parent = _arg.parent;\n    self = {};\n    activeItem = contextRoot.activeItem, handlers = contextRoot.handlers;\n    active = function() {\n      var _ref1;\n      return isDescendant((_ref1 = activeItem()) != null ? _ref1.element : void 0, element);\n    };\n    self.active = active;\n    if (items) {\n      submenu = MenuView({\n        items: items,\n        contextRoot: contextRoot,\n        parent: self\n      });\n      content = submenu.element;\n    }\n    _ref1 = formatAction(label), labelText = _ref1[0], actionName = _ref1[1];\n    _ref2 = formatLabel(labelText), title = _ref2[0], accelerator = _ref2[1];\n    action = handlers[actionName];\n    disabled = S(action, \"disabled\", false);\n    hotkey = S(action, \"hotkey\", \"\");\n    click = function(e) {\n      if (disabled()) {\n        return;\n      }\n      if (e != null ? e.defaultPrevented : void 0) {\n        return;\n      }\n      if (e != null) {\n        e.preventDefault();\n      }\n      if (submenu) {\n        activeItem(submenu);\n        return;\n      }\n      console.log(\"Handling\", actionName);\n      if (action != null) {\n        if (typeof action.call === \"function\") {\n          action.call(handlers);\n        }\n      }\n      return activeItem(null);\n    };\n    element = MenuItemTemplate({\n      \"class\": function() {\n        return [items ? \"menu\" : void 0, active() ? \"active\" : void 0];\n      },\n      click: click,\n      mousemove: function(e) {\n        if (!activeItem()) {\n          return;\n        }\n        if (!e.defaultPrevented && isDescendant(e.target, element)) {\n          e.preventDefault();\n          return activeItem(self);\n        }\n      },\n      title: title,\n      content: content,\n      decoration: items ? \"▸\" : void 0,\n      hotkey: hotkey,\n      disabled: disabled\n    });\n    Object.assign(self, {\n      accelerator: accelerator,\n      accelerate: function(key) {\n        if (submenu) {\n          return submenu.accelerate(key);\n        } else {\n          return parent.accelerate(key);\n        }\n      },\n      click: click,\n      parent: parent,\n      element: element,\n      submenu: submenu,\n      cursor: function(direction) {\n        console.log(\"Item Cursor\", direction);\n        if (submenu && direction === \"Right\") {\n          return activeItem(submenu.navigableItems[0]);\n        } else if (parent.parent && direction === \"Left\") {\n          if (parent.parent.horizontal) {\n            return parent.parent.cursor(direction);\n          } else {\n            return activeItem(parent.parent);\n          }\n        } else {\n          return parent.cursor(direction);\n        }\n      }\n    });\n    return self;\n  };\n\n  formatAction = function(labelText) {\n    var action, title, _ref1;\n    _ref1 = labelText.split(\"->\").map(F(\"trim\")), title = _ref1[0], action = _ref1[1];\n    if (action == null) {\n      action = title.replace(/[^A-Za-z0-9]/g, \"\");\n    }\n    action = action.charAt(0).toLowerCase() + action.substring(1);\n    return [title, action];\n  };\n\n  formatLabel = function(labelText) {\n    var accelerator, span, titleHTML;\n    accelerator = void 0;\n    titleHTML = htmlEscape(labelText).replace(/\\[([^\\]]+)\\]/, function(match, $1) {\n      accelerator = $1.toLowerCase();\n      return \"<span class=\\\"accelerator\\\">\" + $1 + \"</span>\";\n    });\n    span = document.createElement(\"span\");\n    span.innerHTML = titleHTML;\n    return [span, accelerator];\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu-separator": {
          "path": "views/menu-separator",
          "content": "(function() {\n  var MenuSeparatorTemplate;\n\n  MenuSeparatorTemplate = require(\"../templates/menu-separator\");\n\n  module.exports = function() {\n    return {\n      element: MenuSeparatorTemplate(),\n      separator: true\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/menu": {
          "path": "views/menu",
          "content": "(function() {\n  var F, MenuItemTemplate, MenuItemView, MenuTemplate, MenuView, Observable, S, SeparatorView, accelerateItem, advance, asElement, assert, handle, htmlEscape, isDescendant, _ref;\n\n  Observable = require(\"observable\");\n\n  assert = require(\"../lib/assert\");\n\n  _ref = require(\"../util\"), advance = _ref.advance, accelerateItem = _ref.accelerateItem, asElement = _ref.asElement, F = _ref.F, S = _ref.S, htmlEscape = _ref.htmlEscape, handle = _ref.handle, isDescendant = _ref.isDescendant;\n\n  MenuTemplate = require(\"../templates/menu\");\n\n  MenuItemTemplate = require(\"../templates/menu-item\");\n\n  SeparatorView = require(\"./menu-separator\");\n\n  MenuItemView = require(\"./menu-item\");\n\n  module.exports = MenuView = function(_arg) {\n    var active, activeItem, classes, contextRoot, items, navigableItems, parent, self, style;\n    items = _arg.items, classes = _arg.classes, style = _arg.style, contextRoot = _arg.contextRoot, parent = _arg.parent;\n    self = {};\n    if (classes == null) {\n      classes = function() {\n        return [\"options\"];\n      };\n    }\n    activeItem = contextRoot.activeItem;\n    items = items.map(function(item) {\n      var label, submenuItems;\n      switch (false) {\n        case item !== \"-\":\n          return SeparatorView();\n        case !Array.isArray(item):\n          assert(item.length === 2);\n          label = item[0], submenuItems = item[1];\n          return MenuItemView({\n            label: label,\n            items: submenuItems,\n            MenuView: MenuView,\n            contextRoot: contextRoot,\n            parent: self\n          });\n        default:\n          return MenuItemView({\n            label: item,\n            contextRoot: contextRoot,\n            parent: self\n          });\n      }\n    });\n    navigableItems = items.filter(function(item) {\n      return !item.separator;\n    });\n    active = function() {\n      var _ref1;\n      return isDescendant((_ref1 = activeItem()) != null ? _ref1.element : void 0, self.element);\n    };\n    Object.assign(self, {\n      accelerate: function(key) {\n        return accelerateItem(items, key);\n      },\n      cursor: function(direction) {\n        var _ref1;\n        switch (direction) {\n          case \"Up\":\n            return self.advance(-1);\n          case \"Down\":\n            return self.advance(1);\n          default:\n            return (_ref1 = parent.parent) != null ? _ref1.cursor(direction) : void 0;\n        }\n      },\n      parent: parent,\n      items: items,\n      advance: function(n) {\n        return activeItem(advance(navigableItems, n));\n      },\n      navigableItems: navigableItems,\n      element: MenuTemplate({\n        style: style,\n        \"class\": function() {\n          return [active() ? \"active\" : void 0].concat(classes());\n        },\n        click: handle(function(e) {\n          return activeItem(self);\n        }),\n        items: items.map(asElement)\n      })\n    });\n    return self;\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/progress": {
          "path": "views/progress",
          "content": "(function() {\n  var Observable, Template;\n\n  Template = require(\"../templates/progress\");\n\n  Observable = require(\"observable\");\n\n  module.exports = function(params) {\n    var element, max, message, value;\n    if (params == null) {\n      params = {};\n    }\n    value = params.value, max = params.max, message = params.message;\n    value = Observable(value || 0);\n    max = Observable(max);\n    message = Observable(message);\n    element = Template({\n      value: value,\n      max: max,\n      message: message\n    });\n    return {\n      element: element,\n      value: value,\n      message: message,\n      max: max\n    };\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/table": {
          "path": "views/table",
          "content": "(function() {\n  var TableTemplate, TableView, advanceRow, empty;\n\n  empty = require(\"../util\").empty;\n\n  TableTemplate = require(\"../templates/table\");\n\n  advanceRow = function(path, prev) {\n    var cellIndex, input, nextRowElement, td, tr;\n    td = path.filter(function(element) {\n      return element.tagName === \"TD\";\n    })[0];\n    if (!td) {\n      return;\n    }\n    tr = td.parentElement;\n    cellIndex = Array.prototype.indexOf.call(tr.children, td);\n    if (prev) {\n      nextRowElement = tr.previousSibling;\n    } else {\n      nextRowElement = tr.nextSibling;\n    }\n    if (nextRowElement) {\n      input = nextRowElement.children[cellIndex].querySelector('input');\n      return input != null ? input.focus() : void 0;\n    }\n  };\n\n  TableView = function(_arg) {\n    var RowElement, containerElement, data, filterAndSort, filterFn, headers, rowElements, tableBody, update;\n    data = _arg.data, headers = _arg.headers, RowElement = _arg.RowElement;\n    if (headers == null) {\n      headers = Object.keys(data[0]);\n    }\n    containerElement = TableTemplate({\n      headers: headers,\n      keydown: function(event) {\n        var key, path;\n        key = event.key, path = event.path;\n        switch (key) {\n          case \"Enter\":\n          case \"ArrowDown\":\n            event.preventDefault();\n            return advanceRow(path);\n          case \"ArrowUp\":\n            event.preventDefault();\n            return advanceRow(path, true);\n        }\n      }\n    });\n    tableBody = containerElement.querySelector('tbody');\n    filterFn = function(datum) {\n      return true;\n    };\n    filterAndSort = function(data, filterFn, sortFn) {\n      var filteredData;\n      if (filterFn == null) {\n        filterFn = function() {\n          return true;\n        };\n      }\n      filteredData = data.filter(filterFn);\n      if (sortFn) {\n        return filteredData.sort(sortFn);\n      } else {\n        return filteredData;\n      }\n    };\n    rowElements = function() {\n      return filterAndSort(data, filterFn, null).map(RowElement);\n    };\n    update = function() {\n      empty(tableBody);\n      return rowElements().forEach(function(element) {\n        return tableBody.appendChild(element);\n      });\n    };\n    update();\n    return {\n      element: containerElement,\n      render: update\n    };\n  };\n\n  module.exports = TableView;\n\n}).call(this);\n",
          "type": "blob"
        },
        "views/window": {
          "path": "views/window",
          "content": "(function() {\n  var Bindable, Observable, WindowTemplate, activeDrag, activeResize, dragStart, elementView, frameGuard, raiseToTop, resizeInitial, resizeStart, styleBind, topIndex;\n\n  WindowTemplate = require(\"../templates/window\");\n\n  elementView = require(\"../util\").elementView;\n\n  frameGuard = document.createElement(\"frame-guard\");\n\n  document.body.appendChild(frameGuard);\n\n  topIndex = 0;\n\n  raiseToTop = function(view) {\n    var zIndex;\n    if (typeof view.zIndex !== 'function') {\n      return;\n    }\n    zIndex = view.zIndex();\n    if (zIndex === topIndex) {\n      return;\n    }\n    topIndex += 1;\n    return view.zIndex(topIndex);\n  };\n\n  activeDrag = null;\n\n  dragStart = null;\n\n  document.addEventListener(\"mousedown\", function(e) {\n    var target, view;\n    target = e.target;\n    view = elementView(target);\n    if (view) {\n      raiseToTop(view);\n    }\n    if (target.tagName === \"TITLE-BAR\") {\n      frameGuard.classList.add(\"active\");\n      dragStart = e;\n      return activeDrag = view;\n    }\n  });\n\n  document.addEventListener(\"mousemove\", function(e) {\n    var dx, dy, prevX, prevY, x, y;\n    if (activeDrag) {\n      prevX = dragStart.clientX, prevY = dragStart.clientY;\n      x = e.clientX, y = e.clientY;\n      dx = x - prevX;\n      dy = y - prevY;\n      activeDrag.x(activeDrag.x() + dx);\n      activeDrag.y(activeDrag.y() + dy);\n      return dragStart = e;\n    }\n  });\n\n  activeResize = null;\n\n  resizeStart = null;\n\n  resizeInitial = null;\n\n  document.addEventListener(\"mousedown\", function(e) {\n    var height, target, width, x, y, _ref;\n    target = e.target;\n    if (target.tagName === \"RESIZE\") {\n      frameGuard.classList.add(\"active\");\n      resizeStart = e;\n      activeResize = target;\n      _ref = elementView(activeResize), width = _ref.width, height = _ref.height, x = _ref.x, y = _ref.y;\n      return resizeInitial = {\n        width: width(),\n        height: height(),\n        x: x(),\n        y: y()\n      };\n    }\n  });\n\n  document.addEventListener(\"mousemove\", function(e) {\n    var actualDeltaX, actualDeltaY, dx, dy, height, startX, startY, view, width, x, y;\n    if (activeResize) {\n      startX = resizeStart.clientX, startY = resizeStart.clientY;\n      x = e.clientX, y = e.clientY;\n      dx = x - startX;\n      dy = y - startY;\n      width = resizeInitial.width;\n      height = resizeInitial.height;\n      if (activeResize.classList.contains(\"e\")) {\n        width += dx;\n      }\n      if (activeResize.classList.contains(\"w\")) {\n        width -= dx;\n      }\n      if (activeResize.classList.contains(\"s\")) {\n        height += dy;\n      }\n      if (activeResize.classList.contains(\"n\")) {\n        height -= dy;\n      }\n      width = Math.max(width, 200);\n      height = Math.max(height, 50);\n      actualDeltaX = width - resizeInitial.width;\n      actualDeltaY = height - resizeInitial.height;\n      view = elementView(activeResize);\n      if (activeResize.classList.contains(\"n\")) {\n        view.y(resizeInitial.y - actualDeltaY);\n      }\n      if (activeResize.classList.contains(\"w\")) {\n        view.x(resizeInitial.x - actualDeltaX);\n      }\n      view.width(width);\n      view.height(height);\n      return view.trigger(\"resize\");\n    }\n  });\n\n  document.addEventListener(\"mouseup\", function() {\n    activeDrag = null;\n    activeResize = null;\n    return frameGuard.classList.remove(\"active\");\n  });\n\n  Bindable = require(\"bindable\");\n\n  Observable = require(\"observable\");\n\n  module.exports = function(params) {\n    var element, height, self, title, width, x, y, zIndex, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n    self = Bindable();\n    x = Observable((_ref = params.x) != null ? _ref : 50);\n    y = Observable((_ref1 = params.y) != null ? _ref1 : 50);\n    width = Observable((_ref2 = params.width) != null ? _ref2 : 400);\n    height = Observable((_ref3 = params.height) != null ? _ref3 : 300);\n    title = Observable((_ref4 = params.title) != null ? _ref4 : \"Untitled\");\n    topIndex += 1;\n    zIndex = Observable((_ref5 = params.zIndex) != null ? _ref5 : topIndex);\n    element = WindowTemplate({\n      title: title,\n      menuBar: params.menuBar,\n      content: params.content,\n      close: function() {\n        return self.close();\n      }\n    });\n    styleBind(y, element, \"top\", \"px\");\n    styleBind(x, element, \"left\", \"px\");\n    styleBind(height, element, \"height\", \"px\");\n    styleBind(width, element, \"width\", \"px\");\n    styleBind(zIndex, element, \"zIndex\");\n    Object.assign(self, {\n      element: element,\n      title: title,\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      zIndex: zIndex,\n      close: function() {\n        return element.remove();\n      }\n    });\n    element.view = self;\n    return self;\n  };\n\n  styleBind = function(observable, element, attr, suffix) {\n    var update;\n    if (suffix == null) {\n      suffix = \"\";\n    }\n    update = function(newValue) {\n      newValue = parseInt(newValue);\n      if (newValue != null) {\n        return element.style[attr] = \"\" + newValue + suffix;\n      }\n    };\n    observable.observe(update);\n    return update(observable());\n  };\n\n}).call(this);\n",
          "type": "blob"
        },
        "lib/hamlet-runtime": {
          "path": "lib/hamlet-runtime",
          "content": "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.HamletRuntime = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Generated by CoffeeScript 1.7.1\n(function() {\n  \"use strict\";\n  var Observable, Runtime, bindEvent, bindObservable, bufferTo, classes, createElement, empty, eventNames, get, id, isEvent, isFragment, makeElement, observeAttribute, observeAttributes, observeContent, specialBindings, valueBind, valueIndexOf;\n\n  Observable = require(\"o_0\");\n\n  eventNames = \"abort\\nblur\\nchange\\nclick\\ncontextmenu\\ndblclick\\ndrag\\ndragend\\ndragenter\\ndragexit\\ndragleave\\ndragover\\ndragstart\\ndrop\\nerror\\nfocus\\ninput\\nkeydown\\nkeypress\\nkeyup\\nload\\nmousedown\\nmousemove\\nmouseout\\nmouseover\\nmouseup\\nreset\\nresize\\nscroll\\nselect\\nsubmit\\ntouchcancel\\ntouchend\\ntouchenter\\ntouchleave\\ntouchmove\\ntouchstart\\nunload\".split(\"\\n\");\n\n  isEvent = function(name) {\n    return eventNames.indexOf(name) !== -1;\n  };\n\n  isFragment = function(node) {\n    return (node != null ? node.nodeType : void 0) === 11;\n  };\n\n  valueBind = function(element, value, context) {\n    Observable(function() {\n      var update;\n      value = Observable(value, context);\n      switch (element.nodeName) {\n        case \"SELECT\":\n          element.oninput = element.onchange = function() {\n            var optionValue, _ref, _value;\n            _ref = this.children[this.selectedIndex], optionValue = _ref.value, _value = _ref._value;\n            return value(_value || optionValue);\n          };\n          update = function(newValue) {\n            var options;\n            element._value = newValue;\n            if ((options = element._options)) {\n              if (newValue.value != null) {\n                return element.value = (typeof newValue.value === \"function\" ? newValue.value() : void 0) || newValue.value;\n              } else {\n                return element.selectedIndex = valueIndexOf(options, newValue);\n              }\n            } else {\n              return element.value = newValue;\n            }\n          };\n          return bindObservable(element, value, context, update);\n        default:\n          element.oninput = element.onchange = function() {\n            return value(element.value);\n          };\n          if (typeof element.attachEvent === \"function\") {\n            element.attachEvent(\"onkeydown\", function() {\n              return setTimeout(function() {\n                return value(element.value);\n              }, 0);\n            });\n          }\n          return bindObservable(element, value, context, function(newValue) {\n            if (element.value !== newValue) {\n              return element.value = newValue;\n            }\n          });\n      }\n    });\n  };\n\n  specialBindings = {\n    INPUT: {\n      checked: function(element, value, context) {\n        element.onchange = function() {\n          return typeof value === \"function\" ? value(element.checked) : void 0;\n        };\n        return bindObservable(element, value, context, function(newValue) {\n          return element.checked = newValue;\n        });\n      }\n    },\n    SELECT: {\n      options: function(element, values, context) {\n        var updateValues;\n        values = Observable(values, context);\n        updateValues = function(values) {\n          empty(element);\n          element._options = values;\n          return values.map(function(value, index) {\n            var option, optionName, optionValue;\n            option = createElement(\"option\");\n            option._value = value;\n            if (typeof value === \"object\") {\n              optionValue = (value != null ? value.value : void 0) || index;\n            } else {\n              optionValue = value.toString();\n            }\n            bindObservable(option, optionValue, value, function(newValue) {\n              return option.value = newValue;\n            });\n            optionName = (value != null ? value.name : void 0) || value;\n            bindObservable(option, optionName, value, function(newValue) {\n              return option.textContent = option.innerText = newValue;\n            });\n            element.appendChild(option);\n            if (value === element._value) {\n              element.selectedIndex = index;\n            }\n            return option;\n          });\n        };\n        return bindObservable(element, values, context, updateValues);\n      }\n    }\n  };\n\n  observeAttribute = function(element, context, name, value) {\n    var binding, nodeName, _ref;\n    nodeName = element.nodeName;\n    if (name === \"value\") {\n      valueBind(element, value);\n    } else if (binding = (_ref = specialBindings[nodeName]) != null ? _ref[name] : void 0) {\n      binding(element, value, context);\n    } else if (name.match(/^on/) && isEvent(name.substr(2))) {\n      bindEvent(element, name, value, context);\n    } else if (isEvent(name)) {\n      bindEvent(element, \"on\" + name, value, context);\n    } else {\n      bindObservable(element, value, context, function(newValue) {\n        if ((newValue != null) && newValue !== false) {\n          return element.setAttribute(name, newValue);\n        } else {\n          return element.removeAttribute(name);\n        }\n      });\n    }\n    return element;\n  };\n\n  observeAttributes = function(element, context, attributes) {\n    return Object.keys(attributes).forEach(function(name) {\n      var value;\n      value = attributes[name];\n      return observeAttribute(element, context, name, value);\n    });\n  };\n\n  bindObservable = function(element, value, context, update) {\n    var observable, observe, unobserve;\n    observable = Observable(value, context);\n    observe = function() {\n      observable.observe(update);\n      return update(observable());\n    };\n    unobserve = function() {\n      return observable.stopObserving(update);\n    };\n    observe();\n    return element;\n  };\n\n  bindEvent = function(element, name, fn, context) {\n    return element[name] = function() {\n      return fn.apply(context, arguments);\n    };\n  };\n\n  id = function(element, context, sources) {\n    var lastId, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(newId) {\n      return element.id = newId;\n    };\n    lastId = function() {\n      return value.last();\n    };\n    return bindObservable(element, lastId, context, update);\n  };\n\n  classes = function(element, context, sources) {\n    var classNames, update, value;\n    value = Observable.concat.apply(Observable, sources.map(function(source) {\n      return Observable(source, context);\n    }));\n    update = function(classNames) {\n      return element.className = classNames;\n    };\n    classNames = function() {\n      return value.join(\" \");\n    };\n    return bindObservable(element, classNames, context, update);\n  };\n\n  createElement = function(name) {\n    return document.createElement(name);\n  };\n\n  observeContent = function(element, context, contentFn) {\n    var append, contents, update;\n    contents = [];\n    contentFn.call(context, {\n      buffer: bufferTo(context, contents),\n      element: makeElement\n    });\n    append = function(item) {\n      if (item == null) {\n\n      } else if (typeof item === \"string\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"number\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item === \"boolean\") {\n        return element.appendChild(document.createTextNode(item));\n      } else if (typeof item.each === \"function\") {\n        return item.each(append);\n      } else if (typeof item.forEach === \"function\") {\n        return item.forEach(append);\n      } else {\n        return element.appendChild(item);\n      }\n    };\n    update = function(contents) {\n      empty(element);\n      return contents.forEach(append);\n    };\n    return update(contents);\n  };\n\n  bufferTo = function(context, collection) {\n    return function(content) {\n      if (typeof content === 'function') {\n        content = Observable(content, context);\n      }\n      collection.push(content);\n      return content;\n    };\n  };\n\n  makeElement = function(name, context, attributes, fn) {\n    var element;\n    if (attributes == null) {\n      attributes = {};\n    }\n    element = createElement(name);\n    Observable(function() {\n      if (attributes.id != null) {\n        id(element, context, attributes.id);\n        return delete attributes.id;\n      }\n    });\n    Observable(function() {\n      if (attributes[\"class\"] != null) {\n        classes(element, context, attributes[\"class\"]);\n        return delete attributes[\"class\"];\n      }\n    });\n    Observable(function() {\n      return observeAttributes(element, context, attributes);\n    }, context);\n    if (element.nodeName !== \"SELECT\") {\n      Observable(function() {\n        return observeContent(element, context, fn);\n      }, context);\n    }\n    return element;\n  };\n\n  Runtime = function(context) {\n    var self;\n    self = {\n      buffer: function(content) {\n        if (self.root) {\n          throw \"Cannot have multiple root elements\";\n        }\n        return self.root = content;\n      },\n      element: makeElement,\n      filter: function(name, content) {}\n    };\n    return self;\n  };\n\n  Runtime.VERSION = require(\"../package.json\").version;\n\n  Runtime.Observable = Observable;\n\n  module.exports = Runtime;\n\n  empty = function(node) {\n    var child, _results;\n    _results = [];\n    while (child = node.firstChild) {\n      _results.push(node.removeChild(child));\n    }\n    return _results;\n  };\n\n  valueIndexOf = function(options, value) {\n    if (typeof value === \"object\") {\n      return options.indexOf(value);\n    } else {\n      return options.map(function(option) {\n        return option.toString();\n      }).indexOf(value.toString());\n    }\n  };\n\n  get = function(x) {\n    if (typeof x === 'function') {\n      return x();\n    } else {\n      return x;\n    }\n  };\n\n}).call(this);\n\n},{\"../package.json\":3,\"o_0\":2}],2:[function(require,module,exports){\n(function (global){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],3:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"hamlet.coffee\",\n  \"version\": \"0.7.6\",\n  \"description\": \"Truly amazing templating!\",\n  \"devDependencies\": {\n    \"browserify\": \"^12.0.1\",\n    \"coffee-script\": \"~1.7.1\",\n    \"jsdom\": \"^7.2.0\",\n    \"mocha\": \"^2.3.3\"\n  },\n  \"dependencies\": {\n    \"hamlet-compiler\": \"0.7.0\",\n    \"o_0\": \"0.3.8\"\n  },\n  \"homepage\": \"hamlet.coffee\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/dr-coffee-labs/hamlet.git\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"script/prepublish\",\n    \"test\": \"script/test\"\n  },\n  \"files\": [\n    \"dist/\"\n  ],\n  \"main\": \"dist/runtime.js\"\n}\n\n},{}]},{},[1])(1)\n});",
          "type": "blob"
        }
      },
      "progenitor": {
        "url": "https://danielx.net/editor/"
      },
      "config": {
        "version": "0.1.2",
        "entryPoint": "main",
        "remoteDependencies": [],
        "dependencies": {
          "observable": "distri/observable:master",
          "bindable": "distri/bindable:master"
        }
      },
      "version": "0.1.2",
      "entryPoint": "main",
      "remoteDependencies": [],
      "repository": {
        "branch": "master",
        "default_branch": "master",
        "full_name": "STRd6/ui",
        "homepage": null,
        "description": "Classic User Interface",
        "html_url": "https://github.com/STRd6/ui",
        "url": "https://api.github.com/repos/STRd6/ui",
        "publishBranch": "gh-pages"
      },
      "dependencies": {
        "observable": {
          "source": {
            "LICENSE": {
              "path": "LICENSE",
              "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
              "mode": "100644",
              "type": "blob"
            },
            "README.md": {
              "path": "README.md",
              "content": "[![Build Status](https://travis-ci.org/distri/observable.svg?branch=npm)](https://travis-ci.org/distri/observable)\n\nObservable\n==========\n\nInstallation\n------------\n\nNode\n\n    npm install o_0\n\nUsage\n-----\n\n    Observable = require \"o_0\"\n\nGet notified when the value changes.\n\n    observable = Observable 5\n\n    observable() # 5\n\n    observable.observe (newValue) ->\n      console.log newValue\n\n    observable 10 # logs 10 to console\n\nArrays\n------\n\nProxy array methods.\n\n    observable = Observable [1, 2, 3]\n\n    observable.forEach (value) ->\n      # 1, 2, 3\n\nFunctions\n---------\n\nAutomagically compute dependencies for observable functions.\n\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n    lastName \"Bro\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "main.coffee.md": {
              "path": "main.coffee.md",
              "content": "Observable\n==========\n\n`Observable` allows for observing arrays, functions, and objects.\n\nFunction dependencies are automagically observed.\n\nStandard array methods are proxied through to the underlying array.\n\n    module.exports = Observable = (value, context) ->\n\nReturn the object if it is already an observable object.\n\n      return value if typeof value?.observe is \"function\"\n\nMaintain a set of listeners to observe changes and provide a helper to notify each observer.\n\n      listeners = []\n\n      notify = (newValue) ->\n        copy(listeners).forEach (listener) ->\n          listener(newValue)\n\nOur observable function is stored as a reference to `self`.\n\nIf `value` is a function compute dependencies and listen to observables that it depends on.\n\n      if typeof value is 'function'\n        fn = value\n\nOur return function is a function that holds only a cached value which is updated\nwhen it's dependencies change.\n\nThe `magicDependency` call is so other functions can depend on this computed function the\nsame way we depend on other types of observables.\n\n        self = ->\n          # Automagic dependency observation\n          magicDependency(self)\n\n          return value\n\n        changed = ->\n          value = computeDependencies(self, fn, changed, context)\n          notify(value)\n\n        changed()\n\n      else\n\nWhen called with zero arguments it is treated as a getter. When called with one argument it is treated as a setter.\n\nChanges to the value will trigger notifications.\n\nThe value is always returned.\n\n        self = (newValue) ->\n          if arguments.length > 0\n            if value != newValue\n              value = newValue\n\n              notify(newValue)\n          else\n            # Automagic dependency observation\n            magicDependency(self)\n\n          return value\n\nThis `each` iterator is similar to [the Maybe monad](http://en.wikipedia.org/wiki/Monad_&#40;functional_programming&#41;#The_Maybe_monad) in that our observable may contain a single value or nothing at all.\n\n      self.each = (callback) ->\n        magicDependency(self)\n\n        if value?\n          [value].forEach (item) ->\n            callback.call(item, item)\n\n        return self\n\nIf the value is an array then proxy array methods and add notifications to mutation events.\n\n      if Array.isArray(value)\n        [\n          \"concat\"\n          \"every\"\n          \"filter\"\n          \"forEach\"\n          \"indexOf\"\n          \"join\"\n          \"lastIndexOf\"\n          \"map\"\n          \"reduce\"\n          \"reduceRight\"\n          \"slice\"\n          \"some\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            magicDependency(self)\n            value[method](args...)\n\n        [\n          \"pop\"\n          \"push\"\n          \"reverse\"\n          \"shift\"\n          \"splice\"\n          \"sort\"\n          \"unshift\"\n        ].forEach (method) ->\n          self[method] = (args...) ->\n            notifyReturning value[method](args...)\n\n        # Provide length on a best effort basis because older browsers choke\n        if PROXY_LENGTH\n          Object.defineProperty self, 'length',\n            get: ->\n              magicDependency(self)\n              value.length\n            set: (length) ->\n              value.length = length\n              notifyReturning(value.length)\n\n        notifyReturning = (returnValue) ->\n          notify(value)\n\n          return returnValue\n\nAdd some extra helpful methods to array observables.\n\n        extend self,\n          each: (callback) ->\n            self.forEach (item, index) ->\n              callback.call(item, item, index, self)\n\n            return self\n\nRemove an element from the array and notify observers of changes.\n\n          remove: (object) ->\n            index = value.indexOf(object)\n\n            if index >= 0\n              notifyReturning value.splice(index, 1)[0]\n\n          get: (index) ->\n            magicDependency(self)\n            value[index]\n\n          first: ->\n            magicDependency(self)\n            value[0]\n\n          last: ->\n            magicDependency(self)\n            value[value.length-1]\n\n          size: ->\n            magicDependency(self)\n            value.length\n\n      extend self,\n        listeners: listeners\n\n        observe: (listener) ->\n          listeners.push listener\n\n        stopObserving: (fn) ->\n          remove listeners, fn\n\n        toggle: ->\n          self !value\n\n        increment: (n) ->\n          self value + n\n\n        decrement: (n) ->\n          self value - n\n\n        toString: ->\n          \"Observable(#{value})\"\n\n      return self\n\n    Observable.concat = ->\n      # Optimization: Manually copy arguments to an array\n      args = new Array(arguments.length)\n      for arg, i in arguments\n        args[i] = arguments[i]\n\n      collection = Observable(args)\n\n      o = Observable ->\n        flatten collection.map(splat)\n\n      o.push = collection.push\n\n      return o\n\nAppendix\n--------\n\nThe extend method adds one object's properties to another.\n\n    extend = (target) ->\n      # Optimization: iterate through arguments manually rather than pass to slice to create an array\n      for source, i in arguments\n        # The first argument is target, so skip it\n        if i > 0\n          for name of source\n            target[name] = source[name]\n\n      return target\n\nSuper hax for computing dependencies. This needs to be a shared global so that\ndifferent bundled versions of observable libraries can interoperate.\n\n    global.OBSERVABLE_ROOT_HACK = []\n\n    magicDependency = (self) ->\n      observerSet = last(global.OBSERVABLE_ROOT_HACK)\n      if observerSet\n        observerSet.add self\n\nOptimization: Keep the function containing the try-catch as small as possible.\n\n    tryCallWithFinallyPop = (fn, context) ->\n      try\n        fn.call(context)\n      finally\n        global.OBSERVABLE_ROOT_HACK.pop()\n\nAutomagically compute dependencies.\n\n    computeDependencies = (self, fn, update, context) ->\n      deps = new Set\n\n      global.OBSERVABLE_ROOT_HACK.push(deps)\n\n      value = tryCallWithFinallyPop fn, context\n\n      self._deps?.forEach (observable) ->\n        observable.stopObserving update\n\n      self._deps = deps\n\n      deps.forEach (observable) ->\n        observable.observe update\n\n      return value\n\nCheck if we can proxy function length property.\n\n    try\n      Object.defineProperty (->), 'length',\n        get: ->\n        set: ->\n\n      PROXY_LENGTH = true\n    catch\n      PROXY_LENGTH = false\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n\n    copy = (array) ->\n      array.concat([])\n\n    get = (arg) ->\n      if typeof arg is \"function\"\n        arg()\n      else\n        arg\n\n    splat = (item) ->\n      results = []\n\n      return results unless item?\n\n      if typeof item.forEach is \"function\"\n        item.forEach (i) ->\n          results.push i\n      else\n        result = get item\n\n        results.push result if result?\n\n      results\n\n    last = (array) ->\n      array[array.length - 1]\n\n    flatten = (array) ->\n      array.reduce (a, b) ->\n        a.concat(b)\n      , []\n",
              "mode": "100644",
              "type": "blob"
            },
            "pixie.cson": {
              "path": "pixie.cson",
              "content": "version: \"0.3.8\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "test/observable.coffee": {
              "path": "test/observable.coffee",
              "content": "global.Observable = require \"../main\"\n\ndescribe 'Observable', ->\n  it 'should create an observable for an object', ->\n    n = 5\n\n    observable = Observable(n)\n\n    assert.equal(observable(), n)\n\n  it 'should fire events when setting', ->\n    string = \"yolo\"\n\n    observable = Observable(string)\n    observable.observe (newValue) ->\n      assert.equal newValue, \"4life\"\n\n    observable(\"4life\")\n\n  it \"should not fire when setting to the same value\", ->\n    o = Observable 5\n\n    o.observe ->\n      assert false\n\n    o(5)\n\n  it 'should be idempotent', ->\n    o = Observable(5)\n\n    assert.equal o, Observable(o)\n\n  describe \"#each\", ->\n    it \"should be invoked once if there is an observable\", ->\n      o = Observable(5)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n        assert.equal value, 5\n\n      assert.equal called, 1\n\n    it \"should not be invoked if observable is null\", ->\n      o = Observable(null)\n      called = 0\n\n      o.each (value) ->\n        called += 1\n\n      assert.equal called, 0\n\n    it \"should have the correct `this` scope for items\", (done) ->\n      o = Observable 5\n\n      o.each ->\n        assert.equal this, 5\n        done()\n\n    it \"should have the correct `this` scope for items in observable arrays\", ->\n      scopes = []\n\n      o = Observable [\"I'm\", \"an\", \"array\"]\n\n      o.each ->\n        scopes.push this\n\n      assert.equal scopes[0], \"I'm\"\n      assert.equal scopes[1], \"an\"\n      assert.equal scopes[2], \"array\"\n\n  it \"should allow for stopping observation\", ->\n    observable = Observable(\"string\")\n\n    called = 0\n    fn = (newValue) ->\n      called += 1\n      assert.equal newValue, \"4life\"\n\n    observable.observe fn\n\n    observable(\"4life\")\n\n    observable.stopObserving fn\n\n    observable(\"wat\")\n\n    assert.equal called, 1\n\n  it \"should increment\", ->\n    observable = Observable 1\n\n    observable.increment(5)\n\n    assert.equal observable(), 6\n\n  it \"should decremnet\", ->\n    observable = Observable 1\n\n    observable.decrement 5\n\n    assert.equal observable(), -4\n\n  it \"should toggle\", ->\n    observable = Observable false\n\n    observable.toggle()\n    assert.equal observable(), true\n\n    observable.toggle()\n    assert.equal observable(), false\n\n  it \"should trigger when toggling\", (done) ->\n    observable = Observable true\n    observable.observe (v) ->\n      assert.equal v, false\n      done()\n\n    observable.toggle()\n\n  it \"should have a nice toString\", ->\n    observable = Observable 5\n\n    assert.equal observable.toString(), \"Observable(5)\"\n\ndescribe \"Observable Array\", ->\n  it \"should proxy array methods\", ->\n    o = Observable [5]\n\n    o.map (n) ->\n      assert.equal n, 5\n\n  it \"should notify on mutation methods\", (done) ->\n    o = Observable []\n\n    o.observe (newValue) ->\n      assert.equal newValue[0], 1\n\n    o.push 1\n\n    done()\n\n  it \"should have an each method\", ->\n    o = Observable []\n\n    assert o.each\n\n  it \"#get\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.get(2), 2\n\n  it \"#first\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.first(), 0\n\n  it \"#last\", ->\n    o = Observable [0, 1, 2, 3]\n\n    assert.equal o.last(), 3\n\n  it \"#remove\", (done) ->\n    o = Observable [0, 1, 2, 3]\n\n    o.observe (newValue) ->\n      assert.equal newValue.length, 3\n      setTimeout ->\n        done()\n      , 0\n\n    assert.equal o.remove(2), 2\n\n  it \"#remove non-existent element\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.remove(0), undefined\n\n  it \"should proxy the length property\", ->\n    o = Observable [1, 2, 3]\n\n    assert.equal o.length, 3\n\n    called = false\n    o.observe (value) ->\n      assert.equal value[0], 1\n      assert.equal value[1], undefined\n      called = true\n\n    o.length = 1\n    assert.equal o.length, 1\n    assert.equal called, true\n\n  it \"should auto detect conditionals of length as a dependency\", ->\n    observableArray = Observable [1, 2, 3]\n\n    o = Observable ->\n      if observableArray.length > 5\n        true\n      else\n        false\n\n    assert.equal o(), false\n\n    called = 0\n    o.observe ->\n      called += 1\n\n    observableArray.push 4, 5, 6\n\n    assert.equal called, 1\n\ndescribe \"Observable functions\", ->\n  it \"should compute dependencies\", (done) ->\n    firstName = Observable \"Duder\"\n    lastName = Observable \"Man\"\n\n    o = Observable ->\n      \"#{firstName()} #{lastName()}\"\n\n    o.observe (newValue) ->\n      assert.equal newValue, \"Duder Bro\"\n\n      done()\n\n    lastName \"Bro\"\n\n  it \"should compute array#get as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.get(0)\n\n    assert.equal observableFn(), 0\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#first as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.first() + 1\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 6\n\n  it \"should compute array#last as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.last()\n\n    assert.equal observableFn(), 2\n\n    observableArray.pop()\n\n    assert.equal observableFn(), 1\n\n    observableArray([5])\n\n    assert.equal observableFn(), 5\n\n  it \"should compute array#size as a dependency\", ->\n    observableArray = Observable [0, 1, 2]\n\n    observableFn = Observable ->\n      observableArray.size() * 2\n\n    assert.equal observableFn(), 6\n\n    observableArray.pop()\n    assert.equal observableFn(), 4\n    observableArray.shift()\n    assert.equal observableFn(), 2\n\n  it \"should allow double nesting\", (done) ->\n    bottom = Observable \"rad\"\n    middle = Observable ->\n      bottom()\n    top = Observable ->\n      middle()\n\n    top.observe (newValue) ->\n      assert.equal newValue, \"wat\"\n      assert.equal top(), newValue\n      assert.equal middle(), newValue\n\n      done()\n\n    bottom(\"wat\")\n\n  it \"should work with dynamic dependencies\", ->\n    observableArray = Observable []\n\n    dynamicObservable = Observable ->\n      observableArray.filter (item) ->\n        item.age() > 3\n\n    assert.equal dynamicObservable().length, 0\n\n    observableArray.push\n      age: Observable 1\n\n    observableArray()[0].age 5\n    assert.equal dynamicObservable().length, 1\n\n  it \"should work with context\", ->\n    model =\n      a: Observable \"Hello\"\n      b: Observable \"there\"\n\n    model.c = Observable ->\n      \"#{@a()} #{@b()}\"\n    , model\n\n    assert.equal model.c(), \"Hello there\"\n\n    model.b \"world\"\n\n    assert.equal model.c(), \"Hello world\"\n\n  it \"should be ok even if the function throws an exception\", ->\n    assert.throws ->\n      t = Observable ->\n        throw \"wat\"\n\n    # TODO: Should be able to find a test case that is affected by this rather that\n    # checking it directly\n    assert.equal global.OBSERVABLE_ROOT_HACK.length, 0\n\n  it \"should have an each method\", ->\n    o = Observable ->\n\n    assert o.each()\n\n  it \"should not invoke when returning undefined\", ->\n    o = Observable ->\n\n    o.each ->\n      assert false\n\n  it \"should invoke when returning any defined value\", (done) ->\n    o = Observable -> 5\n\n    o.each (n) ->\n      assert.equal n, 5\n      done()\n\n  it \"should work on an array dependency\", ->\n    oA = Observable [1, 2, 3]\n\n    o = Observable ->\n      oA()[0]\n\n    last = Observable ->\n      oA()[oA().length-1]\n\n    assert.equal o(), 1\n\n    oA.unshift 0\n\n    assert.equal o(), 0\n\n    oA.push 4\n\n    assert.equal last(), 4, \"Last should be 4\"\n\n  it \"should work with multiple dependencies\", ->\n    letter = Observable \"A\"\n    checked = ->\n      l = letter()\n      @name().indexOf(l) is 0\n\n    first = {name: Observable(\"Andrew\")}\n    first.checked = Observable checked, first\n\n    second = {name: Observable(\"Benjamin\")}\n    second.checked = Observable checked, second\n\n    assert.equal first.checked(), true\n    assert.equal second.checked(), false\n\n    assert.equal letter.listeners.length, 2\n\n    letter \"B\"\n\n    assert.equal first.checked(), false\n    assert.equal second.checked(), true\n\n  it \"shouldn't double count dependencies\", ->\n    dep = Observable \"yo\"\n\n    o = Observable ->\n      dep()\n      dep()\n      dep()\n\n    count = 0\n    o.observe ->\n      count += 1\n\n    dep('heyy')\n\n    assert.equal count, 1\n\n  it \"should work with nested observable construction\", ->\n    gen = Observable ->\n      Observable \"Duder\"\n\n    o = gen()\n\n    assert.equal o(), \"Duder\"\n\n    o(\"wat\")\n\n    assert.equal o(), \"wat\"\n\n  describe \"Scoping\", ->\n    it \"should be scoped to optional context\", (done) ->\n      model =\n        firstName: Observable \"Duder\"\n        lastName: Observable \"Man\"\n\n      model.name = Observable ->\n        \"#{@firstName()} #{@lastName()}\"\n      , model\n\n      model.name.observe (newValue) ->\n        assert.equal newValue, \"Duder Bro\"\n\n        done()\n\n      model.lastName \"Bro\"\n\n  describe \"concat\", ->\n    it \"should work with a single observable\", ->\n      observable = Observable \"something\"\n      observableArray = Observable.concat observable\n      assert.equal observableArray.last(), \"something\"\n\n      observable \"something else\"\n      assert.equal observableArray.last(), \"something else\"\n\n    it \"should work with an undefined observable\", ->\n      observable = Observable undefined\n      observableArray = Observable.concat observable\n      assert.equal observableArray.size(), 0\n\n      observable \"defined\"\n      assert.equal observableArray.size(), 1\n\n    it \"should work with undefined\", ->\n      observableArray = Observable.concat undefined\n      assert.equal observableArray.size(), 0\n\n    it \"should work with []\", ->\n      observableArray = Observable.concat []\n      assert.equal observableArray.size(), 0\n\n    it \"should return an observable array that changes based on changes in inputs\", ->\n      numbers = Observable [1, 2, 3]\n      letters = Observable [\"a\", \"b\", \"c\"]\n      item = Observable({})\n      nullable = Observable null\n\n      observableArray = Observable.concat numbers, \"literal\", letters, item, nullable\n\n      assert.equal observableArray().length, 3 + 1 + 3 + 1\n\n      assert.equal observableArray()[0], 1\n      assert.equal observableArray()[3], \"literal\"\n      assert.equal observableArray()[4], \"a\"\n      assert.equal observableArray()[7], item()\n\n      numbers.push 4\n\n      assert.equal observableArray().length, 9\n\n      nullable \"cool\"\n\n      assert.equal observableArray().length, 10\n\n    it \"should work with observable functions that return arrays\", ->\n      item = Observable(\"wat\")\n\n      computedArray = Observable ->\n        [item()]\n\n      observableArray = Observable.concat computedArray, computedArray\n\n      assert.equal observableArray().length, 2\n\n      assert.equal observableArray()[1], \"wat\"\n\n      item \"yolo\"\n\n      assert.equal observableArray()[1], \"yolo\"\n\n    it \"should have a push method\", ->\n      observableArray = Observable.concat()\n\n      observable = Observable \"hey\"\n\n      observableArray.push observable\n\n      assert.equal observableArray()[0], \"hey\"\n\n      observable \"wat\"\n\n      assert.equal observableArray()[0], \"wat\"\n\n      observableArray.push \"cool\"\n      observableArray.push \"radical\"\n\n      assert.equal observableArray().length, 3\n\n    it \"should be observable\", (done) ->\n      observableArray = Observable.concat()\n\n      observableArray.observe (items) ->\n        assert.equal items.length, 3\n        done()\n\n      observableArray.push [\"A\", \"B\", \"C\"]\n\n    it \"should have an each method\", ->\n      observableArray = Observable.concat([\"A\", \"B\", \"C\"])\n\n      n = 0\n      observableArray.each () ->\n        n += 1\n\n      assert.equal n, 3\n\n  describe \"nesting dependencies\", ->\n    it \"should update the correct observable\", ->\n      a = Observable \"a\"\n      b = Observable \"b\"\n\n      results = Observable ->\n        r = Observable.concat()\n\n        r.push a\n        r.push b\n\n        r\n\n      # TODO: Should this just be\n      #     results.first()\n      assert.equal results().first(), \"a\"\n\n      a(\"newA\")\n\n      assert.equal results().first(), \"newA\"\n",
              "mode": "100644",
              "type": "blob"
            }
          },
          "distribution": {
            "main": {
              "path": "main",
              "content": "(function() {\n  var Observable, PROXY_LENGTH, computeDependencies, copy, extend, flatten, get, last, magicDependency, remove, splat, tryCallWithFinallyPop,\n    __slice = [].slice;\n\n  module.exports = Observable = function(value, context) {\n    var changed, fn, listeners, notify, notifyReturning, self;\n    if (typeof (value != null ? value.observe : void 0) === \"function\") {\n      return value;\n    }\n    listeners = [];\n    notify = function(newValue) {\n      return copy(listeners).forEach(function(listener) {\n        return listener(newValue);\n      });\n    };\n    if (typeof value === 'function') {\n      fn = value;\n      self = function() {\n        magicDependency(self);\n        return value;\n      };\n      changed = function() {\n        value = computeDependencies(self, fn, changed, context);\n        return notify(value);\n      };\n      changed();\n    } else {\n      self = function(newValue) {\n        if (arguments.length > 0) {\n          if (value !== newValue) {\n            value = newValue;\n            notify(newValue);\n          }\n        } else {\n          magicDependency(self);\n        }\n        return value;\n      };\n    }\n    self.each = function(callback) {\n      magicDependency(self);\n      if (value != null) {\n        [value].forEach(function(item) {\n          return callback.call(item, item);\n        });\n      }\n      return self;\n    };\n    if (Array.isArray(value)) {\n      [\"concat\", \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          magicDependency(self);\n          return value[method].apply(value, args);\n        };\n      });\n      [\"pop\", \"push\", \"reverse\", \"shift\", \"splice\", \"sort\", \"unshift\"].forEach(function(method) {\n        return self[method] = function() {\n          var args;\n          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return notifyReturning(value[method].apply(value, args));\n        };\n      });\n      if (PROXY_LENGTH) {\n        Object.defineProperty(self, 'length', {\n          get: function() {\n            magicDependency(self);\n            return value.length;\n          },\n          set: function(length) {\n            value.length = length;\n            return notifyReturning(value.length);\n          }\n        });\n      }\n      notifyReturning = function(returnValue) {\n        notify(value);\n        return returnValue;\n      };\n      extend(self, {\n        each: function(callback) {\n          self.forEach(function(item, index) {\n            return callback.call(item, item, index, self);\n          });\n          return self;\n        },\n        remove: function(object) {\n          var index;\n          index = value.indexOf(object);\n          if (index >= 0) {\n            return notifyReturning(value.splice(index, 1)[0]);\n          }\n        },\n        get: function(index) {\n          magicDependency(self);\n          return value[index];\n        },\n        first: function() {\n          magicDependency(self);\n          return value[0];\n        },\n        last: function() {\n          magicDependency(self);\n          return value[value.length - 1];\n        },\n        size: function() {\n          magicDependency(self);\n          return value.length;\n        }\n      });\n    }\n    extend(self, {\n      listeners: listeners,\n      observe: function(listener) {\n        return listeners.push(listener);\n      },\n      stopObserving: function(fn) {\n        return remove(listeners, fn);\n      },\n      toggle: function() {\n        return self(!value);\n      },\n      increment: function(n) {\n        return self(value + n);\n      },\n      decrement: function(n) {\n        return self(value - n);\n      },\n      toString: function() {\n        return \"Observable(\" + value + \")\";\n      }\n    });\n    return self;\n  };\n\n  Observable.concat = function() {\n    var arg, args, collection, i, o, _i, _len;\n    args = new Array(arguments.length);\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      arg = arguments[i];\n      args[i] = arguments[i];\n    }\n    collection = Observable(args);\n    o = Observable(function() {\n      return flatten(collection.map(splat));\n    });\n    o.push = collection.push;\n    return o;\n  };\n\n  extend = function(target) {\n    var i, name, source, _i, _len;\n    for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {\n      source = arguments[i];\n      if (i > 0) {\n        for (name in source) {\n          target[name] = source[name];\n        }\n      }\n    }\n    return target;\n  };\n\n  global.OBSERVABLE_ROOT_HACK = [];\n\n  magicDependency = function(self) {\n    var observerSet;\n    observerSet = last(global.OBSERVABLE_ROOT_HACK);\n    if (observerSet) {\n      return observerSet.add(self);\n    }\n  };\n\n  tryCallWithFinallyPop = function(fn, context) {\n    try {\n      return fn.call(context);\n    } finally {\n      global.OBSERVABLE_ROOT_HACK.pop();\n    }\n  };\n\n  computeDependencies = function(self, fn, update, context) {\n    var deps, value, _ref;\n    deps = new Set;\n    global.OBSERVABLE_ROOT_HACK.push(deps);\n    value = tryCallWithFinallyPop(fn, context);\n    if ((_ref = self._deps) != null) {\n      _ref.forEach(function(observable) {\n        return observable.stopObserving(update);\n      });\n    }\n    self._deps = deps;\n    deps.forEach(function(observable) {\n      return observable.observe(update);\n    });\n    return value;\n  };\n\n  try {\n    Object.defineProperty((function() {}), 'length', {\n      get: function() {},\n      set: function() {}\n    });\n    PROXY_LENGTH = true;\n  } catch (_error) {\n    PROXY_LENGTH = false;\n  }\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n  copy = function(array) {\n    return array.concat([]);\n  };\n\n  get = function(arg) {\n    if (typeof arg === \"function\") {\n      return arg();\n    } else {\n      return arg;\n    }\n  };\n\n  splat = function(item) {\n    var result, results;\n    results = [];\n    if (item == null) {\n      return results;\n    }\n    if (typeof item.forEach === \"function\") {\n      item.forEach(function(i) {\n        return results.push(i);\n      });\n    } else {\n      result = get(item);\n      if (result != null) {\n        results.push(result);\n      }\n    }\n    return results;\n  };\n\n  last = function(array) {\n    return array[array.length - 1];\n  };\n\n  flatten = function(array) {\n    return array.reduce(function(a, b) {\n      return a.concat(b);\n    }, []);\n  };\n\n}).call(this);\n",
              "type": "blob"
            },
            "pixie": {
              "path": "pixie",
              "content": "module.exports = {\"version\":\"0.3.8\"};",
              "type": "blob"
            },
            "test/observable": {
              "path": "test/observable",
              "content": "(function() {\n  global.Observable = require(\"../main\");\n\n  describe('Observable', function() {\n    it('should create an observable for an object', function() {\n      var n, observable;\n      n = 5;\n      observable = Observable(n);\n      return assert.equal(observable(), n);\n    });\n    it('should fire events when setting', function() {\n      var observable, string;\n      string = \"yolo\";\n      observable = Observable(string);\n      observable.observe(function(newValue) {\n        return assert.equal(newValue, \"4life\");\n      });\n      return observable(\"4life\");\n    });\n    it(\"should not fire when setting to the same value\", function() {\n      var o;\n      o = Observable(5);\n      o.observe(function() {\n        return assert(false);\n      });\n      return o(5);\n    });\n    it('should be idempotent', function() {\n      var o;\n      o = Observable(5);\n      return assert.equal(o, Observable(o));\n    });\n    describe(\"#each\", function() {\n      it(\"should be invoked once if there is an observable\", function() {\n        var called, o;\n        o = Observable(5);\n        called = 0;\n        o.each(function(value) {\n          called += 1;\n          return assert.equal(value, 5);\n        });\n        return assert.equal(called, 1);\n      });\n      it(\"should not be invoked if observable is null\", function() {\n        var called, o;\n        o = Observable(null);\n        called = 0;\n        o.each(function(value) {\n          return called += 1;\n        });\n        return assert.equal(called, 0);\n      });\n      it(\"should have the correct `this` scope for items\", function(done) {\n        var o;\n        o = Observable(5);\n        return o.each(function() {\n          assert.equal(this, 5);\n          return done();\n        });\n      });\n      return it(\"should have the correct `this` scope for items in observable arrays\", function() {\n        var o, scopes;\n        scopes = [];\n        o = Observable([\"I'm\", \"an\", \"array\"]);\n        o.each(function() {\n          return scopes.push(this);\n        });\n        assert.equal(scopes[0], \"I'm\");\n        assert.equal(scopes[1], \"an\");\n        return assert.equal(scopes[2], \"array\");\n      });\n    });\n    it(\"should allow for stopping observation\", function() {\n      var called, fn, observable;\n      observable = Observable(\"string\");\n      called = 0;\n      fn = function(newValue) {\n        called += 1;\n        return assert.equal(newValue, \"4life\");\n      };\n      observable.observe(fn);\n      observable(\"4life\");\n      observable.stopObserving(fn);\n      observable(\"wat\");\n      return assert.equal(called, 1);\n    });\n    it(\"should increment\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.increment(5);\n      return assert.equal(observable(), 6);\n    });\n    it(\"should decremnet\", function() {\n      var observable;\n      observable = Observable(1);\n      observable.decrement(5);\n      return assert.equal(observable(), -4);\n    });\n    it(\"should toggle\", function() {\n      var observable;\n      observable = Observable(false);\n      observable.toggle();\n      assert.equal(observable(), true);\n      observable.toggle();\n      return assert.equal(observable(), false);\n    });\n    it(\"should trigger when toggling\", function(done) {\n      var observable;\n      observable = Observable(true);\n      observable.observe(function(v) {\n        assert.equal(v, false);\n        return done();\n      });\n      return observable.toggle();\n    });\n    return it(\"should have a nice toString\", function() {\n      var observable;\n      observable = Observable(5);\n      return assert.equal(observable.toString(), \"Observable(5)\");\n    });\n  });\n\n  describe(\"Observable Array\", function() {\n    it(\"should proxy array methods\", function() {\n      var o;\n      o = Observable([5]);\n      return o.map(function(n) {\n        return assert.equal(n, 5);\n      });\n    });\n    it(\"should notify on mutation methods\", function(done) {\n      var o;\n      o = Observable([]);\n      o.observe(function(newValue) {\n        return assert.equal(newValue[0], 1);\n      });\n      o.push(1);\n      return done();\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable([]);\n      return assert(o.each);\n    });\n    it(\"#get\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.get(2), 2);\n    });\n    it(\"#first\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.first(), 0);\n    });\n    it(\"#last\", function() {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      return assert.equal(o.last(), 3);\n    });\n    it(\"#remove\", function(done) {\n      var o;\n      o = Observable([0, 1, 2, 3]);\n      o.observe(function(newValue) {\n        assert.equal(newValue.length, 3);\n        return setTimeout(function() {\n          return done();\n        }, 0);\n      });\n      return assert.equal(o.remove(2), 2);\n    });\n    it(\"#remove non-existent element\", function() {\n      var o;\n      o = Observable([1, 2, 3]);\n      return assert.equal(o.remove(0), void 0);\n    });\n    it(\"should proxy the length property\", function() {\n      var called, o;\n      o = Observable([1, 2, 3]);\n      assert.equal(o.length, 3);\n      called = false;\n      o.observe(function(value) {\n        assert.equal(value[0], 1);\n        assert.equal(value[1], void 0);\n        return called = true;\n      });\n      o.length = 1;\n      assert.equal(o.length, 1);\n      return assert.equal(called, true);\n    });\n    return it(\"should auto detect conditionals of length as a dependency\", function() {\n      var called, o, observableArray;\n      observableArray = Observable([1, 2, 3]);\n      o = Observable(function() {\n        if (observableArray.length > 5) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n      assert.equal(o(), false);\n      called = 0;\n      o.observe(function() {\n        return called += 1;\n      });\n      observableArray.push(4, 5, 6);\n      return assert.equal(called, 1);\n    });\n  });\n\n  describe(\"Observable functions\", function() {\n    it(\"should compute dependencies\", function(done) {\n      var firstName, lastName, o;\n      firstName = Observable(\"Duder\");\n      lastName = Observable(\"Man\");\n      o = Observable(function() {\n        return \"\" + (firstName()) + \" \" + (lastName());\n      });\n      o.observe(function(newValue) {\n        assert.equal(newValue, \"Duder Bro\");\n        return done();\n      });\n      return lastName(\"Bro\");\n    });\n    it(\"should compute array#get as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.get(0);\n      });\n      assert.equal(observableFn(), 0);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#first as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.first() + 1;\n      });\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 6);\n    });\n    it(\"should compute array#last as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.last();\n      });\n      assert.equal(observableFn(), 2);\n      observableArray.pop();\n      assert.equal(observableFn(), 1);\n      observableArray([5]);\n      return assert.equal(observableFn(), 5);\n    });\n    it(\"should compute array#size as a dependency\", function() {\n      var observableArray, observableFn;\n      observableArray = Observable([0, 1, 2]);\n      observableFn = Observable(function() {\n        return observableArray.size() * 2;\n      });\n      assert.equal(observableFn(), 6);\n      observableArray.pop();\n      assert.equal(observableFn(), 4);\n      observableArray.shift();\n      return assert.equal(observableFn(), 2);\n    });\n    it(\"should allow double nesting\", function(done) {\n      var bottom, middle, top;\n      bottom = Observable(\"rad\");\n      middle = Observable(function() {\n        return bottom();\n      });\n      top = Observable(function() {\n        return middle();\n      });\n      top.observe(function(newValue) {\n        assert.equal(newValue, \"wat\");\n        assert.equal(top(), newValue);\n        assert.equal(middle(), newValue);\n        return done();\n      });\n      return bottom(\"wat\");\n    });\n    it(\"should work with dynamic dependencies\", function() {\n      var dynamicObservable, observableArray;\n      observableArray = Observable([]);\n      dynamicObservable = Observable(function() {\n        return observableArray.filter(function(item) {\n          return item.age() > 3;\n        });\n      });\n      assert.equal(dynamicObservable().length, 0);\n      observableArray.push({\n        age: Observable(1)\n      });\n      observableArray()[0].age(5);\n      return assert.equal(dynamicObservable().length, 1);\n    });\n    it(\"should work with context\", function() {\n      var model;\n      model = {\n        a: Observable(\"Hello\"),\n        b: Observable(\"there\")\n      };\n      model.c = Observable(function() {\n        return \"\" + (this.a()) + \" \" + (this.b());\n      }, model);\n      assert.equal(model.c(), \"Hello there\");\n      model.b(\"world\");\n      return assert.equal(model.c(), \"Hello world\");\n    });\n    it(\"should be ok even if the function throws an exception\", function() {\n      assert.throws(function() {\n        var t;\n        return t = Observable(function() {\n          throw \"wat\";\n        });\n      });\n      return assert.equal(global.OBSERVABLE_ROOT_HACK.length, 0);\n    });\n    it(\"should have an each method\", function() {\n      var o;\n      o = Observable(function() {});\n      return assert(o.each());\n    });\n    it(\"should not invoke when returning undefined\", function() {\n      var o;\n      o = Observable(function() {});\n      return o.each(function() {\n        return assert(false);\n      });\n    });\n    it(\"should invoke when returning any defined value\", function(done) {\n      var o;\n      o = Observable(function() {\n        return 5;\n      });\n      return o.each(function(n) {\n        assert.equal(n, 5);\n        return done();\n      });\n    });\n    it(\"should work on an array dependency\", function() {\n      var last, o, oA;\n      oA = Observable([1, 2, 3]);\n      o = Observable(function() {\n        return oA()[0];\n      });\n      last = Observable(function() {\n        return oA()[oA().length - 1];\n      });\n      assert.equal(o(), 1);\n      oA.unshift(0);\n      assert.equal(o(), 0);\n      oA.push(4);\n      return assert.equal(last(), 4, \"Last should be 4\");\n    });\n    it(\"should work with multiple dependencies\", function() {\n      var checked, first, letter, second;\n      letter = Observable(\"A\");\n      checked = function() {\n        var l;\n        l = letter();\n        return this.name().indexOf(l) === 0;\n      };\n      first = {\n        name: Observable(\"Andrew\")\n      };\n      first.checked = Observable(checked, first);\n      second = {\n        name: Observable(\"Benjamin\")\n      };\n      second.checked = Observable(checked, second);\n      assert.equal(first.checked(), true);\n      assert.equal(second.checked(), false);\n      assert.equal(letter.listeners.length, 2);\n      letter(\"B\");\n      assert.equal(first.checked(), false);\n      return assert.equal(second.checked(), true);\n    });\n    it(\"shouldn't double count dependencies\", function() {\n      var count, dep, o;\n      dep = Observable(\"yo\");\n      o = Observable(function() {\n        dep();\n        dep();\n        return dep();\n      });\n      count = 0;\n      o.observe(function() {\n        return count += 1;\n      });\n      dep('heyy');\n      return assert.equal(count, 1);\n    });\n    it(\"should work with nested observable construction\", function() {\n      var gen, o;\n      gen = Observable(function() {\n        return Observable(\"Duder\");\n      });\n      o = gen();\n      assert.equal(o(), \"Duder\");\n      o(\"wat\");\n      return assert.equal(o(), \"wat\");\n    });\n    describe(\"Scoping\", function() {\n      return it(\"should be scoped to optional context\", function(done) {\n        var model;\n        model = {\n          firstName: Observable(\"Duder\"),\n          lastName: Observable(\"Man\")\n        };\n        model.name = Observable(function() {\n          return \"\" + (this.firstName()) + \" \" + (this.lastName());\n        }, model);\n        model.name.observe(function(newValue) {\n          assert.equal(newValue, \"Duder Bro\");\n          return done();\n        });\n        return model.lastName(\"Bro\");\n      });\n    });\n    describe(\"concat\", function() {\n      it(\"should work with a single observable\", function() {\n        var observable, observableArray;\n        observable = Observable(\"something\");\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.last(), \"something\");\n        observable(\"something else\");\n        return assert.equal(observableArray.last(), \"something else\");\n      });\n      it(\"should work with an undefined observable\", function() {\n        var observable, observableArray;\n        observable = Observable(void 0);\n        observableArray = Observable.concat(observable);\n        assert.equal(observableArray.size(), 0);\n        observable(\"defined\");\n        return assert.equal(observableArray.size(), 1);\n      });\n      it(\"should work with undefined\", function() {\n        var observableArray;\n        observableArray = Observable.concat(void 0);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should work with []\", function() {\n        var observableArray;\n        observableArray = Observable.concat([]);\n        return assert.equal(observableArray.size(), 0);\n      });\n      it(\"should return an observable array that changes based on changes in inputs\", function() {\n        var item, letters, nullable, numbers, observableArray;\n        numbers = Observable([1, 2, 3]);\n        letters = Observable([\"a\", \"b\", \"c\"]);\n        item = Observable({});\n        nullable = Observable(null);\n        observableArray = Observable.concat(numbers, \"literal\", letters, item, nullable);\n        assert.equal(observableArray().length, 3 + 1 + 3 + 1);\n        assert.equal(observableArray()[0], 1);\n        assert.equal(observableArray()[3], \"literal\");\n        assert.equal(observableArray()[4], \"a\");\n        assert.equal(observableArray()[7], item());\n        numbers.push(4);\n        assert.equal(observableArray().length, 9);\n        nullable(\"cool\");\n        return assert.equal(observableArray().length, 10);\n      });\n      it(\"should work with observable functions that return arrays\", function() {\n        var computedArray, item, observableArray;\n        item = Observable(\"wat\");\n        computedArray = Observable(function() {\n          return [item()];\n        });\n        observableArray = Observable.concat(computedArray, computedArray);\n        assert.equal(observableArray().length, 2);\n        assert.equal(observableArray()[1], \"wat\");\n        item(\"yolo\");\n        return assert.equal(observableArray()[1], \"yolo\");\n      });\n      it(\"should have a push method\", function() {\n        var observable, observableArray;\n        observableArray = Observable.concat();\n        observable = Observable(\"hey\");\n        observableArray.push(observable);\n        assert.equal(observableArray()[0], \"hey\");\n        observable(\"wat\");\n        assert.equal(observableArray()[0], \"wat\");\n        observableArray.push(\"cool\");\n        observableArray.push(\"radical\");\n        return assert.equal(observableArray().length, 3);\n      });\n      it(\"should be observable\", function(done) {\n        var observableArray;\n        observableArray = Observable.concat();\n        observableArray.observe(function(items) {\n          assert.equal(items.length, 3);\n          return done();\n        });\n        return observableArray.push([\"A\", \"B\", \"C\"]);\n      });\n      return it(\"should have an each method\", function() {\n        var n, observableArray;\n        observableArray = Observable.concat([\"A\", \"B\", \"C\"]);\n        n = 0;\n        observableArray.each(function() {\n          return n += 1;\n        });\n        return assert.equal(n, 3);\n      });\n    });\n    return describe(\"nesting dependencies\", function() {\n      return it(\"should update the correct observable\", function() {\n        var a, b, results;\n        a = Observable(\"a\");\n        b = Observable(\"b\");\n        results = Observable(function() {\n          var r;\n          r = Observable.concat();\n          r.push(a);\n          r.push(b);\n          return r;\n        });\n        assert.equal(results().first(), \"a\");\n        a(\"newA\");\n        return assert.equal(results().first(), \"newA\");\n      });\n    });\n  });\n\n}).call(this);\n",
              "type": "blob"
            }
          },
          "progenitor": {
            "url": "https://danielx.net/editor/"
          },
          "config": {
            "version": "0.3.8"
          },
          "version": "0.3.8",
          "entryPoint": "main",
          "repository": {
            "branch": "master",
            "default_branch": "master",
            "full_name": "distri/observable",
            "homepage": "http://observable.us",
            "description": null,
            "html_url": "https://github.com/distri/observable",
            "url": "https://api.github.com/repos/distri/observable",
            "publishBranch": "gh-pages"
          },
          "dependencies": {}
        },
        "bindable": {
          "source": {
            "LICENSE": {
              "path": "LICENSE",
              "content": "The MIT License (MIT)\n\nCopyright (c) 2014 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
              "mode": "100644",
              "type": "blob"
            },
            "README.coffee.md": {
              "path": "README.coffee.md",
              "content": "Bindable\n========\n\nAdd event binding to objects.\n\n>     bindable = Bindable()\n>     bindable.on \"greet\", ->\n>       console.log \"yo!\"\n>     bindable.trigger \"greet\"\n>     #=> \"yo!\" is printed to log\n\nUse as a mixin.\n\n>    self.include Bindable\n\n    module.exports = (I={}, self={}) ->\n      eventCallbacks = {}\n\nAdds a function as an event listener.\n\nThis will call `coolEventHandler` after `yourObject.trigger \"someCustomEvent\"`\nis called.\n\n>     yourObject.on \"someCustomEvent\", coolEventHandler\n\nHandlers can be attached to namespaces as well. The namespaces are only used\nfor finer control of targeting event removal. For example if you are making a\ncustom drawing system you could unbind `\".Drawable\"` events and add your own.\n\n>     yourObject.on \"\"\n\n      self.on = (namespacedEvent, callback) ->\n        [event, namespace] = namespacedEvent.split(\".\")\n\n        # HACK: Here we annotate the callback function with namespace metadata\n        # This will probably lead to some strange edge cases, but should work fine\n        # for simple cases.\n        if namespace\n          callback.__PIXIE ||= {}\n          callback.__PIXIE[namespace] = true\n\n        eventCallbacks[event] ||= []\n        eventCallbacks[event].push(callback)\n\n        return self\n\nRemoves a specific event listener, or all event listeners if\nno specific listener is given.\n\nRemoves the handler coolEventHandler from the event `\"someCustomEvent\"` while\nleaving the other events intact.\n\n>     yourObject.off \"someCustomEvent\", coolEventHandler\n\nRemoves all handlers attached to `\"anotherCustomEvent\"`\n\n>     yourObject.off \"anotherCustomEvent\"\n\nRemove all handlers from the `\".Drawable\" namespace`\n\n>     yourObject.off \".Drawable\"\n\n      self.off = (namespacedEvent, callback) ->\n        [event, namespace] = namespacedEvent.split(\".\")\n\n        if event\n          eventCallbacks[event] ||= []\n\n          if namespace\n            # Select only the callbacks that do not have this namespace metadata\n            eventCallbacks[event] = eventCallbacks.filter (callback) ->\n              !callback.__PIXIE?[namespace]?\n\n          else\n            if callback\n              remove eventCallbacks[event], callback\n            else\n              eventCallbacks[event] = []\n        else if namespace\n          # No event given\n          # Select only the callbacks that do not have this namespace metadata\n          # for any events bound\n          for key, callbacks of eventCallbacks\n            eventCallbacks[key] = callbacks.filter (callback) ->\n              !callback.__PIXIE?[namespace]?\n\n        return self\n\nCalls all listeners attached to the specified event.\n\n>     # calls each event handler bound to \"someCustomEvent\"\n>     yourObject.trigger \"someCustomEvent\"\n\nAdditional parameters can be passed to the handlers.\n\n>     yourObject.trigger \"someEvent\", \"hello\", \"anotherParameter\"\n\n      self.trigger = (event, parameters...) ->\n        callbacks = eventCallbacks[event]\n\n        if callbacks\n          callbacks.forEach (callback) ->\n            callback.apply(self, parameters)\n\n        return self\n\n      return self\n\nHelpers\n-------\n\nRemove a value from an array.\n\n    remove = (array, value) ->\n      index = array.indexOf(value)\n\n      if index >= 0\n        array.splice(index, 1)[0]\n",
              "mode": "100644",
              "type": "blob"
            },
            "pixie.cson": {
              "path": "pixie.cson",
              "content": "entryPoint: \"README\"\nversion: \"0.2.0\"\n",
              "mode": "100644",
              "type": "blob"
            },
            "test/bindable.coffee": {
              "path": "test/bindable.coffee",
              "content": "test = it\nok = assert\nequal = assert.equal\n\nBindable = require \"../README\"\n\ndescribe \"Bindable\", ->\n\n  test \"#bind and #trigger\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"Multiple bindings\", ->\n    o = Bindable()\n\n    o.on(\"test\", -> ok true)\n    o.on(\"test\", -> ok true)\n\n    o.trigger(\"test\")\n\n  test \"#trigger arguments\", ->\n    o = Bindable()\n\n    param1 = \"the message\"\n    param2 = 3\n\n    o.on \"test\", (p1, p2) ->\n      equal(p1, param1)\n      equal(p2, param2)\n\n    o.trigger \"test\", param1, param2\n\n  test \"#unbind\", ->\n    o = Bindable()\n\n    callback = ->\n      ok false\n\n    o.on \"test\", callback\n    # Unbind specific event\n    o.off \"test\", callback\n    o.trigger \"test\"\n\n    o.on \"test\", callback\n    # Unbind all events\n    o.off \"test\"\n    o.trigger \"test\"\n\n  test \"#trigger namespace\", ->\n    o = Bindable()\n    o.on \"test.TestNamespace\", ->\n      ok true\n\n    o.trigger \"test\"\n\n    o.off \".TestNamespace\"\n    o.trigger \"test\"\n\n  test \"#unbind namespaced\", ->\n    o = Bindable()\n\n    o.on \"test.TestNamespace\", ->\n      ok true\n\n    o.trigger \"test\"\n\n    o.off \".TestNamespace\", ->\n    o.trigger \"test\"\n",
              "mode": "100644",
              "type": "blob"
            }
          },
          "distribution": {
            "README": {
              "path": "README",
              "content": "(function() {\n  var remove,\n    __slice = [].slice;\n\n  module.exports = function(I, self) {\n    var eventCallbacks;\n    if (I == null) {\n      I = {};\n    }\n    if (self == null) {\n      self = {};\n    }\n    eventCallbacks = {};\n    self.on = function(namespacedEvent, callback) {\n      var event, namespace, _ref;\n      _ref = namespacedEvent.split(\".\"), event = _ref[0], namespace = _ref[1];\n      if (namespace) {\n        callback.__PIXIE || (callback.__PIXIE = {});\n        callback.__PIXIE[namespace] = true;\n      }\n      eventCallbacks[event] || (eventCallbacks[event] = []);\n      eventCallbacks[event].push(callback);\n      return self;\n    };\n    self.off = function(namespacedEvent, callback) {\n      var callbacks, event, key, namespace, _ref;\n      _ref = namespacedEvent.split(\".\"), event = _ref[0], namespace = _ref[1];\n      if (event) {\n        eventCallbacks[event] || (eventCallbacks[event] = []);\n        if (namespace) {\n          eventCallbacks[event] = eventCallbacks.filter(function(callback) {\n            var _ref1;\n            return ((_ref1 = callback.__PIXIE) != null ? _ref1[namespace] : void 0) == null;\n          });\n        } else {\n          if (callback) {\n            remove(eventCallbacks[event], callback);\n          } else {\n            eventCallbacks[event] = [];\n          }\n        }\n      } else if (namespace) {\n        for (key in eventCallbacks) {\n          callbacks = eventCallbacks[key];\n          eventCallbacks[key] = callbacks.filter(function(callback) {\n            var _ref1;\n            return ((_ref1 = callback.__PIXIE) != null ? _ref1[namespace] : void 0) == null;\n          });\n        }\n      }\n      return self;\n    };\n    self.trigger = function() {\n      var callbacks, event, parameters;\n      event = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      callbacks = eventCallbacks[event];\n      if (callbacks) {\n        callbacks.forEach(function(callback) {\n          return callback.apply(self, parameters);\n        });\n      }\n      return self;\n    };\n    return self;\n  };\n\n  remove = function(array, value) {\n    var index;\n    index = array.indexOf(value);\n    if (index >= 0) {\n      return array.splice(index, 1)[0];\n    }\n  };\n\n}).call(this);\n",
              "type": "blob"
            },
            "pixie": {
              "path": "pixie",
              "content": "module.exports = {\"entryPoint\":\"README\",\"version\":\"0.2.0\"};",
              "type": "blob"
            },
            "test/bindable": {
              "path": "test/bindable",
              "content": "(function() {\n  var Bindable, equal, ok, test;\n\n  test = it;\n\n  ok = assert;\n\n  equal = assert.equal;\n\n  Bindable = require(\"../README\");\n\n  describe(\"Bindable\", function() {\n    test(\"#bind and #trigger\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      return o.trigger(\"test\");\n    });\n    test(\"Multiple bindings\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      o.on(\"test\", function() {\n        return ok(true);\n      });\n      return o.trigger(\"test\");\n    });\n    test(\"#trigger arguments\", function() {\n      var o, param1, param2;\n      o = Bindable();\n      param1 = \"the message\";\n      param2 = 3;\n      o.on(\"test\", function(p1, p2) {\n        equal(p1, param1);\n        return equal(p2, param2);\n      });\n      return o.trigger(\"test\", param1, param2);\n    });\n    test(\"#unbind\", function() {\n      var callback, o;\n      o = Bindable();\n      callback = function() {\n        return ok(false);\n      };\n      o.on(\"test\", callback);\n      o.off(\"test\", callback);\n      o.trigger(\"test\");\n      o.on(\"test\", callback);\n      o.off(\"test\");\n      return o.trigger(\"test\");\n    });\n    test(\"#trigger namespace\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test.TestNamespace\", function() {\n        return ok(true);\n      });\n      o.trigger(\"test\");\n      o.off(\".TestNamespace\");\n      return o.trigger(\"test\");\n    });\n    return test(\"#unbind namespaced\", function() {\n      var o;\n      o = Bindable();\n      o.on(\"test.TestNamespace\", function() {\n        return ok(true);\n      });\n      o.trigger(\"test\");\n      o.off(\".TestNamespace\", function() {});\n      return o.trigger(\"test\");\n    });\n  });\n\n}).call(this);\n",
              "type": "blob"
            }
          },
          "progenitor": {
            "url": "https://danielx.net/editor/"
          },
          "version": "0.2.0",
          "entryPoint": "README",
          "repository": {
            "branch": "master",
            "default_branch": "master",
            "full_name": "distri/bindable",
            "homepage": null,
            "description": "Event binding",
            "html_url": "https://github.com/distri/bindable",
            "url": "https://api.github.com/repos/distri/bindable",
            "publishBranch": "gh-pages"
          },
          "dependencies": {}
        }
      }
    }
  }
}